---
layout: post
title: Entire Algorithm until 18, June.
date: 2020-06-18
description: Entire Algorithm until 18, June.
thumbnail: food2.jpg
categories: Algorithm

# Information for the author block
author : Loui
---


<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Total solved problems with problems before starting github</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>{ %raw % }</p>
<p>[1. n! 끝자리 0의 개수]</p>
<p>- n!을 할 때 인수 5가 몇 개 들어가는지 세면됨</p>
<p>ex) n=30 : 5, 10, 15 20, 25=(5x5), 30 이므로 6개.</p>
<p>[2. 인접하지 않은 인덱스만 골라서 원소 합 최대 구하기 – House robber]</p>
<p>- DP로 푸는 거임. 배열하나 설정하고, 해당 배열에 max(현재인덱스 + 2번째 전 인덱스, 1번째 전인덱스)를 하면서, 계속 더해나가면 됨.</p>
<p>int rob(vector&lt;int&gt;&amp; nums) {</p>
<p>if(nums.empty() || nums.size()==0) return 0;</p>
<p>if(nums.size()==1) return nums[0];</p>
<p>int prev_1=nums[1];</p>
<p>int prev_2=nums[0];</p>
<p>int cur;</p>
<p>for(int i=2;i&lt;nums.size();i++){</p>
<p>if(nums[i]+prev_2&gt;prev_1){</p>
<p>cur=prev_1;</p>
<p>prev_1=nums[i]+prev_2;</p>
<p>prev_2=max(cur,prev_2);</p>
<p>}</p>
<p>else</p>
<p>prev_2=prev_1;</p>
<p>}</p>
<p>return max(prev_1,prev_2);</p>
<p>}</p>
<p>[3. 이진수 스트링의 합]</p>
<p>- 스트링을 인트로 변환하려면 atoi(s.c_str); 을 사용하면 됨.</p>
<p>- 인트를 바이너리 스트링으로 출력하려면 biset 라이브러리를 이용하면 됨.</p>
<p>ex) biset&lt;셋의 크기&gt;(인트 변수).to_string();</p>
<p>- 또는 answer = sum%2; sum/=2 를 한후 얻은 문자열을 reverse하면 됨.</p>
<p>- 이 문제는 각 스트링의 오른쪽 끝부터 시작하여 carry값을 유지하며 진행함.</p>
<p>즉, 둘다 1이었을 경우 합은 2 인데, 2%2==0 이므로, 해당 위치에는 0을 대입하고 캐리 값은 2 /1 = 1을 가지고 올라감. 그럼으로써, 캐리가 될 수 있도록 함.</p>
<p>string addBinary(string a, string b) {</p>
<p>int i=a.size()-1;</p>
<p>int j=b.size()-1;</p>
<p>int cur=0;</p>
<p>string answer;</p>
<p>while(i&gt;=0 || j&gt;=0|| cur!=0){</p>
<p>if(i&gt;=0){</p>
<p>cur+=a[i]=='0'?0:1;</p>
<p>i--;</p>
<p>}</p>
<p>if(j&gt;=0){</p>
<p>cur+=b[j]=='0'?0:1;</p>
<p>j--;</p>
<p>}</p>
<p>answer+=((cur%2)==0?'0':'1');</p>
<p>cur/=2;</p>
<p>}</p>
<p>reverse(answer.begin(),answer.end()); //이렇게 해주는 것이 O(n)으로 풀수있는 방법임.</p>
<p>return answer;</p>
<p>}</p>
<p>[4. 배열의 각 원소들을 연이어서 수를 만들 때, 그 수의 +1을 리턴하는 문제 – Plus One]</p>
<p>- 즉, [4,3,2,1] 이면 [4,3,2,2]를 리턴하는 문제, 왜냐하면 4321+1=4322</p>
<p>수의 범위가 크지 않다면 아래 방법처럼 간단한 덧셈과 인트 -&gt; 스트링 -&gt; 벡터변환으로 풀 수 있음.</p>
<p>vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {</p>
<p>int answer=digits[0];</p>
<p>for(int i=1;i&lt;digits.size();i++){</p>
<p>answer=answer*10+digits[i];</p>
<p>}</p>
<p>answer++;</p>
<p>string temp=to_string(answer);</p>
<p>vector&lt;int&gt; ret;</p>
<p>for(int i=0;i&lt;temp.size();i++){</p>
<p>ret.push_back(temp[i]-48);</p>
<p>}</p>
<p>return ret;</p>
<p>}</p>
<p>그러나 수의 범위가 크다면, 덧셈을 이용할 수 없음. 아래 방법을 이용하면 됨.</p>
<p>vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {</p>
<p>vector&lt;int&gt;::reverse_iterator iter=digits.rbegin();</p>
<p>//rbegin 하려면 reverse_iterator 라고 명시해줘야한다.</p>
<p>vector&lt;int&gt; answer;</p>
<p>int carry=1;</p>
<p>for(;iter!=digits.rend();iter++){</p>
<p>if(carry+*iter&gt;=10){</p>
<p>carry=1;</p>
<p>answer.push_back(0);</p>
<p>}</p>
<p>else{</p>
<p>answer.push_back(*iter+carry);</p>
<p>carry=0;</p>
<p>}</p>
<p>}</p>
<p>// 인풋이 9 였을 때, answer에 10 이 들어가야되는데 0 만들어감.</p>
<p>// 이런 경우른 대비해서 끝났을 때 carry가 1이면 1을 한번더 push 해줌</p>
<p>if(carry==1)</p>
<p>answer.push_back(1);</p>
<p>reverse(answer.begin(),answer.end());</p>
<p>return answer;</p>
<p>}</p>
<p>[4. 해당 수가 power of prime인지 확인하는 문제]</p>
<p>- 사실 power of three 문제였는데, 3도 소수이므로 동일하게 풀 수 있다.</p>
<p>- 3의 제곱들 중 최댓 값을 안다면(1162261467, Math.log(0x7fffffff)) 해당 수가 3으로 나누어지면 power of three이다.</p>
<p>- 마찬가지로 다른 소수의 제곱들 중 최댓 값을 알면 풀 수 있다.</p>
<p>[5. 옆 사람과 가장 멀리 떨어져 앉는 문제]</p>
<p>- 모든 인덱스에 대해서 나의 오른쪽 사람과의 거리를 right 배열에 저장하고, 왼쪽 사람과의 거리를 left에 저장한다. 그 후 두 배열의 같은 인덱스에 대해서 min값을 구하고, 최종적으로 구해진 배열의 max값을 리턴하면 된다.</p>
<p>- 이때 양쪽 끝에는 사람이 없는 것으로 간주한다. 이것 때문에 나의 알고리즘이 속도가 많이 느려졌다. 이것을 처리하려고 count를 사용했는데, 이때 마지막 자리와 끝 자리와의 거리가 구해진다면, 그 사이의 거리는 min처리에서 제대로 처리되므로 상관 없다.</p>
<p>-90.24%의 속도가 나왔다.</p>
<p>int alloc_right(int* cur, vector&lt;int&gt;&amp; seats,int index,int count){</p>
<p>if(index&gt;=seats.size()) return count+1;</p>
<p>if(seats[index]==1) return 1;</p>
<p>cur[index]=alloc_right(cur,seats,index+1,count+1);</p>
<p>return cur[index]+1;</p>
<p>}</p>
<p>int alloc_left(int* cur, vector&lt;int&gt;&amp; seats,int index,int count){</p>
<p>if(index&lt;0) return count+1;</p>
<p>if(seats[index]==1) return 1;</p>
<p>cur[index]=alloc_left(cur,seats,index-1,count+1);</p>
<p>return cur[index]+1;</p>
<p>}</p>
<p>int maxDistToClosest(vector&lt;int&gt;&amp; seats) {</p>
<p>int* left=new int[seats.size()]{0,};</p>
<p>int* right=new int[seats.size()]{0,};</p>
<p>for(int i=0, j=0;i&lt;seats.size();i++){</p>
<p>if(seats[i]==1) continue;</p>
<p>j=i;</p>
<p>i=i+alloc_right(right,seats,j,0)-1;</p>
<p>}</p>
<p>for(int i=seats.size()-1,j=i;i&gt;=0;i--){</p>
<p>if(seats[i]==1) continue;</p>
<p>j=i;</p>
<p>i=i-alloc_left(left,seats,j,0)+1;</p>
<p>}</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(int i=0;i&lt;seats.size();i++){</p>
<p>answer.push_back(min(left[i],right[i]));</p>
<p>}</p>
<p>int maximum=INT_MIN;</p>
<p>for(int i=0;i&lt;answer.size();i++)</p>
<p>maximum=max(maximum,answer[i]);</p>
<blockquote>
<p>return maximum;</p>
</blockquote>
<p>}</p>
<p>[6. 큐로 스택 구현하기]</p>
<p>- 큐는 항상 front에서 pop하기 때문에, stack처럼 LIFO로 pop 하려면, pop할 때 queue.size()-1만큼 큐 앞에 원소를 지워서 뒤에 붙여준 후, 마지막에 pop을 해야 됨. 이때 C++ 에서는 pop을 하면 원소가 지워지기만 하고 void 가 return 되므로, queue.front() 로 먼저 해당 원소를 저장해 주어야 함.</p>
<p>queue&lt;int&gt; Que;</p>
<p>/** Push element x onto stack. */</p>
<p>void push(int x) {</p>
<p>Que.push(x);</p>
<p>}</p>
<p>/** Removes the element on top of the stack and returns that element. */</p>
<p>int pop() {</p>
<p>int a;</p>
<p>for(int i=0;i&lt;Que.size()-1;i++){</p>
<p>Que.push(Que.front());</p>
<p>Que.pop();</p>
<p>}</p>
<p>a=Que.front();</p>
<p>Que.pop();</p>
<p>return a;</p>
<p>}</p>
<p>/** Get the top element. */</p>
<p>int top() {</p>
<p>return Que.back();</p>
<p>}</p>
<p>/** Returns whether the stack is empty. */</p>
<p>bool empty() {</p>
<p>return Que.empty();</p>
<p>}</p>
<p>[7. 균형트리인지 확인하기]</p>
<p>-postOrder로 트리를 탐색하는 데, 이때 재귀로 각 트리의 왼쪽 서브트리와 오른쪽 서브트리의 높이 중 큰 값을 취하여 리턴해주고, 만약 왼쪽, 오른쪽 서브트리의 높이차가 1이상이면 flag=false로 하고, 아니면 falg=true인 상태로 놔둠.</p>
<p>bool flag=true;</p>
<p>int postOrder(TreeNode* root){</p>
<p>if(!root) return 0;</p>
<p>int left=0,right=0;</p>
<p>left+=postOrder(root-&gt;left);</p>
<p>right+=postOrder(root-&gt;right);</p>
<p>if(abs(left-right)&gt;1)</p>
<p>flag=false;</p>
<p>return max(left,right)+1;</p>
<p>}</p>
<p>bool isBalanced(TreeNode* root) {</p>
<p>postOrder(root);</p>
<p>return flag;</p>
<p>}</p>
<p>[8. License key Formatting – 주어진 K에 대해서 dash 사이에 K개의 문자를 배치하는 문제]</p>
<p>- 문자열 전체를 대문자로 바꾸기 위해서는 std::transform(S.begin(),S.end(),S.begin(), ::toupper)를 하면 된다.</p>
<p>- 문자열 끝에서부터 시작하여 dash를 제외한 alphanumeric의 개수를 count로 세주고, given K만큼 세어졌을 때, dash를 추가한다.</p>
<p>- 또한 문자열 맨 처음의 연속된 dash를 방지하기 위하여, dash가 아닌 제일 첫번째 문자의 인덱스를 문자열 시작점으로 한다.</p>
<p>string licenseKeyFormatting(string S, int K) {</p>
<p>string answer;</p>
<p>int count=1;</p>
<p>int begin=0;</p>
<p>while(S[begin]=='-') begin++; // 맨 앞에 연이은 dash를 방지함.</p>
<p>for(int i=S.size()-1;i&gt;=begin;i--){</p>
<p>if(count%(K+1)==0){</p>
<p>answer+='-';</p>
<p>count=1;</p>
<p>i++; // K개 만큼 센후 dash추가하려는 데, 그 원소가 dash가 아닐 경우를 대비.</p>
<p>continue;</p>
<p>}</p>
<p>if(S[i]!='-'){</p>
<p>answer+=S[i];</p>
<p>count++;</p>
<p>}</p>
<p>}</p>
<p>std::transform(answer.begin(),answer.end(),answer.begin(),::toupper);</p>
<p>reverse(answer.begin(),answer.end());</p>
<p>return answer;</p>
<p>}</p>
<p>[9. Find Pivot Index – 인덱스를 기준으로 왼쪽과 오른쪽 원소들의 합이 같은 인덱스(pivot)을 찾는문제]</p>
<p>int pivotIndex(vector&lt;int&gt;&amp; nums) {</p>
<p>nums.push_back(0);</p>
<p>int pivot=0;</p>
<p>int left=0;</p>
<p>int right=0;</p>
<p>for(int i=1;i&lt;nums.size();i++)</p>
<p>right+=nums[i];</p>
<p>while(pivot&lt;nums.size()-1){</p>
<p>if(left==right)</p>
<p>break;</p>
<p>left+=nums[pivot];</p>
<p>right-=nums[pivot+1];</p>
<p>pivot++;</p>
<p>}</p>
<p>return pivot==nums.size()-1? -1 : pivot;</p>
<p>}</p>
<p>[10. power of two – 주어진 수가 2의 제곱 꼴인지 확인하는 문제]</p>
<p>- 비트연산을 이용하여 푼다. 2의 제곱들은 1000, 0100, 0010, 0001 등 비트형태에서 1을 하나 가지고 있다. 이때 2의 제곱들 -1은 0111, 0011, 0001, 0000 등 2의 제곱들보다 한자리 낮은 수부터 1로 가득 차있다.</p>
<p>-그러므로 n&amp;(n-1)==0 이면 2의 제곱이다.</p>
<p>bool isPowerOfTwo(int n) {</p>
<p>return n&gt;0 &amp;&amp; (n&amp;(n-1))==0 ;</p>
<p>}</p>
<p>[11. Reverse Vowels of a String – 모음 위치를 반대 순서로 바꾸는 문제]</p>
<p>- 한번 훑으면서 모음을 벡터에 저장하고, 그 모음의 인덱스를 다른 벡터에 저장한 후, 인덱스의 역순에 따라서 모음을 넣어주면 됨.</p>
<p>-주의할 점은 vector가 비었을 때, vec.back()을 호출하면 heap overflow 에러가 발생한다는 것임.</p>
<p>if(s.size()&lt;2)</p>
<p>return s;</p>
<p>vector&lt;char&gt; table;</p>
<p>vector&lt;int&gt; index;</p>
<p>for(int i=0; i&lt;s.size();i++){</p>
<p>if(s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u'||</p>
<p>s[i]=='A'||s[i]=='E'||s[i]=='I'||s[i]=='O'||s[i]=='U'){</p>
<p>table.push_back(s[i]);</p>
<p>index.push_back(i);</p>
<p>}</p>
<p>}</p>
<p>reverse(index.begin(),index.end());</p>
<p>string answer;</p>
<p>int i=0;</p>
<p>while(i&lt;s.size()){</p>
<p>if(!index.empty()&amp;&amp;i==index.back()){</p>
<p>answer+=table.back();</p>
<p>table.pop_back();</p>
<p>index.pop_back();</p>
<p>}</p>
<p>else{</p>
<p>answer+=s[i];</p>
<p>}</p>
<p>i++;</p>
<p>}</p>
<p>return answer;</p>
<p>[12. <strong> Second Minimum Node In a Binary Tree – 두개의 자식 중 최소 값이 부모가 되는 이진트리에서 두번째 최소값 찾는 문제]</strong></p>
<p>- 전부 순회를 하되, 두번째 값을 LONG_MAX로 초기화 해놓고, 순회할때마다 해당 노드의 value가 최소값(루트값) 보다 크고, 현재의 second값보다 작은지 확인하여, 조건이 만족하면 second=value를 하면 됨.</p>
<p>int first;</p>
<p>long second;</p>
<p>void search(TreeNode* root){</p>
<p>if(!root) return;</p>
<p>if(first&lt;root-&gt;val &amp;&amp; root-&gt;val&lt;second)</p>
<p>second=root-&gt;val;</p>
<p>search(root-&gt;left);</p>
<p>search(root-&gt;right);</p>
<p>}</p>
<p>int findSecondMinimumValue(TreeNode* root) {</p>
<p>first=root-&gt;val;</p>
<p>second=LONG_MAX;</p>
<p>search(root);</p>
<p>return second==LONG_MAX? -1: second;</p>
<p>}</p>
<p>[13. <strong> Convert a Number to Hexadecimal – 십진수를 16진수 스트링으로 바꾸는 문제]</strong></p>
<p>- 스트링하나에 0부터 f까지 지정해 준 후, 주어진 십진수를 16으로 % 연산을 하여 해당 인덱스의 값을 결과 값에 더해나간다.</p>
<p>- 마지막에 해당 값을 reverse해주면 된다.</p>
<p>- 이때 -를 다루기 위해서는 unsigned int 로 인풋값을 재 지정해준다. 그럴경우 -1이 unsigned int의 최대값이 된다.</p>
<p>string toHex(int num) {</p>
<p>unsigned int n=num;</p>
<p>string table=&quot;0123456789abcdef&quot;;</p>
<p>string answer;</p>
<p>do{</p>
<p>answer+=table[n%16];</p>
<p>n/=16;</p>
<p>}while(n);</p>
<p>return {answer.rbegin(),answer.rend()};</p>
<p>}</p>
<p>[14 <strong>Quad Tree Intersection - 4개의 자식이 있는 두개의 트리에 대하여 각 자식끼리의 OR연산을 하는 문제]</strong></p>
<p><strong>-</strong> 난 아래처럼 최종 모습이 4개의 자식을 가진 노드를 만드는 건줄 알았는 데, 아닌 듯?</p>
<p>bool search(Node* root){</p>
<p>if(root-&gt;isLeaf) return root-&gt;val;</p>
<p>return search(root-&gt;topLeft)||search(root-&gt;topRight)||search(root-&gt;bottomLeft)||search(root-&gt;bottomRight);</p>
<p>}</p>
<p>Node* intersect(Node* quadTree1, Node* quadTree2) {</p>
<p>bool one=search(quadTree1-&gt;topLeft)||search(quadTree2-&gt;topLeft);</p>
<p>bool two=search(quadTree1-&gt;topRight)||search(quadTree2-&gt;topRight);</p>
<p>bool three=search(quadTree1-&gt;bottomLeft)||search(quadTree2-&gt;bottomLeft);</p>
<p>bool four=search(quadTree1-&gt;bottomRight)||search(quadTree2-&gt;bottomRight);</p>
<p>Node* answer=new Node();</p>
<p>answer-&gt;val = true;</p>
<p>answer-&gt; isLeaf = false;</p>
<p>answer-&gt;topLeft = new Node(one,true,nullptr,nullptr,nullptr,nullptr);</p>
<p>answer-&gt;topRight = new Node(two,true,nullptr,nullptr,nullptr,nullptr);</p>
<p>answer-&gt;bottomLeft = new Node(three,true,nullptr,nullptr,nullptr,nullptr);</p>
<p>answer-&gt;bottomRight = new Node(four,true,nullptr,nullptr,nullptr,nullptr);</p>
<p>return answer;</p>
<p>}</p>
<p>- 마지막에 4개의 자식이 모두 같은 boolean 값을 가지면 하나로 합쳐줘야함.</p>
<p>- 아래 2개의 방법은 다른 사람들이 푼 것으로, 읽으니까 이해할 수 있었음.</p>
<p>Node* intersect(Node* quadTree1, Node* quadTree2) {</p>
<p>if(quadTree1-&gt;isLeaf &amp;&amp; quadTree1-&gt;val) return quadTree1;</p>
<p>if(quadTree2-&gt;isLeaf &amp;&amp; quadTree2-&gt;val) return quadTree2;</p>
<p>if(quadTree1-&gt;isLeaf &amp;&amp; !quadTree1-&gt;val) return quadTree2;</p>
<p>if(quadTree2-&gt;isLeaf &amp;&amp; !quadTree2-&gt;val) return quadTree1;</p>
<p>auto tl = intersect(quadTree1-&gt;topLeft, quadTree2-&gt;topLeft);</p>
<p>auto tr = intersect(quadTree1-&gt;topRight, quadTree2-&gt;topRight);</p>
<p>auto bl = intersect(quadTree1-&gt;bottomLeft, quadTree2-&gt;bottomLeft);</p>
<p>auto br = intersect(quadTree1-&gt;bottomRight, quadTree2-&gt;bottomRight);</p>
<p>if(tl-&gt;val == tr-&gt;val &amp;&amp; tl-&gt;val == bl-&gt;val &amp;&amp; tl-&gt;val == br-&gt;val &amp;&amp; tl-&gt;isLeaf &amp;&amp; tr-&gt;isLeaf &amp;&amp; bl-&gt;isLeaf &amp;&amp; br-&gt;isLeaf)</p>
<p>return new Node(tl-&gt;val, true, nullptr, nullptr, nullptr, nullptr);</p>
<p>else</p>
<p>return new Node(false, false, tl, tr, bl, br);</p>
<p>}</p>
<p>Node* intersect(Node* quadTree1, Node* quadTree2)</p>
<p>{</p>
<p>// if a is leaf+true, choose a.</p>
<p>// if b is leaf+false, choose a.</p>
<p>if (quadTree1-&gt;isLeaf &amp;&amp; quadTree1-&gt;val == true ||</p>
<p>quadTree2-&gt;isLeaf &amp;&amp; quadTree2-&gt;val == false)</p>
<p>return quadTree1;</p>
<p>// if b is leaf+true, choose b.</p>
<p>// if a is leaf+false, choose b;</p>
<p>if (quadTree2-&gt;isLeaf &amp;&amp; quadTree2-&gt;val == true ||</p>
<p>quadTree1-&gt;isLeaf &amp;&amp; quadTree1-&gt;val == false)</p>
<p>return quadTree2;</p>
<p>// intersect.</p>
<p>Node* ret = new Node (false, false,</p>
<p>intersect (quadTree1-&gt;topLeft, quadTree2-&gt;topLeft),</p>
<p>intersect (quadTree1-&gt;topRight, quadTree2-&gt;topRight),</p>
<p>intersect (quadTree1-&gt;bottomLeft, quadTree2-&gt;bottomLeft),</p>
<p>intersect (quadTree1-&gt;bottomRight, quadTree2-&gt;bottomRight));</p>
<p>// merge if all children are leaves and have the same value.</p>
<p>if (ret-&gt;topLeft-&gt;val == ret-&gt;topRight-&gt;val &amp;&amp; ret-&gt;topLeft-&gt;val == ret-&gt;bottomLeft-&gt;val &amp;&amp;</p>
<p>ret-&gt;topLeft-&gt;val == ret-&gt;bottomRight-&gt;val &amp;&amp;</p>
<p>ret-&gt;topLeft-&gt;isLeaf &amp;&amp; ret-&gt;topRight-&gt;isLeaf &amp;&amp; ret-&gt;bottomLeft-&gt;isLeaf &amp;&amp; ret-&gt;bottomRight-&gt;isLeaf)</p>
<p>{</p>
<p>ret-&gt;val = ret-&gt;topLeft-&gt;val;</p>
<p>ret-&gt;isLeaf = true;</p>
<p>ret-&gt;topLeft = ret-&gt;topRight = ret-&gt;bottomLeft = ret-&gt;bottomRight = NULL;</p>
<p>}</p>
<p>// done.</p>
<p>return ret;</p>
<p>}</p>
<p>[15. <strong> Most Common Word – 문자열에서 금지된 단어를 제외하고 가장 많이 등장하는 단어를 찾아내는 문제]</strong></p>
<p>- map을 이용해서 각 단어마다 등장횟수를 센 후, map을 순회하면서 해당 단어가 banned되어 있지 않고, 현재의 단어보다 많이 등장하였다면 answer를 바꾸어 줌.</p>
<p>- 문자열을 소문자로 바꾸기 위해서는 transfrom(s.begin(),s.end(),s.begin(),::tolower)를 하면 됨.</p>
<p>- vector안에서 해당 아이템, 또는 문자열을 찾기 위해서는 find(vec.begin(),vec.end(),item)을 하면 해당 item의 iterator가 반환됨. 그러므로 !=vec.end() 를 조건으로 주면 해당 아이템이 없으면 false, 있으면 true가 됨.</p>
<p>std::transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);</p>
<p>unordered_map&lt;string,int&gt; table;</p>
<p>string temp;</p>
<p>for(int i=0;i&lt;paragraph.size();i++){</p>
<p>if('a'&lt;=paragraph[i] &amp;&amp; paragraph[i]&lt;='z')</p>
<p>temp+=paragraph[i];</p>
<p>else{</p>
<p>table[temp]++;</p>
<p>temp=&quot;&quot;;</p>
<p>}</p>
<p>}</p>
<p>table[temp]++; //마지막에 고려되지 못한 단어를 위해서</p>
<p>unordered_map&lt;string,int&gt;::iterator iter=table.begin();</p>
<p>string answer=&quot;&quot;;</p>
<p>int count=0;</p>
<p>for(;iter!=table.end();iter++){</p>
<p>if(std::find(banned.begin(),banned.end(),iter-&gt;first)==banned.end()&amp;&amp;iter-&gt;second&gt;count</p>
<p>&amp;&amp; 'a'&lt;=iter-&gt;first[0] &amp;&amp; iter-&gt;first[0]&lt;='z'){// 해당 문자열이 banned이고, iter가 구두점이나 공백이 아니라면</p>
<p>answer=iter-&gt;first;</p>
<p>count=iter-&gt;second;</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[16. <strong> Subtree of Another Tree – 트리 s가 트리 t를 서브트리로 가지고 있는지 확인하는 문제]</strong></p>
<p><strong>-</strong> 이렇게 푸는게 맞는지 모르겠는데, 일단 오래걸렸음.</p>
<p>- 먼저 트리 t의 shape을 vector에 담고, 트리 s에서 트리 t의 root를 찾은 순간, 그때부터 트리 t와 같은 subtree구조를 가졌는지 확인하는 방식임.</p>
<p>bool answer=false;</p>
<p>vector&lt;int&gt; t_table;</p>
<p>int i;</p>
<p>int first;</p>
<p>void t_search(TreeNode* root){ //4, 1, min, min, 2, min, min</p>
<p>if(!root){</p>
<p>t_table.push_back(INT_MIN);</p>
<p>return;</p>
<p>}</p>
<p>t_table.push_back(root-&gt;val);</p>
<p>t_search(root-&gt;left);</p>
<p>t_search(root-&gt;right);</p>
<p>}</p>
<p>void s_search(TreeNode* root){</p>
<p>if(!root) return;</p>
<p>if(root-&gt;val==first){ //if tree t's root is found, then check whether the subtree is same with t</p>
<p>check(root);</p>
<p>}</p>
<p>if(answer==true)</p>
<p>return;</p>
<p>s_search(root-&gt;left);</p>
<p>s_search(root-&gt;right);</p>
<p>}</p>
<p>void check(TreeNode* root){</p>
<p>if(!root &amp;&amp; t_table[i]==INT_MIN){</p>
<p>if(i==t_table.size()-1){</p>
<p>answer=true;</p>
<p>return;</p>
<p>}</p>
<p>i++;</p>
<p>return;</p>
<p>}</p>
<p>if((!root &amp;&amp; t_table[i]!=INT_MIN) || ( root &amp;&amp;root-&gt;val !=t_table[i])){</p>
<p>i=0;</p>
<p>return;</p>
<p>}</p>
<p>i++;</p>
<p>check(root-&gt;left);</p>
<p>check(root-&gt;right);</p>
<p>}</p>
<p>bool isSubtree(TreeNode* s, TreeNode* t) {</p>
<p>t_search(t);</p>
<p>first=t-&gt;val;</p>
<p>i=0;</p>
<p>s_search(s);</p>
<p>return answer;</p>
<p>}</p>
<p>- 그리고 훨씬 좋은 solution을 봐버렸다.</p>
<p>class Solution {</p>
<p>public:</p>
<p>bool isSubtree(TreeNode* s, TreeNode* t) {</p>
<p>if(!s) return false;</p>
<p>if (isSame(s,t)) return true;</p>
<p>return isSubtree(s-&gt;left,t) || isSubtree(s-&gt;right,t);</p>
<p>}</p>
<p>bool isSame(TreeNode *s, TreeNode *t)</p>
<p>{</p>
<p>if (!s &amp;&amp; !t) return true;</p>
<p>if (!s || !t) return false;</p>
<p>if (s-&gt;val != t-&gt;val) return false;</p>
<p>return isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</p>
<p>}</p>
<p>};</p>
<p>[17. <strong>Remove Duplicates from Sorted List – 링크드리스트에서 중복 원소 제거하는 문제]</strong></p>
<p>- Discussion 찾아보니까 new로 생성한거 아니면 dlete할 필요 없다는 거 같은데 잘 모르겠음.</p>
<p>- 일단 같은 원소가 아닐때까지 loop돌고 다른원소 발견하면 이전 원소의 맨 앞에거랑 연결해주는 방식으로 했음. 이것이 속도가 좀 빠름.</p>
<p>ListNode* deleteDuplicates(ListNode* head) {</p>
<p>ListNode* answer= head;</p>
<p>ListNode* temp;</p>
<p>int value;</p>
<p>while(head){</p>
<p>value=head-&gt;val;</p>
<p>temp=head;</p>
<p>while(temp-&gt;next &amp;&amp; value==temp-&gt;next-&gt;val) temp=temp-&gt;next;</p>
<p>if(!temp-&gt;next){</p>
<p>head-&gt;next=nullptr;</p>
<p>head=head-&gt;next;</p>
<p>break;</p>
<p>}</p>
<p>else{</p>
<p>head-&gt;next=temp-&gt;next;</p>
<p>head=head-&gt;next;</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[18. <strong>Add to Array-Form of Intege – 벡터로 정수가 주어지고, 또 다른 정수 K가 주어져서 두개를 더한 후 벡터모양을 리턴하는 문제]</strong></p>
<p>- 벡터를 일단 정수로 바꿔서 더할려고 했는데, 정수 값을 엄청 크게 줘서 안됨.</p>
<p>- 그래서 carry를 사용해서 풀었는 데, 내가봤는데도 너무 느린 효율을 가짐</p>
<p>- 참고로 K%10 은 마지막 숫자를 리턴해줌. K/10은 마지막 숫자를 제외한 숫자를 리턴함.</p>
<p>vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) {</p>
<p>int cur=0;</p>
<p>int carry=0;</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(int i=A.size()-1;i&gt;=0;i--){</p>
<p>cur=A[i]+K%10+carry;</p>
<p>if(cur&gt;=10) {</p>
<p>carry=1;</p>
<p>cur%=10;</p>
<p>}</p>
<p>else carry=0;</p>
<p>K/=10;</p>
<p>answer.push_back(cur);</p>
<p>}</p>
<p>while(K){ //A의 자릿수가 K보다 작은 경우를 cover함.</p>
<p>cur=K%10+carry;</p>
<p>if(cur&gt;=10){</p>
<p>carry=1;</p>
<p>cur%=10;</p>
<p>}</p>
<p>else carry=0;</p>
<p>answer.push_back(cur);</p>
<p>K/=10;</p>
<p>}</p>
<p>if(carry==1) answer.push_back(1); //답이 1082 막 이런데 벡터에 082 이런거 까지만 들어가는 경우 cover함</p>
<p>return {answer.rbegin(),answer.rend()};</p>
<p>}</p>
<p>- 이거는 나랑 같은 방식인데 설명을 더 잘해놓음.</p>
<p>/* An important observation ---</p>
<p>1) num%10 gives us the last digit of a number</p>
<p>2) num = num/10 cuts off the last digit of the number</p>
<p>3) numVector.back() gives us the last digit of the number in vector form</p>
<p>4) numVector.pop_back() cuts off the last digit of the number in vector form</p>
<p>5) The extra space required can be reduced by overwriting the first vector.</p>
<p>*/</p>
<p>class Solution</p>
<p>{</p>
<p>public:</p>
<p>vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; a, int k);</p>
<p>};</p>
<p>/* Returns the sum of 2 numbers in vector form */</p>
<p>vector&lt;int&gt; Solution :: addToArrayForm(vector&lt;int&gt;&amp; a, int k)</p>
<p>{</p>
<p>// Get the length of the first number</p>
<p>int n = a.size();</p>
<p>// Vector to store the answer</p>
<p>vector&lt;int&gt; answer;</p>
<p>/* Start adding both the numbers from the end */</p>
<p>int carry = 0;</p>
<p>// As long as one of the number exists, keep adding them</p>
<p>while(!a.empty() || k!=0)</p>
<p>{</p>
<p>// Get the last digits of both the numbers. If a vector has finished off, the last digit is zero</p>
<p>int lastDigit_1 = a.empty() ? 0 : a.back();</p>
<p>int lastDigit_2 = k%10;</p>
<p>// Sum up the digits and add the carry</p>
<p>int sum = lastDigit_1 + lastDigit_2 + carry;</p>
<p>answer.push_back(sum%10);</p>
<p>carry = sum/10;</p>
<p>// Remove the last digits of both the numbers</p>
<p>if(!a.empty()) a.pop_back();</p>
<p>k = k/10;</p>
<p>}</p>
<p>// If the carry is remaining, add it</p>
<p>if(carry!=0) answer.push_back(carry);</p>
<p>// Reverse the answer, since we were summing up from the end</p>
<p>reverse(answer.begin(), answer.end());</p>
<p>// Return the answer in vector format</p>
<p>return answer;</p>
<p>}</p>
<p>[19. <strong>Long Pressed Name – 중복적으로 눌린 키보드 문자로 원래의 이름을 만들 수 있는지 확인하는 문제.]</strong></p>
<p>- 문제 설명하기가 힘들어서 원본을 붙여 넣음.</p>
<p>Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get <em>long pressed</em>, and the character will be typed 1 or more times.</p>
<p>You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p>
<p>- 두 문자열이 match 되면 pass, 아니면 long pressed인지 확인하여 그만큼 string typed를 진행시키고, 아니면 return false.</p>
<p>- while 문이 종료되었을 때, i가 name.size()보다 작으면, string typed의 character의 숫자가 모자른 것이므로 false.</p>
<p>bool isLongPressedName(string name, string typed) {</p>
<p>int i=0,j=0;</p>
<p>char prev=name[0];</p>
<p>while(j&lt;typed.size()){</p>
<p>// if the two strings is matched.</p>
<p>if(name[i]==typed[j]){</p>
<p>prev=name[i];</p>
<p>i++;j++;</p>
<p>continue;</p>
<p>}</p>
<p>//if typed has been long pressed.</p>
<p>if(prev!=name[i] &amp;&amp; prev==typed[j]){</p>
<p>while(prev==typed[j]) j++;</p>
<p>continue;</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>//if the type has not enough character.</p>
<p>return i&gt;=name.size()? true : false;</p>
<p>}</p>
<p>[20. <strong>Path Sum III – 주어진 트리의 노드들을 더하여 주어진 sum을 만들 수 있는 path가 몇 개인지 구하는 문제]</strong></p>
<p>- 두개의 재귀를 생각해야해서 어려운 문제임. 덕분에 좋은 공부가 되었음.</p>
<p>- 전수조사 밖에 답이없는 것 같음.</p>
<p>int search(TreeNode* root, int sum, int pre){</p>
<p>if(!root) return 0;</p>
<p>return (root-&gt;val+pre == sum) + search(root-&gt;left,sum,pre+root-&gt;val) + search(root-&gt;right,sum,pre+root-&gt;val);</p>
<p>}</p>
<p>int pathSum(TreeNode* root, int sum) {</p>
<p>if(!root) return 0;</p>
<p>return search(root,sum,0) + pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum);</p>
<p>}</p>
<p>[21. <strong>Find Smallest Letter Greater Than Target – 주어진 target보다 큰 가장 작은 character를 반환하는 문제]</strong></p>
<p>- 그냥 간단하게 target의 ascii code값 보다 큰 값이 나오면 return 해주는 것으로 했음, 끝날때까지 찾지 못하면, 첫번째 원소. 이거는 O(n)임.</p>
<p>char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {</p>
<blockquote>
<p>if(letters[letters.size()-1]&lt;=target) return letters[0];</p>
<p>for(int i=0;i&lt;letters.size();i++){</p>
<p>if(target&lt;letters[i])</p>
<p>return letters[i];</p>
<p>}</p>
<p>return letters[0];</p>
</blockquote>
<p>}</p>
<p>-이것을 이진탐색으로도 풀 수 있음.</p>
<p>char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {</p>
<p>int left=0;</p>
<p>int right=letters.size()-1;</p>
<p>int mid;</p>
<p>while(left&lt;=right){</p>
<p>mid=(right-left)/2+left; // to handle INT overflow.</p>
<p>if(mid==0){</p>
<p>if(letters[mid]&gt;target) return letters[0];</p>
<p>else{</p>
<p>left=mid+1;</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<p>if(letters[mid-1]&lt;=target &amp;&amp; letters[mid]&gt;target) return letters[mid];</p>
<p>else if(letters[mid]&lt;=target)</p>
<p>left=mid+1;</p>
<p>else right=mid-1;</p>
<p>}</p>
<p>return letters[0];</p>
<p>}</p>
<p>- upper_bound를 사용한 풀이 방법도 있음. 이거 알아두자.</p>
<p>- upper_bound는 이진탐색 기반의 탐색 법임. 사용전 list가 정렬되어 있어야함.</p>
<p>- key값을 초과하는 가장 첫번째 원소의 반복자를 리턴함.</p>
<p>- upper_bound(vec.begin(),vec.end(),value)의 형식으로 사용함.</p>
<p>- lower_bound는 해당 value를 포함하여 이상인 값을 리턴함. 즉, lower는 이상, upper는 초과!</p>
<p>char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {</p>
<p>vector&lt;char&gt;::iterator iter=upper_bound(letters.begin(),letters.end(),target);</p>
<p>return iter==letters.end() ? letters[0] : *iter;</p>
<p>}</p>
<p>p.s) 세상 많이 편해졌다.</p>
<p>[22. <strong> Longest Harmonious Subsequence – max와 min의 차이가 정확히 1인 subsequence 찾는 문제]</strong></p>
<p>- 여기서 subsequence는 substring이 아니라, 조합될수 있는 모든 가지수임.</p>
<p>ex) apple의 subsequence는 a,ap,al,ae,app,apl,ape … 이런 식임.</p>
<p>- 이 문제는 map을 활용하여 2번의 for문을 쓰는게 관건이었음.</p>
<p>- 생각하기 쉽지 않아서 Discussion의 도움을 받음.</p>
<p>int findLHS(vector&lt;int&gt;&amp; nums) {</p>
<p>unordered_map&lt;int,int&gt; table;</p>
<p>for(int i : nums){</p>
<p>table[i]++;</p>
<p>}</p>
<p>int answer=0;</p>
<p>unordered_map&lt;int,int&gt;::iterator iter=table.begin();</p>
<p>for(;iter!=table.end();iter++){</p>
<p>if(table.count(iter-&gt;first-1)&gt;0)</p>
<p>answer=max(answer,iter-&gt;second+table[iter-&gt;first-1]);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[23. <strong>Longest Continuous Increasing Subsequence – 벡터 내 오름차순 부분배열 중 가장 긴 길이를 구하는 문제] 2020-01-26 7:30.</strong></p>
<p>- empty인 vector에 대해서 vec.empty()로 체크하는 것 보다 vec.size()==0 으로 체크하는 것이 훨씬 빠르다.</p>
<p>int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {</p>
<p>if(nums.size()==0) return 0;</p>
<p>int count=1;</p>
<p>int answer=1;</p>
<p>int i=0;</p>
<p>while(i&lt;nums.size()-1){</p>
<p>while(i+1&lt;nums.size() &amp;&amp; nums[i]&lt;nums[i+1]){</p>
<p>count++;</p>
<p>i++;</p>
<p>}</p>
<p>answer=max(answer,count);</p>
<p>count=1;</p>
<p>i++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[24. <strong>Symmetric Tree – 트리가 대칭 모양인지 구하는 문제]</strong></p>
<p>- 나는 left subtree와 right subtree를 preorder search를 통해서 vector에 각 value값을 저장하고, 마지막에 두개의 벡터가 같은 값을 가지는지 확인하였음.</p>
<p>- 이때 null node에 대해서는 INT_MIN을 대입함으로써, 모양을 기억함.</p>
<p>vector&lt;int&gt; left_tree;</p>
<p>vector&lt;int&gt; right_tree;</p>
<p>void leftSearch(TreeNode* root){</p>
<p>if(!root){</p>
<p>left_tree.push_back(INT_MIN);</p>
<p>return;</p>
<p>}</p>
<p>left_tree.push_back(root-&gt;val);</p>
<p>leftSearch(root-&gt;left);</p>
<p>leftSearch(root-&gt;right);</p>
<p>}</p>
<p>void rightSearch(TreeNode* root){</p>
<p>if(!root){</p>
<p>right_tree.push_back(INT_MIN);</p>
<p>return;</p>
<p>}</p>
<p>right_tree.push_back(root-&gt;val);</p>
<p>rightSearch(root-&gt;right);</p>
<p>rightSearch(root-&gt;left);</p>
<p>}</p>
<p>bool isSymmetric(TreeNode* root) {</p>
<p>if(!root) return true;</p>
<p>leftSearch(root-&gt;left);</p>
<p>rightSearch(root-&gt;right);</p>
<p>if(left_tree.size()!=right_tree.size())</p>
<p>return false;</p>
<p>for(int i=0;i&lt;left_tree.size();i++)</p>
<p>if(left_tree[i]!=right_tree[i])</p>
<p>return false;</p>
<p>return true;</p>
<p>}</p>
<p>- Discussion의 방법인데, 좀 더 빠르고 간단함.</p>
<p>bool isSymmetric(TreeNode *root) {</p>
<p>if (!root) return true;</p>
<p>return helper(root-&gt;left, root-&gt;right);</p>
<p>}</p>
<p>bool helper(TreeNode* p, TreeNode* q) {</p>
<p>if (!p &amp;&amp; !q) {</p>
<p>return true;</p>
<p>} else if (!p || !q) {</p>
<p>return false;</p>
<p>}</p>
<p>if (p-&gt;val != q-&gt;val) {</p>
<p>return false;</p>
<p>}</p>
<p>return helper(p-&gt;left,q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);</p>
<p>}</p>
<p>[25. <strong>Maximum Subarray – 최대부분배열문제] 2020-01-27 4:30 PM.</strong></p>
<p>- dp를 이용해서 푸는건데, dp 벡터에 현재 인덱스의 값과 바로 이전까지 구한 최대부분배열을 더하여 현재 인덱스 값보다 크면 그 값을 그 인덱스의 dp값으로 하는 방식임.</p>
<p>- O(n) solution인데, 떠올리기 쉽지 않음.<br />
int maxSubArray(vector&lt;int&gt;&amp; nums) {</p>
<p>int maximum=nums[0];</p>
<p>vector&lt;int&gt; dp;</p>
<p>dp.push_back(nums[0]);</p>
<p>for(int i=1;i&lt;nums.size();i++){</p>
<p>dp.push_back(max(nums[i],nums[i]+dp[i-1]));</p>
<p>maximum=max(maximum,dp[i]);</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>[26. <strong>Base 7 – 주어진 수를 7진수 string으로 표현하는 문제]</strong></p>
<p>- 이게 인풋이 그냥 7이면 곱하기 10을 해도 7%7=0 이므로 자릿수가 올라가지 않아서, 처음부터 string으로 다루는 것이 포인트임.</p>
<p>string convertToBase7(int num) {</p>
<p>if(num==0)</p>
<p>return &quot;0&quot;;</p>
<p>string base7;</p>
<p>int temp=num;</p>
<p>num=abs(num);</p>
<p>while(num){</p>
<p>base7+=to_string(num%7);</p>
<p>num/=7;</p>
<p>}</p>
<p>reverse(base7.begin(),base7.end());</p>
<p>return temp&lt;0? '-'+base7 : base7;</p>
<p>}</p>
<p>[27. <strong>Add Strings – 두개의 string으로 주어진 정수를 더하는 문제] 2020-01-27 5:45 PM</strong></p>
<p>- string 최대길이가 5100이므로 정수로 바꿔서 더할 수 없고, carry를 활용해야함.</p>
<p>- 더 짧게 짤 수 있을 것 같긴한데, 알고리즘은 대체로 나와 같을 것이라 예상됨.</p>
<p>string addStrings(string num1, string num2) {</p>
<p>int carry=0;</p>
<p>string answer;</p>
<p>int temp;</p>
<p>int i,j;</p>
<p>for(i=num1.size()-1,j=num2.size()-1;i&gt;=0 &amp;&amp; j&gt;=0 ; i--,j--){</p>
<p>temp=(num1[i]-48)+(num2[j]-48)+carry;</p>
<p>answer+=to_string(temp%10);</p>
<p>if(temp&gt;=10) carry=1;</p>
<p>else carry=0;</p>
<p>}</p>
<p>while(i&gt;=0){</p>
<p>temp=(num1[i]-48+carry);</p>
<p>answer+=to_string(temp%10);</p>
<p>i--;</p>
<p>if(temp&gt;=10) carry=1;</p>
<p>else carry=0;</p>
<p>}</p>
<p>while(j&gt;=0){</p>
<p>temp=(num2[j]-48+carry);</p>
<p>answer+=to_string(temp%10);</p>
<p>j--;</p>
<p>if(temp&gt;=10) carry=1;</p>
<p>else carry=0;</p>
<p>}</p>
<p>if(carry)</p>
<p>answer+=to_string(carry);</p>
<p>return {answer.rbegin(),answer.rend()};</p>
<p>}</p>
<p>[28. <strong>Climbing Stairs – 계단을 한번에 1개나 2개씩 오를 수 있을 때, 특정 높이의 계단까지 가는 방법의 수를 구하는 문제] 2020-01-27 6:20</strong></p>
<p><strong>-</strong> 간만에 DP를 풀어서 그런지, 피보나치임을 눈으로 보고도 알아채지 못 했음.</p>
<p>int climbStairs(int n) {</p>
<p>if(n&lt;=2) return n;</p>
<p>int temp;</p>
<p>int prev=1;</p>
<p>int cur=2;</p>
<p>for(int i=3; i&lt;=n;i++){</p>
<p>temp=cur;</p>
<p>cur=prev+cur;</p>
<p>prev=temp;</p>
<p>}</p>
<p>return cur;</p>
<p>}</p>
<p>[29. <strong>Binary Watch – 손목시계에 들어온 LED의 개수로 표현할 수 있는 모든 시간을 구하는 문제] 2020-01-27 7:00</strong></p>
<p>- 이건 내가 못푸는 문제임. Discussion 보고도 한참 걸렸음.</p>
<p>- bitset을 이용하는 문제임. 어렵다.</p>
<p>- bitset&lt;10&gt; a으로 선언할 수 있는데, a에 자리수가 10개인 비트를 저장할 수 있다는 것이다.</p>
<p>이때 bitset&lt;10&gt;(3) a 로 선언하면, 10개의 비트에 대해서 십진수 3을 이진수로 표현하여 a에 저장해준다. 즉 0000 00011 이 된다.</p>
<p>- a.set() 을 하면 모든 bit이 1이되고, a.reset() 하면 0이 된다. a.set(3,true)로 하면 3+1인 4번 비트를 1로 설정한다.</p>
<p>- a.flip()을 하면 모든 비트를 반전하고, a.flip(3)을 하면 3+1인 4번 비트를 반전한다.</p>
<p>- a.to_string() 하면 전체 비트를 string화 시킨다.</p>
<p>- a[4], a.test[4] 처럼 배열처럼 접근할 수 있다.</p>
<p>- a.any()는 비트 중 하나라도 1이면 1을 반환하고, a.none()은 모두 0이어야만 1을 반환한다.</p>
<p>- a.test(n)은 n+1번째 비트가 1인지 0인지 검사한다.</p>
<p>vector&lt;string&gt; readBinaryWatch(int num) {</p>
<p>vector&lt;string&gt; answer;</p>
<p>for(int h=0;h&lt;12;h++){</p>
<p>for(int m=0;m&lt;60;m++){</p>
<p>if(bitset&lt;10&gt;(h).count()+bitset&lt;10&gt;(m).count()==num)</p>
<p>answer.push_back(to_string(h)+&quot;:&quot;+(m&lt;10? &quot;0&quot;:&quot;&quot;)+to_string(m));</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>-이런걸 생각해 내는 사람들도 대단함.</p>
<p>[30. <strong>Student Attendance Record I – 학생이 상을 받을 수 있는 출석률을 가졌는지 아닌지 판단하는 문제]</strong></p>
<p>- 간단한 문제임. if문을 여러 개 사용하면 됨.</p>
<p>- 결석이 2회이상이면 탈락이고, 3연속 지각을 하면 탈락임.</p>
<p>bool checkRecord(string s) {</p>
<p>bool absent=false;</p>
<p>int late=0;</p>
<p>for(int i=0;i&lt;s.size();i++){</p>
<p>if(absent &amp;&amp; s[i]=='A')</p>
<p>return false;</p>
<p>else if(s[i]=='A'){</p>
<p>absent=true;</p>
<p>late=0;</p>
<p>continue;</p>
<p>}</p>
<p>else if(late==2&amp;&amp;s[i]=='L')</p>
<p>return false;</p>
<p>else if(s[i]=='L'){</p>
<p>late++;</p>
<p>continue;</p>
<p>}</p>
<p>late=0;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>[31. <strong>Number of 1 Bits – uint_8 로 주어진 bit에 1이 몇 개인지 세는 문제]</strong></p>
<p><strong>-</strong> bit연산을 통해서 풀었음. 주어진 n과 1을 &amp;연산을 하여 true면 count++를 함. 그 이후 n=n&gt;&gt;1을 하여 n==0일 때까지 loop를 돌림.</p>
<p>int hammingWeight(uint32_t n) {</p>
<p>int count=0;</p>
<p>while(n){</p>
<p>n&amp;1? count++:count;</p>
<p>n=n&gt;&gt;1;</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>[32. <strong>Pascal's Triangle II – 파스칼 트라이앵글의 특정 row의 원소를 구하는 문제]</strong></p>
<p><img src="data:image/png;base64,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" style="width:2.85417in;height:2.6875in" /></p>
<p>- 벡터 메모리 해제를 위해 vector&lt;int&gt;().swap(answer)를 이용하였다.</p>
<p>vector&lt;int&gt; getRow(int rowIndex) {</p>
<p>if(rowIndex==0) return {1};</p>
<p>vector&lt;int&gt; prev(2,1);</p>
<p>vector&lt;int&gt; answer;</p>
<p>vector&lt;int&gt; res=prev;</p>
<p>for(int i=0;i&lt;rowIndex-1;i++){</p>
<p>answer.push_back(1);</p>
<p>for(int j=0;j&lt;prev.size()-1;j++){</p>
<p>answer.push_back(prev[j]+prev[j+1]);</p>
<p>}</p>
<p>answer.push_back(1);</p>
<p>prev=answer;</p>
<p>res=answer;</p>
<p>answer.clear();</p>
<p>}</p>
<p>vector&lt;int&gt;().swap(prev); // deallocate prev</p>
<p>vector&lt;int&gt;().swap(answer);</p>
<p>return res;</p>
<p>}</p>
<p>- 다음 문장에 의거하여 더 빠르게 풀 수 있다.</p>
<p><em>Based on math, the kth element for nth row is C(n, k) = n! / (k!*(n-k)!), then res[k] = res[n - k]</em></p>
<p><em>so the relationship between res[i] and res[i-1] is n! / (k!(n-k)!) / n! <strong>/</strong> ((k-1)!(n-k + 1)!) = (n - k + 1) / k;</em></p>
<p><em>Note that this solution is math derived from number of Combinations.</em></p>
<p><em>Each line of Pascal's Triangle is a full set of Combination number based on k .</em></p>
<p><em>comb(k,p) = k! /( p! *(k-p)!) = comb(k,k-p)</em></p>
<p><em>if p &lt; k-p</em></p>
<p><em>comb(k,p) = comb(k,p-1) * (k-p+1) / p</em></p>
<p><em>Because :</em></p>
<p><em>comb(k,p) = [ k * (k-1) * (k-2) *... (k-p+1)] / [1 * 2 * 3 *...(p)]</em></p>
<p>vector&lt;int&gt; getRow(int rowIndex) {</p>
<p>vector&lt;int&gt; answer(rowIndex+1,1);</p>
<p>for(int i=1;i&lt;=(rowIndex+1)/2;i++){</p>
<p>answer[i]=answer[rowIndex-i]=(long)answer[i-1]*(long)(rowIndex-i+1)/i;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[33. <strong>Implement Queue using Stacks – 스택을 이용해 큐를 구현하는 문제] 2020-01-28 5:00</strong></p>
<p>- 스택을 2개 사용하여, push는 스택1에 push하고, pop이나 peek이 호출된 순간, 스택2가 비어있으면 스택1의 모든 원소를 pop하여 스택 2에 넣고, 스택 2의 top을 리턴한다. 스택2가 비어있지 않을 경우 그냥 스택 2의 탑을 리턴한다.</p>
<p>- 이때 pop 호출시 해당 top을 삭제하여 준다.</p>
<p>stack&lt;int&gt; stk1;</p>
<p>stack&lt;int&gt; stk2;</p>
<p>/** Push element x to the back of queue. */</p>
<p>void push(int x) {</p>
<p>stk1.push(x);</p>
<p>}</p>
<p>/** Removes the element from in front of queue and returns that element. */</p>
<p>int pop() {</p>
<p>if(!stk2.empty()){</p>
<p>int temp=stk2.top();</p>
<p>stk2.pop();</p>
<p>return temp;</p>
<p>}</p>
<p>while(!stk1.empty()){</p>
<p>stk2.push(stk1.top());</p>
<p>stk1.pop();</p>
<p>}</p>
<p>int temp=stk2.top();</p>
<p>stk2.pop();</p>
<p>return temp;</p>
<p>}</p>
<p>/** Get the front element. */</p>
<p>int peek() {</p>
<p>if(!stk2.empty())</p>
<p>return stk2.top();</p>
<p>while(!stk1.empty()){</p>
<p>stk2.push(stk1.top());</p>
<p>stk1.pop();</p>
<p>}</p>
<p>return stk2.top();</p>
<p>}</p>
<p>/** Returns whether the queue is empty. */</p>
<p>bool empty() {</p>
<p>if(stk1.empty() &amp;&amp; stk2.empty())</p>
<p>return true;</p>
<p>return false;</p>
<p>}</p>
<p>[34. <strong>Number of Equivalent Domino Pairs - 2차원 벡터에서 순서에 상관없이 동일한 원소를 가진 행벡터를 구하는 문제] 2020-01-28 5:20</strong></p>
<p>- 나는 일단 잘 안떠올라서 sort시키고 시작했음. sort 후 map의 키로서 pair&lt;int,int&gt;를 활용함.</p>
<p>- map의 키로서 pair를 사용할 경우 unordered_map은 사용 불가능함. 그래서 더 느린듯.</p>
<p>int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {</p>
<p>for(int i=0;i&lt;dominoes.size();i++)</p>
<p>sort(dominoes[i].begin(),dominoes[i].end());</p>
<p>map&lt;pair&lt;int,int&gt;,int&gt; table;</p>
<p>for(int i=0;i&lt;dominoes.size();i++){</p>
<p>table[make_pair(dominoes[i][0],dominoes[i][1])]++;</p>
<p>}</p>
<p>map&lt;pair&lt;int,int&gt;,int&gt;::iterator iter=table.begin();</p>
<p>int answer=0;</p>
<p>for(;iter!=table.end();iter++)</p>
<p>answer+=(iter-&gt;second)*(iter-&gt;second -1)/2;</p>
<p>return answer;</p>
<p>}</p>
<p>- 다른 방법을 찾아봤는데, Discussion 에서 이런 신박한 방법이 있었음.</p>
<p><strong>Explanation</strong></p>
<p>You need to distinguish the different dominoes and count the same.</p>
<p>I did it in this way:<br />
f(domino) = min(d[0], d[1]) * 10 + max(d[0], d[1])<br />
For each domino d, calculate min(d[0], d[1]) * 10 + max(d[0], d[1])<br />
This will put the smaller number on the left and bigger one on the right (in decimal).<br />
So same number same domino, different number different domino.</p>
<p>Take the example from the problem:<br />
dominoes = [[1,2],[2,1],[3,4],[5,6]]<br />
now we transform it into [12,12,34,56].</p>
<p>int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {</p>
<p>unordered_map&lt;int, int&gt; count;</p>
<p>int res = 0;</p>
<p>for (auto&amp; d : dominoes) {</p>
<p>res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>- 천재 xx들…</p>
<p>[35. <strong>Maximum Product of Three Numbers – 벡터의 원소 중 3개를 골라 곱하였을 때의 최댓값을 구하는 문제] 2020-01-28 5:48</strong></p>
<p>- 최댓값은 벡터에 음수가 존재할 경우, 가장 작은 음수 2개와 가장 큰 양수 하나를 곱하거나, 가장 큰 양수 3개를 차례로 곱하는 2가지 방법만이 존재한다.</p>
<p>- 그러므로 가장 큰 양수 3개와, 가장 작은 음수 2개를 찾은 후 두개를 비교하면 된다.</p>
<p>int maximumProduct(vector&lt;int&gt;&amp; nums) {</p>
<p>int max1=INT_MIN+2,max2=INT_MIN+1, max3=INT_MIN;</p>
<p>int min1=INT_MAX-1,min2=INT_MAX;</p>
<p>for(int i=0;i&lt;nums.size();i++){</p>
<p>if(nums[i]&gt;max1){</p>
<p>max3=max2;</p>
<p>max2=max1;</p>
<p>max1=nums[i];</p>
<p>}</p>
<p>else if(nums[i]&gt;max2){</p>
<p>max3=max2;</p>
<p>max2=nums[i];</p>
<p>}</p>
<p>else if(nums[i]&gt;max3) max3=nums[i];</p>
<p>if(nums[i]&lt;min1){</p>
<p>min2=min1;</p>
<p>min1=nums[i];</p>
<p>}</p>
<p>else if(nums[i]&lt;min2) min2=nums[i];</p>
<p>}</p>
<p>return max(max1*max2*max3,min1*min2*max1);</p>
<p>}</p>
<p>[36. <strong>Pairs of Songs With Total Durations Divisible by 60 – 주어진 벡터에서 두 원소의 합이 60으로 나누어 떨어지는 원소 쌍의 개수를 구하는 문제] 2020-01-28 6:14</strong></p>
<p>- 일단 map을 이용하여, 60-원소값 즉, 해당 원소가 60으로 나누어떨어지기 위해서 더해져야 하는 값을 확인하고, 해당 값이 존재하면 answer에 더해준다.</p>
<p>- 이때 i&lt;j인 쌍에서만 확인한다. 즉 중복된 두개의 원소쌍에 대해서는 한번만 연산한다는 것이 중요하다.</p>
<p>- table에는 key값으로 60을 가질 수 없기 때문에, time[i]==60일 경우 %60을 한번 더해줌으로써 table[0]을 검색하게 해준다.</p>
<p>int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) {</p>
<p>unordered_map&lt;int,int&gt; table;</p>
<p>int answer=0;</p>
<p>for(int i=0;i&lt;time.size();i++){</p>
<p>answer+=table[(60-(time[i]%60))%60]; // to handle when a time[i]==60, since there will be no value 60 in the table.</p>
<p>table[time[i]%60]++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[37. <strong>Sum of Nodes with Even-Valued Grandparent – 현재 노드의 grandparent가 짝수인 모든 노드의 합을 구하는 문제] 2020-01-29 6:37</strong></p>
<p><strong>-</strong> helper함수 하나와 재귀를 사용하여 풀었다.</p>
<p>int sum=0;</p>
<p>int search(TreeNode* root){</p>
<p>int temp=0;</p>
<p>if(!root) return 0;</p>
<p>if(root-&gt;left)</p>
<p>temp+=root-&gt;left-&gt;val;</p>
<p>if(root-&gt;right)</p>
<p>temp+=root-&gt;right-&gt;val;</p>
<p>return temp;</p>
<p>}</p>
<p>int sumEvenGrandparent(TreeNode* root) {</p>
<p>if(!root) return 0;</p>
<p>if(root-&gt;val%2==0){</p>
<p>sum+=search(root-&gt;left)+search(root-&gt;right);</p>
<p>}</p>
<p>sumEvenGrandparent(root-&gt;left);</p>
<p>sumEvenGrandparent(root-&gt;right);</p>
<p>return sum;</p>
<p>}</p>
<p>[38. <strong>Deepest Leaves Sum – 가장 깊은 노드들의 value의 합을 구하는 문제] 2020-01-29 6:47</strong></p>
<p>- 첫번째로 max_depth를 구하기 위해 트리를 한번 돌고, 두번째로 max_depth인 노드들의 합을 구하기 위해 한번 돌고, 트리를 총 2번 도는 알고리즘임.</p>
<p>int max_depth=INT_MIN;</p>
<p>void findMaxDepth(TreeNode* root,int depth){</p>
<p>if(!root) return;</p>
<p>max_depth=max(max_depth,depth);</p>
<p>findMaxDepth(root-&gt;left,depth+1);</p>
<p>findMaxDepth(root-&gt;right,depth+1);</p>
<p>}</p>
<p>int sumOfDeepest(TreeNode* root,int depth){</p>
<p>if(!root) return 0;</p>
<p>if(depth==max_depth)</p>
<p>return root-&gt;val;</p>
<p>return sumOfDeepest(root-&gt;left,depth+1)+sumOfDeepest(root-&gt;right,depth+1);</p>
<p>}</p>
<p>int deepestLeavesSum(TreeNode* root) {</p>
<p>findMaxDepth(root,0);</p>
<p>return sumOfDeepest(root,0);</p>
<p>}</p>
<p>[39. <strong> Group the People Given the Group Size They Belong To – 주어진 groupsize의 각 인덱스의 위치한 숫자가, 해당 인덱스가 포함될 그룹의 사이즈임]</strong></p>
<p><strong>-</strong> 문제를 이해하는 것 자체가 힘듬. 일단 0번째 인덱스의 원소가 3이면, 0번 ID를 가진 사람의 그룹 사이즈가 3이어서, 사이즈가 3인 그룹에 해당 ID를 할당해야하는 것임.</p>
<p>- map에 벡터를 value로 사용하는 방법을 배웠음. 해당 key가 empty일때는 table[key]=vector&lt;int&gt;{value} 로 맨처음에 값을 넣어주고, 만약에 값이 존재하면 즉, table[key].count()&gt;0 이 true이면 그냥 바로 table[key].push_back(value); 해주면 됨.<br />
vector&lt;vector&lt;int&gt;&gt; groupThePeople(vector&lt;int&gt;&amp; groupSizes) {</p>
<p>unordered_map&lt;int,vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>for(int i=0;i&lt;groupSizes.size();i++){</p>
<p>int key=groupSizes[i];</p>
<p>if(table.count(key)&gt;0)</p>
<p>table[key].push_back(i);</p>
<p>else table[key]=vector&lt;int&gt;{i};</p>
<p>if(table.find(key)-&gt;second.size()&gt;=key){</p>
<p>answer.push_back(table[key]);</p>
<p>table.erase(key);</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[40. <strong>Max Increase to Keep City Skyline – 각 row, col에 대하여 해당 원소가 증가할 수 있는 최대치의 합을 구하는 문제]</strong></p>
<p>- 각 row와 column의 최대 값을 구한 벡터를 2개를 가진 후, 각 원소가 증가할 수 있는 최대치를 구하여 더해줌.</p>
<p>int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</p>
<p>vector&lt;int&gt; row_height;</p>
<p>vector&lt;int&gt; col_height;</p>
<p>int temp_max=INT_MIN;</p>
<p>for(int i=0;i&lt;grid.size();i++){</p>
<p>for(int j=0;j&lt;grid[i].size();j++)</p>
<p>temp_max=max(temp_max,grid[i][j]);</p>
<p>row_height.push_back(temp_max);</p>
<p>temp_max=INT_MIN;</p>
<p>}</p>
<p>for(int i=0;i&lt;grid[0].size();i++){</p>
<p>for(int j=0;j&lt;grid.size();j++)</p>
<p>temp_max=max(temp_max,grid[j][i]);</p>
<p>col_height.push_back(temp_max);</p>
<p>temp_max=INT_MIN;</p>
<p>}</p>
<p>int sum=0;</p>
<p>for(int i=0;i&lt;grid.size();i++){</p>
<p>for(int j=0;j&lt;grid[i].size();j++){</p>
<p>sum+=min(row_height[i],col_height[j])-grid[i][j];</p>
<p>}</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>[41. <strong>Binary Search Tree to Greater Sum Tree – 이진탐색트리에서 자신보다 큰 노드의 값을 모두 합친 값이 자신의 값이 되도록 수정하는 문제]</strong></p>
<p>- 전역 변수를 사용하는게 포인트임. 사용안하고 풀어보려다가 시간 개오래 걸림.</p>
<p>int current_sum=0;</p>
<p>void modify(TreeNode* root){</p>
<p>if(!root) return;</p>
<p>modify(root-&gt;right);</p>
<p>root-&gt;val+=current_sum;</p>
<p>current_sum=root-&gt;val;</p>
<p>modify(root-&gt;left);</p>
<p>return;</p>
<p>}</p>
<p>TreeNode* bstToGst(TreeNode* root) {</p>
<p>modify(root);</p>
<p>return root;</p>
<p>}</p>
<p>[42. <strong>Encode and Decode TinyURL – 내 마음대로 URL을 encode한 후 decode하는 문제]</strong></p>
<p><strong>-</strong> 그냥 간단하게 각 문자에 3을 더한 ascii 코드값을 string에 저장하고, decode할 때 3을 빼줌.</p>
<p>string enc;</p>
<p>string dec;</p>
<p>// Encodes a URL to a shortened URL.</p>
<p>string encode(string longUrl) {</p>
<p>enc.clear();</p>
<p>for(int i=0;i&lt;longUrl.size();i++)</p>
<p>enc+=longUrl[i]+3;</p>
<p>enc+='\0';</p>
<p>return enc;</p>
<p>}</p>
<p>// Decodes a shortened URL to its original URL.</p>
<p>string decode(string shortUrl) {</p>
<p>dec.clear();</p>
<p>for(int i=0;shortUrl[i]!='\0';i++)</p>
<p>dec+=shortUrl[i]-3;</p>
<p>return dec;</p>
<p>}</p>
<p>[43. <strong> Insert into a Binary Search Tree – BST에 삽입하는 문제]</strong></p>
<p>- 자신 보다 큰 노드를 발견할때까지 오른쪽으로 가고, 자신 보다 큰 노드를 만났을 때, 왼쪽 자식이 비어있으면 거기에 넣고, 아니면 왼쪽으로 한칸가서 다시 자신보다 큰 노드를 발견할 때 까지 반복.</p>
<p>void search(TreeNode* root, int val){</p>
<p>if(root-&gt;val&lt;val){</p>
<p>if(!root-&gt;right){</p>
<p>root-&gt;right=new TreeNode(val);</p>
<p>return;</p>
<p>}</p>
<p>search(root-&gt;right,val);</p>
<p>}</p>
<p>else if(!root-&gt;left){</p>
<p>root-&gt;left= new TreeNode(val);</p>
<p>return;</p>
<p>}</p>
<p>else search(root-&gt;left,val);</p>
<p>}</p>
<p>TreeNode* insertIntoBST(TreeNode* root, int val) {</p>
<p>search(root,val);</p>
<p>return root;</p>
<p>}</p>
<p>- 근데 이문제 iterative로 풀면 O(1) space만 쓰면 된다. recursive로 풀면 stack에 함수가 쌓여서 O(n) space가 필요하다.</p>
<p>[44. <strong>Maximum Binary Tree – 주어진 벡터에 대해서 맥스 값을 root로 왼쪽 오른쪽을 나누고, 같은 방식으로 트리를 만드는 문제] 2020-01-30 4:20</strong></p>
<p><strong>-</strong> 처음에는 iterator로 풀려고 했는데, 자꾸 bad_allocation 이라는 runtime error가 발생해서, 그냥 인덱스 가지고 for문 돌리는 것으로 바꿈</p>
<p>- 내생각에 이거는 O(n^2)에 푸는 건데, Discussion을 확인해 봐야겠음.</p>
<p>TreeNode* constructTree(vector&lt;int&gt;&amp; nums){</p>
<p>int maximum=INT_MIN;</p>
<p>int max_index=0;</p>
<p>for(int i=0;i&lt;nums.size();i++)</p>
<p>if(maximum&lt;nums[i]){</p>
<p>maximum=nums[i];</p>
<p>max_index=i;</p>
<p>}</p>
<p>vector&lt;int&gt; left;</p>
<p>vector&lt;int&gt; right;</p>
<p>for(int i=0;i&lt;max_index;i++)</p>
<p>left.push_back(nums[i]);</p>
<p>for(int i=max_index+1;i&lt;nums.size();i++){</p>
<p>right.push_back(nums[i]);</p>
<p>}</p>
<p>TreeNode* root=new TreeNode(maximum);</p>
<p>if(max_index!=0) root-&gt;left=constructTree(left);</p>
<p>if(max_index!=nums.size()-1) root-&gt;right=constructTree(right);</p>
<p>return root;</p>
<p>}</p>
<p>TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {</p>
<p>return constructTree(nums);</p>
<p>}</p>
<p>- 다음 방법은 stack을 이용한 건데, 이해는 했는데, 이게 O(n)인지는 좀 확실치 않음, 스택에 다 넣었다가 빼는 과정도 있어서.. 그래도 O(2n)정도인듯.</p>
<p>TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {</p>
<p>vector&lt;TreeNode*&gt; stk;</p>
<p>for (int i = 0; i &lt; nums.size(); ++i)</p>
<p>{</p>
<p>TreeNode* cur = new TreeNode(nums[i]);</p>
<p>while (!stk.empty() &amp;&amp; stk.back()-&gt;val &lt; nums[i])</p>
<p>{</p>
<p>cur-&gt;left = stk.back();</p>
<p>stk.pop_back();</p>
<p>}</p>
<p>if (!stk.empty())</p>
<p>stk.back()-&gt;right = cur;</p>
<p>stk.push_back(cur);</p>
<p>}</p>
<p>return stk.front();</p>
<p>}</p>
<p>[45. <strong>Sort the Matrix Diagonally – 주어진 2차원 벡터에 대해서 모든 대각선을 오름차순으로 sort하는 문제] 2020-01-30 4:40</strong></p>
<p><strong>-</strong> 쉽게 생각해서 O(n^2)에 풀었는데, 각 원소의 오른쪽 아래원소가 자신보다 작으면 두개를 스왑하는 방식으로, 그것을 주어진 2차원 벡터의 row수만큼 반복함.</p>
<p>vector&lt;vector&lt;int&gt;&gt; diagonalSort(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {</p>
<p>for(int k=0;k&lt;mat.size();k++)</p>
<p>for(int i=0;i&lt;mat.size()-1;i++)</p>
<p>for(int j=0;j&lt;mat[i].size()-1;j++)</p>
<p>if(mat[i][j]&gt;mat[i+1][j+1])</p>
<p>swap(mat[i][j],mat[i+1][j+1]);</p>
<p>return mat;</p>
<p>}</p>
<p>[46. <strong>All Elements in Two Binary Search Trees – 주어진 두개의 BST의 원소들을 오름차순으로 벡터에 집어넣는 문제] 2020-01-30 5:03</strong></p>
<p>- BST이므로 중위순회를 하면 sort가 됨. 이것을 각각 벡터로 하나씩 가지고 있고, 두개의 벡터의 원소들을 비교해가면서 answer 벡터에 넣어줌.</p>
<p>-마지막에 빈 벡터와 위의 sort 벡터 2개를 swap함으로써 메모리 해제를 해줌.</p>
<p>- 이때 벡터 2개를 사용안하고 벡터 1개에 집어넣고 sort하는 방식도 있긴함. 근데 이러면 O(nlogn)이 걸림. 내 방법은 해봐야 O(4n)임.</p>
<p>void inOrder(TreeNode* root,vector&lt;int&gt;&amp; bst){</p>
<p>if(!root) return;</p>
<p>inOrder(root-&gt;left,bst);</p>
<p>bst.push_back(root-&gt;val);</p>
<p>inOrder(root-&gt;right,bst);</p>
<p>}</p>
<p>vector&lt;int&gt; getAllElements(TreeNode* root1, TreeNode* root2) {</p>
<p>vector&lt;int&gt; bst1;</p>
<p>vector&lt;int&gt; bst2;</p>
<p>vector&lt;int&gt; answer;</p>
<p>inOrder(root1,bst1);</p>
<p>inOrder(root2,bst2);</p>
<p>vector&lt;int&gt;::iterator left=bst1.begin();</p>
<p>vector&lt;int&gt;::iterator right=bst2.begin();</p>
<p>while(left!=bst1.end()|right!=bst2.end()){</p>
<p>if(left==bst1.end()){</p>
<p>while(right!=bst2.end()){</p>
<p>answer.push_back(*right);</p>
<p>right++;</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>if(right==bst2.end()){</p>
<p>while(left!=bst1.end()){</p>
<p>answer.push_back(*left);</p>
<p>left++;</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>if(*left&gt;*right){</p>
<p>answer.push_back(*right);</p>
<p>right++;</p>
<p>}</p>
<p>else{</p>
<p>answer.push_back(*left);</p>
<p>left++;</p>
<p>}</p>
<p>}</p>
<p>vector&lt;int&gt;().swap(bst1);</p>
<p>vector&lt;int&gt;().swap(bst2);</p>
<p>return answer;</p>
<p>}</p>
<p>[47. <strong>Construct Binary Search Tree from Preorder Traversal – preorder로 주어진 벡터로 트리를 만드는 문제] 2020-01-30 5:34</strong></p>
<p><strong>-</strong> 아 이거 학교에서 했던건데 알고리즘이 떠오르지 않아서 되게 과격한 방식으로 풀었음. Discussion을 좀 확인해봐야겠음.</p>
<p>- 일단 나의 알고리즘은, 벡터의 첫번째 원소가 항상 root이고 이제 벡터를 왼쪽 서브트리와 오른쪽 서브트리로 나눠야 하는데, 첫번째 원소보다 큰 값을 가진 첫번째 원소가 오른쪽 서브트리의 루트고, 왼쪽 서브트리의 루트는 두번째 원소임.</p>
<p>- 위와 같은 방식으로 벡터 2개를 구해서 각각 재귀해줌. 그런데 이거 iterator로 풀수 있을 것 같은 데 왜 안풀리냐 ㅡㅡ, 그래서 그냥 index로 품. 속도 보장 못함.</p>
<p>TreeNode* helper(vector&lt;int&gt; preorder){</p>
<p>if(preorder.size()==0) return nullptr;</p>
<p>TreeNode* root=new TreeNode(preorder[0]);</p>
<p>int next_index=preorder.size();</p>
<p>for(int i=1;i&lt;preorder.size();i++)</p>
<p>if(preorder[i]&gt;preorder[0]){</p>
<p>next_index=i;</p>
<p>break;</p>
<p>}</p>
<p>vector&lt;int&gt; left;</p>
<p>vector&lt;int&gt; right;</p>
<p>for(int i=1;i&lt;next_index;i++)</p>
<p>left.push_back(preorder[i]);</p>
<p>for(int i=next_index;i&lt;preorder.size();i++)</p>
<p>right.push_back(preorder[i]);</p>
<p>if(right.size()!=0)</p>
<p>root-&gt;right=helper(right);</p>
<p>if(left.size()!=0)</p>
<p>root-&gt;left=helper(left);</p>
<p>return root;</p>
<p>}</p>
<p>TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) {</p>
<p>return helper(preorder);</p>
<p>}</p>
<p>- 이런식으로 하면 iterator 쓸수 있을 듯.</p>
<p>TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) {</p>
<p>return helper(preorder.begin(), preorder.end());</p>
<p>}</p>
<p>TreeNode * helper(vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end) {</p>
<p>if (begin == end) {</p>
<p>return nullptr;</p>
<p>}</p>
<p>auto node = new TreeNode(*begin);</p>
<p>auto right = upper_bound(begin + 1, end, *begin);</p>
<p>node-&gt;left = helper(begin + 1, right);</p>
<p>node-&gt;right = helper(right, end);</p>
<p>return node;</p>
<p>}</p>
<p>[48. <strong>Letter Tile Possibilities – 주어진 string으로 만들 수 있는 모든 sequence의 개수를 출력하는 문제]</strong></p>
<p><strong>-</strong> 이 문제 어렵다 ㄷㄷ.</p>
<p>- Discussion 보고 배껴서 풀긴 했는데, 아직도 이해가 잘 안감.</p>
<p>unordered_set&lt;string&gt; answer;</p>
<p>unordered_map&lt;char,int&gt; table;</p>
<p>void helper(string current,int length){</p>
<p>if(current!=&quot;&quot;)</p>
<p>answer.insert(current);</p>
<p>if(current.size()&gt;=length)</p>
<p>return;</p>
<p>for(unordered_map&lt;char,int&gt;::iterator iter=table.begin();iter!=table.end();iter++){</p>
<p>if(iter-&gt;second&gt;0){</p>
<p>iter-&gt;second--;</p>
<p>current+=iter-&gt;first;</p>
<p>helper(current,length);</p>
<p>current.pop_back();</p>
<p>iter-&gt;second++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int numTilePossibilities(string tiles) {</p>
<p>for(int i=0;i&lt;tiles.size();i++)</p>
<p>table[tiles[i]]++;</p>
<p>helper(&quot;&quot;,tiles.size());</p>
<p>return answer.size();</p>
<p>}</p>
<p>[49. <strong>Delete Leaves With a Given Value – 주어진 target value와 동일한 값을 가지고 있는 leaf node를 삭제하는 문제] 2020-01-31 8:50</strong></p>
<p>- 리프노드를 삭제했을 때, 그 부모가 리프노드가 되고 또 리프노드가 된 그 노드가 target value를 가지고 있으면 또 지워줘야함.</p>
<p>- 또한 트리 전체의 root 까지 지워야 하는 경우를 대비하여, root를 가리키는 임의의 노드를 생성하여, 그것을 가상의 루트로 함. 여기서는 answer node임.</p>
<p>bool end=false;</p>
<p>void remove(TreeNode* root, int target){</p>
<p>if(!root) return;</p>
<p>if(root-&gt;left){</p>
<p>if(root-&gt;left-&gt;val==target &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right){</p>
<p>root-&gt;left=nullptr;</p>
<p>end=false;</p>
<p>}</p>
<p>}</p>
<p>if(root-&gt;right){</p>
<p>if(root-&gt;right-&gt;val==target &amp;&amp; !root-&gt;right-&gt;left &amp;&amp; !root-&gt;right-&gt;right){</p>
<p>root-&gt;right=nullptr;</p>
<p>end=false;</p>
<p>}</p>
<p>}</p>
<p>remove(root-&gt;left,target);</p>
<p>remove(root-&gt;right,target);</p>
<p>}</p>
<p>TreeNode* removeLeafNodes(TreeNode* root, int target) {</p>
<p>TreeNode* answer=new TreeNode(target-1);</p>
<p>answer-&gt;left=root;</p>
<p>while(!end){</p>
<p>end=true;</p>
<p>remove(answer,target);</p>
<p>}</p>
<p>return answer-&gt;left;</p>
<p>}</p>
<p>[50. <strong>Partition Labels – 주어진 string을 분할하는 문제인데, 각 문자는 하나의 partition에만 속할 수 있음. 이렇게 나눌 수 있는 최대의 파티션을 구하고, 각 파티션의 길이를 리턴하는 문제] 2020-01-31 9:20</strong></p>
<p>- 나는 brute force로 푼거 같음. 현재 고려하는 문자를 cur라고 하고 그 위치를 left로 함. 그 후 가장 오른쪽에 위치한 cur를 찾고 그위치를 right로 하고, left와 right 사이의 문자 중 right 보다 더 오른쪽에 존재하는 문자를 찾아봄. 있으면 그 문자가 right가 됨. 그후 right-left+1이 해당 partition의 길이임.</p>
<p>-위 과정을 주어진 string이 끝날때까지 하면됨.</p>
<p>- O(n^2) solution 인듯.</p>
<p>int rightEnd(string&amp; S,char cur,int left){</p>
<p>int right=0;</p>
<p>for(int i=left;i&lt;S.size();i++)</p>
<p>if(S[i]==cur) right=i;</p>
<p>return right;</p>
<p>}</p>
<p>vector&lt;int&gt; partitionLabels(string S) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>char cur=S[0];</p>
<p>int left=0,right=0;</p>
<p>int i=0;</p>
<p>while(i&lt;S.size()){</p>
<p>cur=S[i];</p>
<p>left=i;</p>
<p>right=rightEnd(S,cur,left);</p>
<p>for(int j=left+1;j&lt;right;j++){</p>
<p>int temp_right=rightEnd(S,S[j],j);</p>
<p>if(right&lt;temp_right){</p>
<p>right=temp_right;</p>
<p>}</p>
<p>}</p>
<p>answer.push_back(right-left+1);</p>
<p>i=right+1;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>-생각해보니 다르게 풀 수 있을 것 같음. map 써가지고 O(n)시간안에 푸는건데, O(n)이긴 한데 좀 오래걸리는 O(n)임.</p>
<p>vector&lt;int&gt; partitionLabels(string S) {</p>
<p>unordered_map&lt;char,vector&lt;int&gt;&gt; table;</p>
<p>for(int i=0;i&lt;S.size();i++){</p>
<p>if(table.count(S[i])&gt;0) table[S[i]][1]=i;</p>
<p>else table[S[i]]=vector&lt;int&gt;{i,i};</p>
<p>}</p>
<p>int i=0;</p>
<p>int left,right;</p>
<p>char cur;</p>
<p>vector&lt;int&gt; answer;</p>
<p>while(i&lt;S.size()){</p>
<p>cur=S[i];</p>
<p>left=table.find(S[i])-&gt;second[0];</p>
<p>right=table.find(S[i])-&gt;second[1];</p>
<p>for(int j=left+1;j&lt;right;j++){</p>
<p>if(table.find(S[j])-&gt;second[1]&gt;right){</p>
<p>right=table.find(S[j])-&gt;second[1];</p>
<p>}</p>
<p>}</p>
<p>answer.push_back(right-left+1);</p>
<p>i=right+1;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>- void <strong>swap</strong>(a, b) : a와 b를 교환</p>
<p>- T <strong>exchange</strong>(T t, U u) : t에 u를 할당, 원래 t를 반환</p>
<p>- 이거는 O(n) solution 임. Discussion에서 봄. 확실히 간단함.</p>
<p>vector&lt;int&gt; partitionLabels(string S) {</p>
<p>vector&lt;int&gt; res, pos(26, 0);</p>
<p>for (auto i = 0; i &lt; S.size(); ++i) pos[S[i] - 'a'] = i;</p>
<p>for (auto i = 0, idx = INT_MIN, last_i = 0; i &lt; S.size(); ++i) {</p>
<p>idx = max(idx, pos[S[i] - 'a']);</p>
<p>if (idx == i) res.push_back(i - exchange(last_i, i + 1) + 1);</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>[51. <strong>Reveal Cards In Increasing Order – 주어진 단계에 따랐을 때, 오름차순으로 카드가 정렬될 수 있도록 하는 문제. 설명을 봐야됨] 2020-01-31 10:09</strong></p>
<p>In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.</p>
<p>Initially, all the cards start face down (unrevealed) in one deck.</p>
<p>Now, you do the following steps repeatedly, until all cards are revealed:</p>
<ol class="incremental" type="1">
<li><p>Take the top card of the deck, reveal it, and take it out of the deck.</p></li>
<li><p>If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.</p></li>
<li><p>If there are still unrevealed cards, go back to step 1.  Otherwise, stop.</p></li>
</ol>
<p>Return an ordering of the deck that would reveal the cards in <strong>increasing order.</strong></p>
<p>The first entry in the answer is considered to be the top of the deck.</p>
<p>- 이 문제 처음에는 가늠도 안갔음. 어떻게 풀어야 하는지.</p>
<p>- Discussion을 참고했더니, 하는 단계를 역으로 하는 해법이 있었음. 세상의 천재는 많음. ㄹㅇ…</p>
<p>vector&lt;int&gt; deckRevealedIncreasing(vector&lt;int&gt;&amp; deck) {</p>
<p>sort(deck.begin(),deck.end());</p>
<p>vector&lt;int&gt; answer;</p>
<p>while(deck.size()){</p>
<p>// second step</p>
<p>if(answer.size()){</p>
<p>answer.insert(answer.begin(),answer.back());</p>
<p>answer.pop_back();</p>
<p>}</p>
<p>//first step</p>
<p>answer.insert(answer.begin(),deck.back());</p>
<p>deck.pop_back();</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[52. <strong>All Paths From Source to Target – 그래프의 모든 paths를 반환하는 문제] 2020-02-04 11:43</strong></p>
<p><strong>-</strong> “from node 0 to node N-1”이 말이 키포인트 임. 문제를 잘 읽어야 함.</p>
<p>- dfs로 푸는건데 생각해내기 쉽지 않음.</p>
<p>- 와 코딩 열심히 해야겠따 ㄹㅇ...</p>
<p>void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph,vector&lt;vector&lt;int&gt;&gt;&amp; answer,vector&lt;int&gt; table,int cur){</p>
<p>table.push_back(cur);</p>
<p>if(cur==graph.size()-1){</p>
<p>answer.push_back(table);</p>
<p>return;</p>
<p>}</p>
<p>for(int i=0;i&lt;graph[cur].size();i++)</p>
<p>dfs(graph,answer,table,graph[cur][i]);</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>vector&lt;int&gt; table;</p>
<p>dfs(graph,answer,table,0);</p>
<p>return answer;</p>
<p>}</p>
<p>[53. <strong>Binary Tree Pruning – 1을 포함하지 않는 모든 subtree를 제거하는 문제] 2020-02-04 11:51</strong></p>
<p><strong>-</strong> 이 문제는 리프노드이면서 value가 0인 노드를 리프에서부터 제거해서 루트로 올라오면 된다.</p>
<p>- 조건에 부합하여 제거된 노드의 부모가 다시 조건에 부합하게 되면, 그역시 삭제해야 한다.</p>
<p>void helper(TreeNode* root){</p>
<p>if(!root) return;</p>
<p>helper(root-&gt;left);</p>
<p>helper(root-&gt;right);</p>
<p>if(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right &amp;&amp; root-&gt;left-&gt;val==0)</p>
<p>root-&gt;left=nullptr;</p>
<p>if(root-&gt;right&amp;&amp; !root-&gt;right-&gt;left &amp;&amp; !root-&gt;right-&gt;right &amp;&amp; root-&gt;right-&gt;val==0)</p>
<p>root-&gt;right=nullptr;</p>
<p>}</p>
<p>TreeNode* pruneTree(TreeNode* root) {</p>
<p>helper(root);</p>
<p>return root;</p>
<p>}</p>
<p>[54. <strong> All Possible Full Binary Trees – 어려워서 못풀었음.]</strong></p>
<p><strong>-</strong> DFS 랑 BFS로 풀라그랬는데 실패함. discussion봤는데 divide and conquer 길래 읽어봐도 뭔소린지 모르겠음. 그래서 youtube를 참고하려고 함.</p>
<p>- youtube에도 중국인 설명밖에 없음. 모르겠다 이문제 ㄷㄷ;</p>
<p>- 이해했다. 1개로 만들수 있는 트리, 3개로 만들 수 있는 트리를 계속저장해가면서 불러오는거 같다.</p>
<p>- 이게 정답인데, 이해할려면 시간 좀 걸릴 듯.</p>
<p>unordered_map&lt;int, vector&lt;TreeNode*&gt;&gt; cache;</p>
<p>vector&lt;TreeNode*&gt; allPossibleFBT(int N) {</p>
<p>vector&lt;TreeNode*&gt; res;</p>
<p>if(cache[N].size() != 0) return cache[N];</p>
<p>if(N == 1) {</p>
<p>res.push_back(new TreeNode(0));</p>
<p>} else {</p>
<p>for (int i = 1; i &lt; N; i += 2) {</p>
<p>int l = i, r = N - i - 1;</p>
<p>for (TreeNode* left : allPossibleFBT(l)) {</p>
<p>for (TreeNode* right : allPossibleFBT(r)) {</p>
<p>TreeNode * root = new TreeNode(0);</p>
<p>root-&gt;left = left;</p>
<p>root-&gt;right = right;</p>
<p>res.push_back(root);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cache[N] = res;</p>
<p>return res;</p>
<p>}</p>
<p>[55. <strong>Find and Replace Pattern – 주어진 pattern과 같은 순열을 가지는 word들을 반환하는 문제]</strong></p>
<p>- 나는 unordered_map을 이용해서, 주어진 string의 pattern을 숫자로 나타내었음. 그리고 word들을 숫자로 나타낸 것과 비교함.</p>
<p>vector&lt;string&gt; findAndReplacePattern(vector&lt;string&gt;&amp; words, string pattern) {</p>
<p>vector&lt;string&gt; answer;</p>
<p>unordered_map&lt;char,int&gt; p_table;</p>
<p>int count=1;</p>
<p>for(int i=0;i&lt;pattern.size();i++){</p>
<p>if(!p_table[pattern[i]]) p_table[pattern[i]]=count++;</p>
<p>}</p>
<p>string answer_pattern;</p>
<p>for(int i=0;i&lt;pattern.size();i++){</p>
<p>answer_pattern+=p_table[pattern[i]]+48;</p>
<p>}</p>
<p>unordered_map&lt;char,int&gt; match;</p>
<p>count=1;</p>
<p>string temp;</p>
<p>for(string word:words){</p>
<p>for(int i=0;i&lt;word.size();i++){</p>
<p>if(!match[word[i]]) match[word[i]]=count++;</p>
<p>}</p>
<p>for(int i=0;i&lt;word.size();i++){</p>
<p>temp+=match[word[i]]+48;</p>
<p>}</p>
<p>if(temp.compare(answer_pattern)==0)</p>
<p>answer.push_back(word);</p>
<p>count=1;</p>
<p>temp=&quot;&quot;;</p>
<p>match.clear();</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[56. <strong>Find Elements in a Contaminated Binary Tree – 오염된 트리를 재구성하고 target value를 찾는 문제]</strong></p>
<ol class="incremental" type="1">
<li><p>root.val == 0</p></li>
<li><p>If treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1</p></li>
<li><p>If treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2</p></li>
</ol>
<p>- 위 공식대로 트리를 재구성한 후 target을 찾으면 된다.</p>
<p>- set을 이용하여 모든 노드 값을 저장하는 것이 target을 더 빨리 찾는 방법이다. 왜냐하면 순회를 하지 않아도 되기 때문이다.</p>
<p>TreeNode* answer;</p>
<p>unordered_set&lt;int&gt; value_set;</p>
<p>void recover(TreeNode* root){</p>
<p>if(!root) return;</p>
<p>if(root-&gt;left)</p>
<p>root-&gt;left-&gt;val=2*root-&gt;val+1;</p>
<p>if(root-&gt;right)</p>
<p>root-&gt;right-&gt;val=2*root-&gt;val+2;</p>
<p>value_set.insert(root-&gt;val);</p>
<p>recover(root-&gt;left);</p>
<p>recover(root-&gt;right);</p>
<p>}</p>
<p>FindElements(TreeNode* root) {</p>
<p>root-&gt;val=0;</p>
<p>answer=root;</p>
<p>recover(root);</p>
<p>}</p>
<p>bool helper(TreeNode* root,bool flag,int target){</p>
<p>if(!root) return flag;</p>
<p>if(root-&gt;val==target) return true;</p>
<p>flag=helper(root-&gt;left,flag,target);</p>
<p>flag=helper(root-&gt;right,flag,target);</p>
<p>return flag;</p>
<p>}</p>
<p>bool find(int target) {</p>
<p>//return helper(answer,false,target);</p>
<p>return value_set.count(target);</p>
<p>}</p>
<p>[57. <strong>Matrix Block Sum – 주어진 조건에 맞는 모든 원소를 더해 벡터로 만드는 문제]</strong></p>
<p><strong>-</strong> 일단 문제 이해하는데 좀 걸림.</p>
<p>- for문을 4개나 썼는데, 더 빨리 풀 수 있는방법이 있을 것 같음. 전에 합해놓은 값을 그대로 이용한다던가 하는…</p>
<p>vector&lt;vector&lt;int&gt;&gt; matrixBlockSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; res;</p>
<p>vector&lt;int&gt; temp_answer;</p>
<p>int temp_sum=0;</p>
<p>for(int i=0;i&lt;mat.size();i++){</p>
<p>for(int j=0;j&lt;mat[i].size();j++){</p>
<p>for(int r=i-k;r&lt;=i+k;r++){</p>
<p>if(r&lt;0 || r&gt;=mat.size())</p>
<p>continue;</p>
<p>for(int c=j-k;c&lt;=j+k;c++){</p>
<p>if(c&lt;0||c&gt;=mat[i].size())</p>
<p>continue;</p>
<p>temp_sum+=mat[r][c];</p>
<p>}</p>
<p>}</p>
<p>temp_answer.push_back(temp_sum);</p>
<p>temp_sum=0;</p>
<p>}</p>
<p>res.push_back(temp_answer);</p>
<p>temp_answer.clear();</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>[58. <strong>Minimum Add to Make Parentheses Valid – 주어진 string에서 괄호가 valid하게 되기위해 필요한 괄호의 개수를 반환하는 문제]</strong></p>
<p><strong>-</strong> 그냥 각 케이스의 경우를 생각해서 풀었음.</p>
<p>int minAddToMakeValid(string S) {</p>
<p>int res=0;</p>
<p>int left=0,right=0;</p>
<p>bool left_first=false;</p>
<p>for(int i=0;i&lt;S.size();i++){</p>
<p>if(S[i]=='('){</p>
<p>left++;</p>
<p>res++;</p>
<p>continue;</p>
<p>}</p>
<p>if(S[i]==')'){</p>
<p>if(left){</p>
<p>left--;</p>
<p>res--;</p>
<p>continue;</p>
<p>}</p>
<p>res++;</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>[59. <strong>Score After Flipping Matrix – 주어진 matrix를 자유롭게 toggle 즉, 0과 1을 뒤바꾸어 이진수로 취급할 때의 최대 합을 구하는 문제]</strong></p>
<p><strong>-</strong> 일단 맨 첫 비트가 1이되도록 각 row를 toggle해주고, 이후 모든 columns을 탐색하면서 0의 개수가 1의 개수보다 많으면 toggle한다.</p>
<p>int sumUp(vector&lt;vector&lt;int&gt;&gt; temp){</p>
<p>int sum=0;</p>
<p>int power=0;</p>
<p>for(int i=0;i&lt;temp.size();i++){</p>
<p>for(int j=temp[i].size()-1;j&gt;=0;j--,power++){</p>
<p>if(temp[i][j])</p>
<p>sum+=pow(2,power);</p>
<p>}</p>
<p>power=0;</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) {</p>
<p>//row toggle</p>
<p>for(int i=0;i&lt;A.size();i++){</p>
<p>if(A[i][0]==0){// if leading bit is 1, then toggle it.</p>
<p>for(int j=0;j&lt;A[i].size();j++)</p>
<p>A[i][j]^=1;</p>
<p>}</p>
<p>}</p>
<p>//col toggle when 0s are more than 1s in the current column.</p>
<p>int zeros=0;</p>
<p>int ones=0;</p>
<p>for(int i=0;i&lt;A[0].size();i++){</p>
<p>for(int j=0;j&lt;A.size();j++){</p>
<p>if(A[j][i]==0) zeros++;</p>
<p>else ones++;</p>
<p>}</p>
<p>if(zeros&gt;ones){ // toggle the column.</p>
<p>for(int j=0;j&lt;A.size();j++)</p>
<p>A[j][i]^=1;</p>
<p>}</p>
<p>ones=0;</p>
<p>zeros=0;</p>
<p>}</p>
<p>return sumUp(A);</p>
<p>}</p>
<p>[60. <strong>Maximum Level Sum of a Binary Tree – 노드들의 총합이 가장 큰 minimum level을 찾는 문제]</strong></p>
<p>- 나는 pair와 map을 이용하여 bfs로 풀었다. pair 접근할 때, -&gt; 로 접근하는 것이 아니라 ‘.’ 마침표로 접근한다. root.first 이렇게</p>
<p>- 생각해보니 dfs로 풀면 훨씬 빠를 것 같다. que도 pair도 필요없이 재귀로만 풀 수 있을 듯.</p>
<p>void bfs(queue&lt;pair&lt;TreeNode*,int&gt;&gt;&amp; que,unordered_map&lt;int,int&gt;&amp; level_sum){</p>
<p>if(que.empty()) return;</p>
<p>pair&lt;TreeNode*,int&gt; root=que.front();</p>
<p>que.pop();</p>
<p>level_sum[root.second]+=root.first-&gt;val;</p>
<p>if(root.first-&gt;left) que.push(make_pair(root.first-&gt;left,root.second+1));</p>
<p>if(root.first-&gt;right) que.push(make_pair(root.first-&gt;right,root.second+1));</p>
<p>bfs(que,level_sum);</p>
<p>}</p>
<p>int maxLevelSum(TreeNode* root) {</p>
<p>queue&lt;pair&lt;TreeNode*,int&gt;&gt; que;</p>
<p>int sum=root-&gt;val;</p>
<p>que.push(make_pair(root,1));</p>
<p>unordered_map&lt;int,int&gt; level_sum;</p>
<p>bfs(que,level_sum);</p>
<p>int max_level=1;</p>
<p>for(unordered_map&lt;int,int&gt;::iterator iter=level_sum.begin();iter!=level_sum.end();iter++){</p>
<p>if(iter-&gt;second&gt;sum){</p>
<p>sum=iter-&gt;second;</p>
<p>max_level=iter-&gt;first;</p>
<p>}</p>
<p>}</p>
<p>return max_level;</p>
<p>}</p>
<p>[61. <strong>Path In Zigzag Labelled Binary Tree – 레벨마다 내림차순, 오름차순이 바뀌는 포화 이진트리에서 주어진 label까지의 경로를 출력하는 문제]</strong></p>
<p>- 주어진 트리에 숫자가 순서대로는 들어가 있으므로, 부모노드는 자신의 value/2라는 것을 이용함.</p>
<p>-이때 홀수 레벨은 오름차순이고, 짝수 레벨은 내림차순이므로 계산을 따로 해줌.</p>
<p>vector&lt;int&gt; pathInZigZagTree(int label) {</p>
<p>//leftmost node of level n is 2^(n-1) when root's level is 1.</p>
<p>//rightmost node of level n is 2^n -1.</p>
<p>//find rightmost node greater than label. Then we can find the level of label.</p>
<p>//if n is odd, then the nodes of the level have normal sequence, otherwise reverse sequence.</p>
<p>//In normal case, parents node's value is label / 2, we can use it.</p>
<p>vector&lt;int&gt; answer;</p>
<p>answer.push_back(label);</p>
<p>int level=1;</p>
<p>while(pow(2,level)-1&lt;label) level++; //find the label's level.</p>
<p>int temp=label;</p>
<p>int position=0;</p>
<p>while(level&gt;1){</p>
<p>if(level%2==0) position=(pow(2,level)-1-temp)/2; //find next postion.</p>
<p>else position=(temp-pow(2,level-1))/2;</p>
<p>level--; // we find the postion of the upper level. so we don't need current level anymore.</p>
<p>if(level%2==0) temp=pow(2,level)-1-position;</p>
<p>else temp=pow(2,level-1)+position;</p>
<p>answer.push_back(temp);</p>
<p>}</p>
<p>return {answer.rbegin(),answer.rend()};</p>
<p>}</p>
<p>[62. <strong>Maximum Nesting Depth of Two Valid Parentheses Strings – 최소 깊이를 가지도록 괄호들을 두개의 그룹으로 나누는 문제]</strong></p>
<p>- 문제 설명부터 이해하기 힘듬. 주어진 스트링에서 나열된 순서와 상관 없이, 왼쪽 오른쪽 짝만 맞으면 한 그룹에 들어갈 수 있음. 이렇게 짝을 맞추면서 두개의 그룹으로 나눌 때, 최소의 깊이를 가지게 하면 됨.</p>
<p>- discussion을 보고서 문제를 이해했고, 답도 거기서 힌트를 얻었음.</p>
<p>- 일단 각 괄호의 깊이를 모두 구함. 그리고 홀수는 A에 짝수는 B에 넣음. 즉, 깊이가 하나 깊어질 때마다 다른 그룹에 넣어주면 깊이가 최소가 됨.</p>
<p>- 이런 문제는 누가 생각해내는 거야…</p>
<p>vector&lt;int&gt; maxDepthAfterSplit(string seq) {</p>
<p>vector&lt;int&gt; depth;</p>
<p>int cur_depth=0;</p>
<p>for(int i=0;i&lt;seq.size();i++)</p>
<p>if(seq[i]=='(') depth.push_back(++cur_depth);</p>
<p>else depth.push_back(cur_depth--);</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(int i=0;i&lt;depth.size();i++)</p>
<p>depth[i]%2? answer.push_back(0):answer.push_back(1);</p>
<p>return answer;</p>
<p>}</p>
<p>- for문을 두개 안쓰고, 하나만 쓰면서 깊이를 구하자마자 바로 answer에 넣을 수도 있음.</p>
<p>vector&lt;int&gt; maxDepthAfterSplit(string seq) {</p>
<p>vector&lt;int&gt; depth;</p>
<p>vector&lt;int&gt; answer;</p>
<p>int cur_depth=0;</p>
<p>for(int i=0;i&lt;seq.size();i++){</p>
<p>if(seq[i]=='(') depth.push_back(++cur_depth);</p>
<p>else depth.push_back(cur_depth--);</p>
<p>depth[i]%2? answer.push_back(0):answer.push_back(1);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[63. <strong>Distribute Coins in Binary Tree – 모든 노드가 1개의 coin을 갖도록 분배할 때, 코인이 움직이는 개수를 구하는 문제]</strong></p>
<p><strong>-</strong> 한번에 한칸 움직일 수 있고, 그때 움직인 coin의 개수를 총합한 것이 답이다.</p>
<p>- bottom up으로 풀려고 했고, 실제로 discussion의 방법들과 동일했는데, 나는 중간에 막혔다.</p>
<p>- discussion을 참고하여 풀었다. abs로 move를 더해주는 것이 key였다.</p>
<p>int getCoin(TreeNode* root,int&amp; move){</p>
<p>if(!root) return 0;</p>
<p>root-&gt;val+=getCoin(root-&gt;left,move);</p>
<p>root-&gt;val+=getCoin(root-&gt;right,move);</p>
<p>move+=abs(root-&gt;val-1);</p>
<p>return root-&gt;val-1;</p>
<p>}</p>
<p>int distributeCoins(TreeNode* root) {</p>
<p>int move=0;</p>
<p>getCoin(root,move);</p>
<p>return move;</p>
<p>}</p>
<p>[64. <strong>Queens That Can Attack the King – king과 같은 row,column,diagnal 에 있는 가장 가까운 queen의 좌표를 찾는 문제]</strong></p>
<p>- 처음에는 BFS를 사용할까 생각했는데, 그냥 8x8 배열 만들어 퀸 좌표를 모두 넣은 다음, 킹에서부터 가장 가까운 것 찾는 for문8번돌리는게 시간상 빠를 것 같아서 그렇게 함.</p>
<p>vector&lt;vector&lt;int&gt;&gt; queensAttacktheKing(vector&lt;vector&lt;int&gt;&gt;&amp; queens, vector&lt;int&gt;&amp; king) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; chess;</p>
<p>chess.assign(8,vector&lt;bool&gt;(8)); //2차원 벡터 메모리 초기화</p>
<p>for(int i=0;i&lt;queens.size();i++)</p>
<p>chess[queens[i][0]][queens[i][1]]=true;</p>
<p>int x=king[0];</p>
<p>int y=king[1];</p>
<p>//left</p>
<p>for(int i=x-1;i&gt;=0;i--){</p>
<p>if(chess[i][y]){</p>
<p>answer.push_back(vector&lt;int&gt;{i,y});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//right</p>
<p>for(int i=x+1;i&lt;chess.size();i++){</p>
<p>if(chess[i][y]){</p>
<p>answer.push_back(vector&lt;int&gt;{i,y});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//up</p>
<p>for(int i=y-1;i&gt;=0;i--){</p>
<p>if(chess[x][i]){</p>
<p>answer.push_back(vector&lt;int&gt;{x,i});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//down</p>
<p>for(int i=y+1;i&lt;chess.size();i++){</p>
<p>if(chess[x][i]){</p>
<p>answer.push_back(vector&lt;int&gt;{x,i});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//up-left</p>
<p>for(int i=x-1,j=y-1;i&gt;=0 &amp;&amp; j&gt;=0;i--,j--){</p>
<p>if(chess[i][j]){</p>
<p>answer.push_back(vector&lt;int&gt;{i,j});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//up-right</p>
<p>for(int i=x+1,j=y-1;i&lt;chess.size() &amp;&amp; j&gt;=0;i++,j--){</p>
<p>if(chess[i][j]){</p>
<p>answer.push_back(vector&lt;int&gt;{i,j});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//down-left</p>
<p>for(int i=x-1,j=y+1;i&gt;=0&amp;&amp;j&lt;chess.size();i--,j++){</p>
<p>if(chess[i][j]){</p>
<p>answer.push_back(vector&lt;int&gt;{i,j});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//down-right</p>
<p>for(int i=x+1,j=y+1;i&lt;chess.size()&amp;&amp;j&lt;chess.size();i++,j++){</p>
<p>if(chess[i][j]){</p>
<p>answer.push_back(vector&lt;int&gt;{i,j});</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[65. <strong>Battleships in a Board – 인접하지 않은 the number of rows of Xs or cols of Xs 를 찾는 문제]</strong></p>
<p>- 푸는 건 어렵지 않았음. 그냥 top-left 부터 시작해서 X만날 때 연이은 X를 모두 ‘.’으로 바꾸어주면 됨.</p>
<p>int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) {</p>
<p>int res=0;</p>
<p>int temp;</p>
<p>for(int i=0;i&lt;board.size();i++){</p>
<p>for(int j=0;j&lt;board[i].size();j++){</p>
<p>if(board[i][j]=='X'){</p>
<p>res++;</p>
<p>board[i][j]='.';</p>
<p>temp=j+1;</p>
<p>while(temp&lt;board[i].size()&amp;&amp;board[i][temp]=='X') board[i][temp++]='.';</p>
<p>temp=i+1;</p>
<p>while(temp&lt;board.size()&amp;&amp;board[temp][j]=='X') board[temp++][j]='.';</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>- follow up에 O(1) memory without modifying the value of board가 있어서 discussion을 들어가 봄. head of ships 를 찾는 문제로 변형 됨.</p>
<p>int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) {</p>
<p>if(board.empty() || board.front().empty()) return 0;</p>
<p>int res=0;</p>
<p>for(int i=0;i&lt;board.size();i++)</p>
<p>for(int j=0;j&lt;board[i].size();j++) //just find ship's head.</p>
<p>res+= board[i][j]=='X' &amp;&amp; (i==0|| board[i-1][j]!='X') &amp;&amp; (j==0||board[i][j-1]!='X');</p>
<p>return res;</p>
<p>}</p>
<p>[66. <strong>Count Square Submatrices with All Ones – 사각형이 몇 개 존재하는 지 구하는 문제]</strong></p>
<p>- 처음에는 top-left를 기준으로 만들어지는 square의 개수를 만드려고 다음과 같은 코드를 짰음.</p>
<p>- 그런데 time limit exceeded 함.</p>
<p>- 짱구를 더 굴려 보자구.</p>
<p>int isSquare(int x, int y, int size,vector&lt;vector&lt;int&gt;&gt; matrix){</p>
<p>int res=0; //how many square current coordinates can make.</p>
<p>int temp=1; // current size of square +1</p>
<p>bool flag=true; // whether current considering square is valid square or not.</p>
<p>while(temp&lt;size){</p>
<p>cout&lt;&lt;&quot;x : &quot;&lt;&lt;x&lt;&lt;&quot; y : &quot;&lt;&lt;y&lt;&lt;&quot; temp : &quot;&lt;&lt;temp&lt;&lt;endl;</p>
<p>for(int j=y;j&lt;=y+temp;j++){</p>
<p>if(x+temp&gt;=matrix.size()||j&gt;=matrix[0].size()||!matrix[x+temp][j]){</p>
<p>flag=false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>cout&lt;&lt;&quot;pass1&quot;&lt;&lt;endl;</p>
<p>// thr bottom-right value doesn't need to be considered twice. so i&lt;x+temp</p>
<p>for(int i=x;i&lt;x+temp;i++){</p>
<p>if(y+temp&gt;=matrix[0].size()||i&gt;matrix.size()||!matrix[i][y+temp]){</p>
<p>flag=false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if(!flag) break;</p>
<p>cout&lt;&lt;&quot;pass2&quot;&lt;&lt;endl;</p>
<p>res++;</p>
<p>temp++;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {</p>
<p>int res=0;</p>
<p>int minSize=min(matrix.size(),matrix[0].size());</p>
<p>for(int i=0;i&lt;matrix.size();i++){</p>
<p>for(int j=0;j&lt;matrix[i].size();j++){</p>
<p>if(matrix[i][j]){</p>
<p>res+=isSquare(i,j,minSize,matrix) + 1; // the rightmost 1 is for square of side 1</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>- 특정되는 사각형 수가 크기가 N X N 일때, 총 사각형의 개수는1^2 + 2^2 + … + N^2 임.</p>
<p><img src="data:image/png;base64,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" style="width:2.69792in;height:2.07292in" />을 참고하면 될 듯.</p>
<p>- 위에 것도 접근이 너무 어려움. DP로 푸는 거였음. 하 나는 DP가 너무 약해…</p>
<p>- 근데 이 DP는 진짜 생각해내기 너무 어려운 것 같은데?</p>
<p>- 내 생각에는 이건 그냥 암기다.</p>
<p>int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {</p>
<p>int res=0;</p>
<p>for(int i=0;i&lt;matrix.size();i++){</p>
<p>for(int j=0;j&lt;matrix[i].size();j++){</p>
<p>if(matrix[i][j] &amp;&amp; i &amp;&amp; j) matrix[i][j]+=min(matrix[i][j-1],min(matrix[i-1][j-1],matrix[i-1][j]));</p>
<p>res+=matrix[i][j];</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<ol class="incremental" type="1">
<li><p>if matrix[i][j] == 0, skip</p></li>
<li><p>use bottom right to count the square, if a 2 * 2 grid like<br />
&quot; A B &quot;<br />
&quot; C X &quot;<br />
every character means the nums of the square that position can represent. For example A = 2 represents 2 squares in the &quot;A&quot; position, one is itself and the other is a 2 * 2 square , a 2 * 2 square means A is in the position like<br />
&quot; 1 1 &quot;<br />
&quot; 1 A &quot;<br />
so X should be Math.min(A+1, B+1, C+1) which ensures X is in the postion like<br />
&quot; 1 ... 1 &quot; //k * k, k = Math.min(A+1, B+1, C+1)<br />
&quot; 1 .... . &quot;<br />
&quot; 1 ... X &quot;<br />
for example<br />
<img src="data:image/png;base64,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" style="width:3.58333in;height:3.42708in" /><br />
in the yellow grid, we know (D4=3) (E4=2) (D5=2) and then how to calculate the (E5).<br />
D4 = 3 means the largest sqaure it can represent is the black one(3* 3) === we can find 3 sqaures which its bottom right is D4 (1* 1, 2* 2, 3* 3 squares).<br />
Then the same as E4(red square) and D5(green one). When it comse to E5, (E5) = Math.min(D4+1, E4+1, D5+1) means the largest square E5 can represent which is (C3 ~ E5)</p></li>
<li><p>because we are using the bottom right to count the square, the &quot;A B C&quot; will always be calculated before &quot;X&quot;. So just go through the grid then and add all nums in the grid</p></li>
</ol>
<p>[67. <strong>Spiral Matrix III – 나선모양으로 걸으면서 거친 좌표를 차례대로 벡터에 넣는 문제]</strong></p>
<p>- 이 문제 왜캐 어려웠지… Discussion을 안보고 풀라고 애썼는 데, 실패했다.</p>
<p>- 이 문제의 포인트는 boundary 바깥으로 나가는 것을 고려하지 않아도 된다는 것이었다. 나선형만 제대로 짜 놓으면 어차피 다시 안으로 들어올 것이고, 주어진 boundary안에 좌표가 있을 때만 answer에 더해주면 되는 것이었다.</p>
<p>vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0){</p>
<p>vector&lt;vector&lt;int&gt;&gt; res={{r0,c0}};</p>
<p>int max_step=R*C;</p>
<p>vector&lt;int&gt; cur_pos={r0,c0};</p>
<p>vector&lt;vector&lt;int&gt;&gt; dir={{0,1},{1,0},{0,-1},{-1,0}};</p>
<p>int head=0;</p>
<p>int cur_step=1;</p>
<p>int how_many_step=0;</p>
<p>while(cur_step&lt;max_step){</p>
<p>if(head==0 || head==2) how_many_step++; // when east or west, the step is added one.</p>
<p>for(int i=0;i&lt;how_many_step;i++){ //how many step we have to go before turning right.</p>
<p>//by using the limit R and C, we don't need to consider a walk around outside.</p>
<p>//because it will be returned into the boundary. we just need to check the walk occurs in the boundary or not.</p>
<p>cur_pos[0]+=dir[head][0];</p>
<p>cur_pos[1]+=dir[head][1];</p>
<p>if(0&lt;=cur_pos[0] &amp;&amp; cur_pos[0]&lt;R &amp;&amp; 0&lt;=cur_pos[1] &amp;&amp; cur_pos[1]&lt;C){</p>
<p>cur_step++;</p>
<p>res.push_back(cur_pos);</p>
<p>}</p>
<p>}</p>
<p>head=(head+1)%4;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>[68. <strong>Reduce Array Size to The Half – 배열의 길이를 반 이하로 만들기 위하여 삭제해야하는 원소의 최소개수를 구하는 문제. 이때 각 원소는 중복될 수 있음]</strong></p>
<p>- 내가 생각한 방법의 point는 각 원소의 개수대로 sort를 하는 것이었다. 그래서 pair를 이용했다.</p>
<p>- map 만들때 O(n) sort할 때 O(nlogn)이 걸렸고, 마지막에 length 찾을때 O(n)이 걸렸으므로 O(nlogn)알고리즘 인 것 같다.</p>
<p>- 주의할 점음 pair는 -&gt;이 아니라 . 으로 first, second에 접근한다.</p>
<p>- iterator의 위치를 변경할때는 advance(iter,3)의 방식으로 3번째 다음 인덱스로 iter를 옮길 수 있고, iter간의 거리도 distance(iter1, iter2) 의 형식으로 구할 수 있다.</p>
<p>- 추가로 sort할 때 sort(iter.begin(),iter.end(),greater&lt;int&gt;()); 의 형식으로 하면 내림차순 정렬이 가능하다.</p>
<p>int minSetSize(vector&lt;int&gt;&amp; arr) {</p>
<p>unordered_map&lt;int,int&gt; table;</p>
<p>vector&lt;int&gt; answer_array;</p>
<p>for(int ele : arr){</p>
<p>table[ele]++;</p>
<p>}</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; sorted_pair; //(count,number)</p>
<p>for(unordered_map&lt;int,int&gt;::iterator iter=table.begin();iter!=table.end();iter++)</p>
<p>sorted_pair.push_back(make_pair(iter-&gt;second,iter-&gt;first));</p>
<p>sort(sorted_pair.begin(),sorted_pair.end());</p>
<p>int half=arr.size()/2; // size is always even.</p>
<p>int current_length=0;</p>
<p>for(int i=sorted_pair.size()-1;i&gt;=0;i--){</p>
<p>current_length+=sorted_pair[i].first;</p>
<p>answer_array.push_back(sorted_pair[i].second);</p>
<p>if(current_length&gt;=half) break;</p>
<p>}</p>
<p>return answer_array.size();</p>
<p>}</p>
<p>[69. <strong>Counting Bits - 0부터 주어진 숫자까지의 수들의 bit 표현에서 1의 개수를 세어 vector에 넣는 문제]</strong></p>
<p><strong>-</strong> 나는 그냥 bitset을 이용했다 bitset&lt;32&gt;(i).count()로.</p>
<p>vector&lt;int&gt; countBits(int num) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(int i=0;i&lt;=num;i++)</p>
<p>answer.push_back(bitset&lt;32&gt;(i).count());</p>
<p>return answer;</p>
<p>}</p>
<p>- 다음과 같은 logic으로도 풀 수 있다.</p>
<p>There is one imporant observation we can make about the number of bits in each number.</p>
<ol class="incremental" type="1">
<li><p>Each Power of 2 has exactly only 1 bit. (2 : 0010 , 4: 0100, 8:1000, 16:10000)</p></li>
<li><p>Each number after the power of 2 follows a pecular pattern :<br />
0 → 0<br />
1 → 0<br />
2 → 1 + dp[0] Nearest Power of 2<br />
3 → 1 + dp[1] 1 greater than nearest<br />
4 → 1 + dp[0] Nearest<br />
5 → 1+ dp[1] 1 greater than nearest<br />
6 → 1+ dp[2] 2 greater than nearest<br />
7 → 1+ dp[3] 3 greater than nearest<br />
8 → 1+ dp[0] Nearest<br />
9 → 1+ dp[1]<br />
10 → 1+ dp[2]<br />
11 → 1+ dp[3]<br />
12 → 1+ dp[4]</p></li>
</ol>
<p>You can easily see the pattern here.</p>
<p>[70. <strong>Complex Number Multiplication – 복소수 2개를 주고 곱하여 string으로 출력하는 문제]</strong></p>
<p><strong>-</strong> 그냥 각 복소수의 실수와 허수부분을 나누어 곱해주는 방식으로 했는데, 부호 구분하는 데서 오래 걸렸다.</p>
<p>string complexNumberMultiply(string a, string b) {</p>
<p>string answer;</p>
<p>vector&lt;int&gt; a_sub;</p>
<p>vector&lt;int&gt; b_sub;</p>
<p>string temp=&quot;&quot;;</p>
<p>int i=1;</p>
<p>if(a[0]=='-'){</p>
<p>while('0'&lt;=a[i] &amp;&amp; a[i]&lt;='9') temp+=a[i++];</p>
<p>a_sub.push_back(std::stoi(temp)*-1);</p>
<p>}</p>
<p>else{</p>
<p>i=0;</p>
<p>while('0'&lt;=a[i] &amp;&amp; a[i]&lt;='9') temp+=a[i++];</p>
<p>a_sub.push_back(std::stoi(temp));</p>
<p>}</p>
<p>temp.clear();</p>
<p>if(b[0]=='-'){</p>
<p>i=1;</p>
<p>while('0'&lt;=b[i] &amp;&amp; b[i]&lt;='9') temp+=b[i++];</p>
<p>b_sub.push_back(std::stoi(temp)*-1);</p>
<p>}</p>
<p>else{</p>
<p>i=0;</p>
<p>while('0'&lt;=b[i] &amp;&amp; b[i]&lt;='9') temp+=b[i++];</p>
<p>b_sub.push_back(std::stoi(temp));</p>
<p>}</p>
<p>i=a.size()-2;</p>
<p>temp.clear();</p>
<p>while('0'&lt;=a[i] &amp;&amp; a[i]&lt;='9') i--;</p>
<p>if(a[i]=='-'){</p>
<p>i++;</p>
<p>while('0'&lt;=a[i] &amp;&amp; a[i]&lt;='9') temp+=a[i++];</p>
<p>a_sub.push_back(std::stoi(temp)*-1);</p>
<p>}</p>
<p>else{</p>
<p>i++;</p>
<p>while('0'&lt;=a[i] &amp;&amp; a[i]&lt;='9') temp+=a[i++];</p>
<p>a_sub.push_back(std::stod(temp));</p>
<p>}</p>
<p>i=b.size()-2;</p>
<p>temp.clear();</p>
<p>while('0'&lt;=b[i] &amp;&amp; b[i]&lt;='9') i--;</p>
<p>if(b[i]=='-'){</p>
<p>i++;</p>
<p>while('0'&lt;=b[i] &amp;&amp; b[i]&lt;='9') temp+=b[i++];</p>
<p>b_sub.push_back(std::stoi(temp)*-1);</p>
<p>}</p>
<p>else{</p>
<p>i++;</p>
<p>while('0'&lt;=b[i] &amp;&amp; b[i]&lt;='9') temp+=b[i++];</p>
<p>b_sub.push_back(std::stoi(temp));</p>
<p>}</p>
<p>answer+=std::to_string(a_sub[0]*b_sub[0]+a_sub[1]*b_sub[1]*-1);</p>
<p>answer+='+';</p>
<p>answer+=std::to_string(a_sub[1]*b_sub[0]+a_sub[0]*b_sub[1]);</p>
<p>answer+='i';</p>
<p>return answer;</p>
<p>}</p>
<p>- find 함수 이용 간단하게 풀 수 있는 discussion이 있었다.</p>
<p>public:</p>
<p>string complexNumberMultiply(string a, string b) {</p>
<p>pair&lt;int, int&gt; av = parse(a);</p>
<p>pair&lt;int, int&gt; bv = parse(b);</p>
<p>int ra = av.first * bv.first - av.second * bv.second;</p>
<p>int rb = av.first * bv.second + av.second * bv.first;</p>
<p>return to_string(ra) + &quot;+&quot; + to_string(rb) + &quot;i&quot;;</p>
<p>}</p>
<p>pair&lt;int, int&gt; parse(const string&amp; a) {</p>
<p>int plus = find(a.begin(), a.end(), '+') - a.begin();</p>
<p>int i = find(a.begin(), a.end(), 'i') - a.begin();</p>
<p>int ra = stoi(a.substr(0, plus));</p>
<p>int rb = stoi(a.substr(plus + 1, i - plus));</p>
<p>return {ra, rb};</p>
<p>}</p>
<p>[71. <strong>Fizz Buzz Multithreaded -Thread 사용하는 문제]</strong></p>
<p>- 덕분에 thread 공부했다. 하지만 나는 풀 수 없었기에, discussion 보고 thread 어떻게 쓰는지 배웠다.</p>
<p>private:</p>
<p>int n;</p>
<p>int count;</p>
<p>mutex m;</p>
<p>condition_variable cv;</p>
<p>public:</p>
<p>FizzBuzz(int n) {</p>
<p>this-&gt;n = n;</p>
<p>this-&gt;count = 1;</p>
<p>}</p>
<p>void fizz(function&lt;void()&gt; printFizz) {</p>
<p>while (true) {</p>
<p>unique_lock&lt;mutex&gt; lock(m);</p>
<p>while (count &lt;= n &amp;&amp; (count % 3 != 0 || count % 5 == 0))</p>
<p>cv.wait(lock);</p>
<p>if (count &gt; n) return;</p>
<p>printFizz();</p>
<p>++count;</p>
<p>cv.notify_all();</p>
<p>}</p>
<p>}</p>
<p>void buzz(function&lt;void()&gt; printBuzz) {</p>
<p>while (true) {</p>
<p>unique_lock&lt;mutex&gt; lock(m);</p>
<p>while (count &lt;= n &amp;&amp; (count % 5 != 0 || count % 3 == 0))</p>
<p>cv.wait(lock);</p>
<p>if (count &gt; n) return;</p>
<p>printBuzz();</p>
<p>++count;</p>
<p>cv.notify_all();</p>
<p>}</p>
<p>}</p>
<p>void fizzbuzz(function&lt;void()&gt; printFizzBuzz) {</p>
<p>while (true) {</p>
<p>unique_lock&lt;mutex&gt; lock(m);</p>
<p>while (count &lt;= n &amp;&amp; (count % 5 != 0 || count % 3 != 0))</p>
<p>cv.wait(lock);</p>
<p>if (count &gt; n) return;</p>
<p>printFizzBuzz();</p>
<p>++count;</p>
<p>cv.notify_all();</p>
<p>}</p>
<p>}</p>
<p>void number(function&lt;void(int)&gt; printNumber) {</p>
<p>while (true) {</p>
<p>unique_lock&lt;mutex&gt; lock(m);</p>
<p>while (count &lt;= n &amp;&amp; (count % 5 == 0 || count % 3 == 0))</p>
<p>cv.wait(lock);</p>
<p>if (count &gt; n) return;</p>
<p>printNumber(count++);</p>
<p>cv.notify_all();</p>
<p>}</p>
<p>}</p>
<p>[72. <strong>[951] Flip Equivalent Binary Trees – when we choose any node and swap left and right subtrees, we call it a flip operation. Write a function whether two given trees are flip equivalent.]</strong></p>
<p>- no matter a tree is filped or not, its children have to be same or just changed the order.</p>
<p>- So we can just compare every possible situation – Greedy using DFS.</p>
<p>bool flag=true;</p>
<p>void helper(TreeNode* root1,TreeNode* root2){</p>
<p>if(!root1-&gt;left &amp;&amp; !root1-&gt;right &amp;&amp; !root2-&gt;left &amp;&amp; !root2-&gt;right)</p>
<p>return;</p>
<p>if(root1-&gt;left &amp;&amp; root2-&gt;left &amp;&amp; root1-&gt;left-&gt;val == root2-&gt;left-&gt;val)</p>
<p>helper(root1-&gt;left,root2-&gt;left);</p>
<p>else if(root1-&gt;left &amp;&amp; root2-&gt;right &amp;&amp; root1-&gt;left-&gt;val==root2-&gt;right-&gt;val)</p>
<p>helper(root1-&gt;left,root2-&gt;right);</p>
<p>else if(root1-&gt;left){</p>
<p>flag=false;</p>
<p>return;</p>
<p>}</p>
<p>if(!flag) return;</p>
<p>else if(root1-&gt;right &amp;&amp; root2-&gt;left &amp;&amp; root1-&gt;right-&gt;val==root2-&gt;left-&gt;val)</p>
<p>helper(root1-&gt;right,root2-&gt;left);</p>
<p>else if(root1-&gt;right &amp;&amp; root2-&gt;right &amp;&amp; root1-&gt;right-&gt;val==root2-&gt;right-&gt;val)</p>
<p>helper(root1-&gt;right,root2-&gt;right);</p>
<p>else if(root1-&gt;right){</p>
<p>cout&lt;&lt;&quot;flag&quot;&lt;&lt;endl;</p>
<p>flag=false;</p>
<p>}</p>
<p>}</p>
<p>bool flipEquiv(TreeNode* root1, TreeNode* root2) {</p>
<p>if(!root1 &amp;&amp; !root2) return true;</p>
<p>if((root1 &amp;&amp; !root2) ||(!root1 &amp;&amp; root2)) return false;</p>
<p>helper(root1,root2);</p>
<p>return flag;</p>
<p>}</p>
<p>[73. [<strong>1123] Lowest Common Ancestor of Deepest Leave]</strong></p>
<p><strong>-</strong> find deepest level from root. If the deepest depth is same, then the root is the answer.</p>
<p>- if the depth is different. determine which one has deeper depth between left and right child.</p>
<p>- and doing recursive with the child who has deeper detph.</p>
<p>int helper(TreeNode* root){</p>
<p>if(!root) return 0;</p>
<p>return 1+max(helper(root-&gt;left),helper(root-&gt;right));</p>
<p>}</p>
<p>TreeNode* lcaDeepestLeaves(TreeNode* root) {</p>
<p>int left=helper(root-&gt;left);</p>
<p>int right=helper(root-&gt;right);</p>
<p>if(left==right) return root;</p>
<p>else if(left&gt;right) return lcaDeepestLeaves(root-&gt;left);</p>
<p>else return lcaDeepestLeaves(root-&gt;right);</p>
<p>}</p>
<p>[74. <strong>[986]</strong> <strong>Interval List Intersections – Given two sorted closed interval, return the intersection of these two lists.]</strong></p>
<p>- At first try, I use map to record interval of two lists into one store with using vector in the map for checking every interval’s end.</p>
<p>- I think I just need O(total interval of A and B + map.size()). But time limit exceeded occurs.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) {</p>
<p>map&lt;int,vector&lt;int&gt;&gt; inter;</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>int i;</p>
<p>for(vector&lt;int&gt; ele : A){</p>
<p>for(i=ele[0];i&lt;ele[1];i++){</p>
<p>inter[i]={1,0,0};</p>
<p>}</p>
<p>inter[i]={1,1,0};</p>
<p>}</p>
<p>for(vector&lt;int&gt; ele : B){</p>
<p>for(i=ele[0];i&lt;=ele[1];i++){</p>
<p>if(inter[i].empty()) inter[i]={1,0,0};</p>
<p>else inter[i][0]++;</p>
<p>}</p>
<p>inter[i-1][2]=1;</p>
<p>}</p>
<p>map&lt;int,vector&lt;int&gt;&gt;::iterator iter=inter.begin();</p>
<p>int left=0;</p>
<p>for(;iter!=inter.end();iter++){</p>
<p>if(iter-&gt;second[0]==2){</p>
<p>left=iter-&gt;first;</p>
<p>while(iter-&gt;second[0]==2){</p>
<p>if(iter-&gt;second[1]==1 || iter-&gt;second[2]==1)</p>
<p>break;</p>
<p>else iter++;</p>
<p>}</p>
<p>answer.push_back({left,iter-&gt;first});</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>- I guess the reason why the time limit exceed occurs is because I search all the element in each intervals. So I should figure out how to solve this problem by just using left and right limit of each intervals only.</p>
<p>- the final answer is that if A[i][1] is less than B[j][0], i++, vice versa j++.</p>
<p>- after that we can find overlapping range by two lists. From there, we just determine which one is left and right limit.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>for(int i=0, j=0;i&lt;A.size() &amp;&amp; j&lt;B.size();){</p>
<p>if(A[i][1]&lt;B[j][0]) i++;</p>
<p>else if(A[i][0]&gt;B[j][1]) j++;</p>
<p>else{</p>
<p>answer.push_back({max(A[i][0],B[j][0]),min(A[i][1],B[j][1])});</p>
<p>if(A[i][1]&lt;B[j][1]) i++;</p>
<p>else j++;</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[75. [<strong>1110] Delete Nodes And Return Forest – delete given node, and return roots of every subtrees.]</strong></p>
<p>- I solved this problme using bottom-up approach.</p>
<p>- First at all, using postorder search and if a current node has to be deleted, insert their children into answer vector, and come back to parents node, finally delete the node.</p>
<p>- but the point is how I can handle the original root node, value 1, because of that, I have to use another find function whether the to_delete vector has 1 or not. so it cunsume pretty much time I think.</p>
<p>- Tommrow I will revise this algorithm.</p>
<p>public:</p>
<p>TreeNode* helper(TreeNode* root,vector&lt;TreeNode*&gt;&amp; answer, vector&lt;int&gt;&amp; to_delete){</p>
<p>if(!root) return nullptr;</p>
<p>TreeNode* left=nullptr;</p>
<p>TreeNode* right=nullptr;</p>
<p>left=helper(root-&gt;left,answer,to_delete);</p>
<p>right=helper(root-&gt;right,answer,to_delete);</p>
<p>if(left) root-&gt;left=nullptr;</p>
<p>if(right) root-&gt;right=nullptr;</p>
<p>for(int i=0;i&lt;to_delete.size();i++){</p>
<p>if(to_delete[i]==root-&gt;val){</p>
<p>if(root-&gt;left) answer.push_back(root-&gt;left);</p>
<p>if(root-&gt;right) answer.push_back(root-&gt;right);</p>
<p>//to_delete.erase(to_delete.begin()+i);</p>
<p>return root;</p>
<p>}</p>
<p>}</p>
<p>return nullptr;</p>
<p>}</p>
<p>vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) {</p>
<p>vector&lt;TreeNode*&gt; answer;</p>
<p>helper(root,answer,to_delete);</p>
<p>if(find(to_delete.begin(),to_delete.end(),1)==to_delete.end()) answer.push_back(root);</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[76. [<strong>969] Pancake Sorting – find the order of indexs to reverse the given vector from vector.begin() so that the vector is sorted]</strong></p>
<p>- the flip begin from A[0]. so we have to sort from A.end() descendantly.</p>
<p>- at first, we have to find the largest elements that can be found using A.length.</p>
<p>- then flip from start to the largest elements index so that the largest elements come to first index.</p>
<p>- and reverse all A so as to put the largest elements to last index. and so on.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; A) {</p>
<p>int largest=A.size();</p>
<p>vector&lt;int&gt;::iterator last=A.end();</p>
<p>vector&lt;int&gt;::iterator cur;</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(int i=0; i&lt;A.size()-1; i++){</p>
<p>cur=find(A.begin(),last,largest);</p>
<p>cur++;</p>
<p>answer.push_back(distance(A.begin(),cur));</p>
<p>answer.push_back(distance(A.begin(),last));</p>
<p>reverse(A.begin(),cur);</p>
<p>reverse(A.begin(),last);</p>
<p>largest--;</p>
<p>advance(last,-1);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[77. [<strong>959] Regions Cut By Slashes – return how many distinct regions appear after dividing whole square by /, \]</strong></p>
<p><strong>-</strong> I solved this problem using BFS. But the result was time limit exceeded.</p>
<p>- 1. make the given array 3 time widen. Because to recognize distinct region, we need at least 3 time wider array.</p>
<p>- 2. draw given line to divide region.</p>
<p>- 3. using BFS, paint regions and count hom many regions are.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void helper(vector&lt;vector&lt;int&gt;&gt;&amp; table,queue&lt;pair&lt;int,int&gt;&gt; que){</p>
<p>while(!que.empty()){</p>
<p>int x=que.front().first;</p>
<p>int y=que.front().second;</p>
<p>que.pop();</p>
<p>table[x][y]=1;</p>
<p>if(x &amp;&amp; table[x-1][y]==0) que.push(make_pair(x-1,y));</p>
<p>if(y &amp;&amp; table[x][y-1]==0) que.push(make_pair(x,y-1));</p>
<p>if(x!=table.size()-1 &amp;&amp; table[x+1][y]==0) que.push(make_pair(x+1,y));</p>
<p>if(y!=table[0].size()-1 &amp;&amp; table[x][y+1]==0) que.push(make_pair(x,y+1));</p>
<p>}</p>
<p>}</p>
<p>void paintRegion(vector&lt;vector&lt;int&gt;&gt;&amp; table,int&amp; answer){</p>
<p>queue&lt;pair&lt;int,int&gt;&gt; que;</p>
<p>for(int i=0;i&lt;table.size();i++){</p>
<p>for(int j=0;j&lt;table[i].size();j++){</p>
<p>if(table[i][j]==0){</p>
<p>que.push(make_pair(i,j));</p>
<p>helper(table,que);</p>
<p>answer++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int regionsBySlashes(vector&lt;string&gt;&amp; grid) {</p>
<p>int N=grid.size()*3;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N,vector&lt;int&gt;(N,0)); //make table N*3 X N*3</p>
<p>for(int i=0;i&lt;grid.size();i++){</p>
<p>for(int j=0;j&lt;grid[i].size();j++){</p>
<p>if(grid[i][j]=='/'){</p>
<p>table[i*3][3*j+2]=1;</p>
<p>table[i*3+1][3*j+1]=1;</p>
<p>table[i*3+2][3*j]=1;</p>
<p>}</p>
<p>else if(grid[i][j]=='\\'){</p>
<p>table[i*3][3*j]=1;</p>
<p>table[i*3+1][3*j+1]=1;</p>
<p>table[i*3+2][3*j+2]=1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int answer=0;</p>
<p>paintRegion(table,answer);</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>- due to time limit exceeded, I changed my algorithm to DFS.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void paintRegion(vector&lt;vector&lt;int&gt;&gt;&amp; table,int x, int y){</p>
<p>if(table[x][y]==0){</p>
<p>table[x][y]=1;</p>
<p>if(x) paintRegion(table,x-1,y);</p>
<p>if(y) paintRegion(table,x,y-1);</p>
<p>if(x!=table.size()-1) paintRegion(table,x+1,y);</p>
<p>if(y!=table.size()-1) paintRegion(table,x,y+1);</p>
<p>}</p>
<p>}</p>
<p>int regionsBySlashes(vector&lt;string&gt;&amp; grid) {</p>
<p>int N=grid.size()*3;</p>
<p>int answer=0;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N,vector&lt;int&gt;(N,0)); //make table N*3 X N*3</p>
<p>for(int i=0;i&lt;grid.size();i++){</p>
<p>for(int j=0;j&lt;grid[i].size();j++){</p>
<p>if(grid[i][j]=='/'){</p>
<p>table[i*3][3*j+2]=1;</p>
<p>table[i*3+1][3*j+1]=1;</p>
<p>table[i*3+2][3*j]=1;</p>
<p>}</p>
<p>else if(grid[i][j]=='\\'){</p>
<p>table[i*3][3*j]=1;</p>
<p>table[i*3+1][3*j+1]=1;</p>
<p>table[i*3+2][3*j+2]=1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for(int i=0;i&lt;table.size();i++){</p>
<p>for(int j=0;j&lt;table[i].size();j++){</p>
<p>if(table[i][j]==0){</p>
<p>paintRegion(table,i,j);</p>
<p>answer++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[78. [<strong>1130] Minimum Cost Tree From Leaf Values – find minimum sum of non-leaf node using the given leaves.]</strong></p>
<p>- Atually, this problem was super difficult for me. First at all, I thought I sholud have construted a real tree. But it’s quite insane jobs.</p>
<p>- so I tried to make dp but it was not that easy. Finally, I refered to discussion.</p>
<p>- O(N^2) algorithm is below.</p>
<p>&gt; 1. find minimum leaf of the array : val1</p>
<p>&gt; 2. find min(the leaf’s left, the leaf’s right) : val2</p>
<p>&gt; 3. answer+= val1 * val2</p>
<p>&gt; 4. remove val1 and repeat from 1st.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int mctFromLeafValues(vector&lt;int&gt;&amp; arr) {</p>
<p>int answer=0;</p>
<p>int minimum;</p>
<p>int second;</p>
<p>while(arr.size()&gt;1){</p>
<p>minimum=min_element(arr.begin(),arr.end())-arr.begin(); //minimum value's index</p>
<p>if(minimum==0) second=1;</p>
<p>else if(minimum==arr.size()-1) second=minimum-1;</p>
<p>else{</p>
<p>if(arr[minimum+1]&gt;arr[minimum-1]) second=minimum-1;</p>
<p>else second=minimum+1;</p>
<p>}</p>
<p>answer+=arr[minimum]*arr[second];</p>
<p>arr.erase(arr.begin()+minimum);</p>
<p>if(minimum&gt;second) minimum--;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>- Now I’m trying to understand O(N^3) solution that uses dp.</p>
<p>- The dp solusion from discussion is below.</p>
<p><strong>Intuition and Algorithm</strong><br />
Given an array arr return the smallest possible sum of the values of each non-leaf node.<br />
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.</p>
<p>For example:<br />
arr= [3, 6, 4, 7, 2, 5]</p>
<p><img src="data:image/png;base64,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" alt="image" style="width:6.01042in;height:4.84375in" /></p>
<p>This is one distribution, we are going to solve that from top to bottom with dynammic programming</p>
<p><strong>Approach 1 (DP)</strong><br />
In the image the root, their left subtree contains indexes [0-3] and their right subtree cointains indexes [4-5]. Then their value will be max(arr[0-3])* max(arr[4-5]).</p>
<p>In general:<br />
dp(left, right )= min( max(arr[left .. i] ) * max(arr[i+1 .. right]) + dp(left,i) +dp(i+1,right) ) where i go from left to right-1</p>
<p>class Solution {</p>
<p>public:</p>
<p>int memo[41][41];</p>
<p>int maxi[41][41];</p>
<p>int dp(int left,int right){</p>
<p>if(left==right)return 0; //leaf node</p>
<p>if(memo[left][right]!=-1)return memo[left][right];</p>
<p>int ans = 1&lt;&lt;30;</p>
<p>for(int i=left;i&lt;right;i++)</p>
<p>ans= min(ans, maxi[left][i] * maxi[i+1][right] + dp(left,i) + dp(i+1,right) );</p>
<p>memo[left][right]=ans;</p>
<p>return ans;</p>
<p>}</p>
<p>int mctFromLeafValues(vector&lt;int&gt;&amp; arr) {</p>
<p>memset(memo,-1,sizeof(memo));</p>
<p>for(int i=0;i&lt;arr.size();i++){</p>
<p>maxi[i][i] = arr[i];</p>
<p>for(int j=i+1;j&lt;arr.size();j++)</p>
<p>maxi[i][j] = max(maxi[i][j-1], arr[j]);</p>
<p>}</p>
<p>return dp(0,arr.size()-1);</p>
<p>}</p>
<p>};</p>
<p>[79 [<strong>889] Construct Binary Tree from Preorder and Postorder Traversal – make a binary tree using the given pre and postorder traversals]</strong></p>
<p><strong>-</strong> My first algorithm is that the right next node of current node in preoder traversal is root’s left child and the left next node of current node in post traversal is root’s right child.</p>
<p>- But it’s wrong.</p>
<p>- So I tried a divivde and conquer approach.</p>
<p>- What a difficult problem! I spent almost 4 hours for this heck!</p>
<p>- The key point is divide each traversal respectively.</p>
<p>- And if after making left child, mid+1==postr, then just have to return root.</p>
<p>class Solution {</p>
<p>public:</p>
<p>unordered_map&lt;int,int&gt; table;</p>
<p>TreeNode* helper(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post,int prel,int prer,int postl, int postr){</p>
<p>TreeNode* root=new TreeNode(pre[prel]);</p>
<p>if(prel==prer) return root;</p>
<p>int mid=table[pre[prel+1]];</p>
<p>int length=mid-postl;</p>
<p>root-&gt;left=helper(pre,post,prel+1,prel+length+1,postl,postl+length);</p>
<p>if(mid+1==postr) return root;</p>
<p>root-&gt;right=helper(pre,post,prel+length+2,prer,mid+1,postr-1);</p>
<p>return root;</p>
<p>}</p>
<p>TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) {</p>
<p>for(int i=0;i&lt;post.size();i++) table[post[i]]=i;</p>
<p>TreeNode* root=helper(pre,post,0,pre.size()-1,0,post.size()-1);</p>
<p>return root;</p>
<p>}</p>
<p>};</p>
<p>[80. [<strong>791] Custom Sort String – given sorted array S in a custm way, sort array T so that it is sorted like array S]</strong></p>
<p>‑ Intuition is below</p>
<p>&gt; 1. count each letter in the array T into an unordered_map count.</p>
<p>&gt; 2. For a character C from S.begin to S.end, if the map count has the character of S, add it to answer as many as count[C]</p>
<p>&gt; 3. concatenat all the rest charater in the map count.</p>
<p>class Solution {</p>
<p>public:</p>
<p>string customSortString(string S, string T) {</p>
<p>unordered_map&lt;char,int&gt; count;</p>
<p>for(char c : T)</p>
<p>count[c]++;</p>
<p>string answer;</p>
<p>for(char c : S){</p>
<p>if(count.find(c)!=count.end()){</p>
<p>while(count[c]&gt;0){</p>
<p>answer+=c;</p>
<p>count[c]--;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>unordered_map&lt;char,int&gt;::iterator iter=count.begin();</p>
<p>for(;iter!=count.end();iter++){</p>
<p>while(iter-&gt;second&gt;0){</p>
<p>answer+=iter-&gt;first;</p>
<p>iter-&gt;second--;</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[81. [<strong>442] Find All Duplicates in an Array – find numbers which occur twice]</strong></p>
<p>- If I just have to problem without concerning memory ans time consuming, it is easy.</p>
<p>- But the point is to use only O(1) memory and O(n) time.</p>
<p>- Algorithm is below</p>
<p>&gt; 1. using numbers in array nums as index and negate it. It’s possible since 1&lt;=nums[i]&lt;=n where 0&lt;=i&lt;n.</p>
<p>&gt; 2. if a number occurs twice, the number’s sign must be + not -.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(int i : nums){</p>
<p>i=abs(i);</p>
<p>nums[i-1]=-nums[i-1];</p>
<p>if(nums[i-1]&gt;0) answer.push_back(i);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[82. [<strong>1343] Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold – find the number of sub-array of size K that has an average greater than or equal to given threshold]</strong></p>
<p>- Algorithm is below</p>
<p>&gt; 1. From first of the given array, add K-1 elements. =&gt; cur_sum</p>
<p>&gt; 2. iteratively, make cur_sum has K elements. if K’s average is valid about the given condition. then add 1 to answer</p>
<p>&gt; subtract arr[i-k+1] from cur_sum and add arr[[i] to cur]sum and repeat the algorithm from 2.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int numOfSubarrays(vector&lt;int&gt;&amp; arr, int k, int threshold) {</p>
<p>int cur_sum=0;</p>
<p>int answer=0;</p>
<p>for(int i=0;i&lt;k-1;i++)</p>
<p>cur_sum+=arr[i];</p>
<p>for(int i=k-1;i&lt;arr.size();i++){</p>
<p>cur_sum+=arr[i];</p>
<p>if(cur_sum/k &gt;= threshold) answer++;</p>
<p>cur_sum-=arr[i-k+1];</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[83. [<strong>1043] Partition Array for Maximum Sum – partition the given array into subarrays of length at most given K. each subarray’s value will be changed the greatest value in the subarrays. return the largest sum of the given arrays after partitioning]</strong></p>
<p><strong>-</strong> what the heck? this problem is not a midium level. I think!, Yes, I may not good at DP problem :).</p>
<p>- Anyway, I tried to solve this problem 2d DP.</p>
<p>- row is index, col is the size of partition.</p>
<p>- Algorithm is just &gt;&gt; dp[i][j] = max(dp[i-j]…dp[i-1]) + max(A[i-j+1]….A[i])*j).</p>
<p><img src="data:image/png;base64,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" style="width:6.26806in;height:6.15903in" /></p>
<p>- But tiem limit exceeded occurred.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void printDP(vector&lt;vector&lt;int&gt;&gt; dp){</p>
<p>for(int i=0;i&lt;dp.size();i++){</p>
<p>for(int j=0;j&lt;dp[i].size();j++){</p>
<p>cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</p>
<p>}</p>
<p>cout&lt;&lt;endl;</p>
<p>}</p>
<p>}</p>
<p>void initializeDP(vector&lt;int&gt; A, int K, vector&lt;vector&lt;int&gt;&gt;&amp; dp){</p>
<p>//vector initialized</p>
<p>for(int i=0;i&lt;A.size();i++)</p>
<p>dp[i][0]=A[i]; //when K=1;</p>
<p>//initialize DP's diagonal.</p>
<p>for(int i=1,j=1;i&lt;K;i++,j++){</p>
<p>dp[i][j]=*std::max_element(A.begin(),next(A.begin(),i+1))*(j+1);</p>
<p>}</p>
<p>//initialize DP's upper triangle.</p>
<p>for(int i=0;i&lt;K;i++){</p>
<p>for(int j=i+1;j&lt;K;j++){</p>
<p>dp[i][j]=dp[i][j-1];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int dpMAX(vector&lt;vector&lt;int&gt;&gt;&amp; dp,vector&lt;int&gt; A, int K, int i, int j){</p>
<p>int res=INT_MIN;</p>
<p>int prev;</p>
<p>int max_ele=INT_MIN;</p>
<p>for(int a=i-(j+1);a&lt;i;a++){</p>
<p>prev=dp[a][j]; // a = 1</p>
<p>for(int b=a+1;b&lt;=i;b++){</p>
<p>max_ele=max(max_ele,A[b]);</p>
<p>}</p>
<p>res=max(res,prev+max_ele*(i-a));</p>
<p>max_ele=INT_MIN;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int maxSumAfterPartitioning(vector&lt;int&gt;&amp; A, int K) {</p>
<p>if(K==1){</p>
<p>return accumulate(A.begin(),A.end(),0);</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; dp(A.size(),vector&lt;int&gt;(K,0));</p>
<p>initializeDP(A,K,dp);</p>
<p>for(int j=1;j&lt;K;j++){</p>
<p>for(int i=j+1;i&lt;A.size();i++){</p>
<p>dp[i][j]=dpMAX(dp,A,K,i,j);</p>
<p>}</p>
<p>}</p>
<p>printDP(dp);</p>
<p>return dp[A.size()-1][K-1];</p>
<p>}</p>
<p>};</p>
<p>- I happened to recognize that I don’t need the 2d DP, since I don’t use previous j(which is 1…K-1) array in the 2d DP. I needed just dp[i][K].</p>
<p>- so I revised my algorithm to an 1d DP.</p>
<p>- speed was 11.42% beats. I know is quite slow, but I’m happy I could solve this problem :).</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void initializeDP(vector&lt;int&gt; A, int K, vector&lt;int&gt;&amp; dp){</p>
<p>int max_ele=INT_MIN;</p>
<p>for(int i=0;i&lt;K;i++)</p>
<p>dp[i]=*max_element(A.begin(),next(A.begin(),i+1))*(i+1);</p>
<p>}</p>
<p>int dpMAX(vector&lt;int&gt;&amp; dp,vector&lt;int&gt; A,int i,int K){</p>
<p>int res=INT_MIN;</p>
<p>int prev;</p>
<p>int max_ele=INT_MIN;</p>
<p>for(int a=i-K;a&lt;i;a++){</p>
<p>prev=dp[a];</p>
<p>for(int b=a+1;b&lt;=i;b++){</p>
<p>max_ele=max(max_ele,A[b]);</p>
<p>}</p>
<p>res=max(res,prev+max_ele*(i-a));</p>
<p>max_ele=INT_MIN;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int maxSumAfterPartitioning(vector&lt;int&gt;&amp; A, int K) {</p>
<p>if(K==1){</p>
<p>return accumulate(A.begin(),A.end(),0);</p>
<p>}</p>
<p>vector&lt;int&gt; dp(A.size(),0);</p>
<p>initializeDP(A,K,dp);</p>
<p>for(int i=K;i&lt;A.size();i++){</p>
<p>dp[i]=dpMAX(dp,A,i,K);</p>
<p>}</p>
<p>return dp[A.size()-1];</p>
<p>}</p>
<p>};</p>
<p>[84. [<strong>1219] Path with Maximum Gold – find a path to get maximum gold]</strong></p>
<p><strong>-</strong> I used DFS to solve this problem. the algorithm is quite intutive. I think the explanation is not needed. just cafeful to use visit array.</p>
<p>- but time limit exceeded occurred.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt; grid,int x,int y,vector&lt;vector&lt;int&gt;&gt; visit){</p>
<p>visit[x][y]=1;</p>
<p>int cur_gold=grid[x][y];</p>
<p>vector&lt;int&gt; max_gold;</p>
<p>if(x &amp;&amp; grid[x-1][y]&amp;&amp; !visit[x-1][y]) max_gold.push_back(DFS(grid,x-1,y,visit));</p>
<p>if(y &amp;&amp; grid[x][y-1]&amp;&amp;!visit[x][y-1]) max_gold.push_back(DFS(grid,x,y-1,visit));</p>
<p>if(x+1&lt;grid.size() &amp;&amp; grid[x+1][y]&amp;&amp;!visit[x+1][y] ) max_gold.push_back(DFS(grid,x+1,y,visit));</p>
<p>if(y+1&lt;grid[0].size() &amp;&amp; grid[x][y+1]&amp;&amp;!visit[x][y+1]) max_gold.push_back(DFS(grid,x,y+1,visit));</p>
<p>return cur_gold+ (max_gold.empty()? 0:*max_element(max_gold.begin(),max_gold.end()));</p>
<p>}</p>
<p>int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</p>
<p>int answer=0;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(grid.size(),vector&lt;int&gt;(grid[0].size(),0));</p>
<p>for(int i=0;i&lt;grid.size();i++)</p>
<p>for(int j=0;j&lt;grid[i].size();j++)</p>
<p>if(grid[i][j])</p>
<p>answer=max(answer,DFS(grid,i,j,visit));</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>- I thought the time limit exceeded happened due to max_gold vector and visit vector. so I remove these.</p>
<p>- First, I changed max_gold vector to int and just compare all the possible DFS. Because putting a value into vector and finding maximum value from that vector need quite long time I think.</p>
<p>- Second, I remove visit vector and just use the condition which is, if a cell has 0 golds, then we don’t need to visit the cell. so whenever I visit a cell, I changed the value to 0 like I collected the gold. After all the visiting to neighbor cells, I returned the amount of gold to the cell.</p>
<p>- Finally, I got speed 96.09% beats :).</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y){</p>
<p>int cur_gold=grid[x][y];</p>
<p>grid[x][y]=0;</p>
<p>int max_gold=0;</p>
<p>if(x &amp;&amp; grid[x-1][y]) max_gold=max(max_gold,DFS(grid,x-1,y));</p>
<p>if(y &amp;&amp; grid[x][y-1]) max_gold=max(max_gold,DFS(grid,x,y-1));</p>
<p>if(x+1&lt;grid.size() &amp;&amp; grid[x+1][y]) max_gold=max(max_gold,DFS(grid,x+1,y));</p>
<p>if(y+1&lt;grid[0].size() &amp;&amp; grid[x][y+1]) max_gold=max(max_gold,DFS(grid,x,y+1));</p>
<p>grid[x][y]=cur_gold;</p>
<p>return cur_gold+ max_gold;</p>
<p>}</p>
<p>int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</p>
<p>int answer=0;</p>
<p>for(int i=0;i&lt;grid.size();i++)</p>
<p>for(int j=0;j&lt;grid[i].size();j++)</p>
<p>if(grid[i][j])</p>
<p>answer=max(answer,DFS(grid,i,j));</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[85. [<strong>877] Stone Game – determine whether alex wins the game or not]</strong></p>
<p>- the game rule is below.</p>
<p>&gt; 1. player can choose either given array’s first or last element.</p>
<p>&gt; 2. player tries to collect most stone(number) and acts optimally.</p>
<p>- we should determine alex can win or not given array.</p>
<p>- I use DFS to solve this problem. Since each player tries to get more stone than the opponent, we should do brute-force.</p>
<p>- At first, I use the start iterator like below</p>
<p>&gt; piles.erase(start);</p>
<p>- but it occurred a heap-buffer-overflow, I don’t know why actually. So I changed the code to use the current function’s pile vector.</p>
<p>- Finally, I could solve this problem. but the speed was just 49.95% beats.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>bool DFS(vector&lt;int&gt; piles, vector&lt;int&gt;::iterator start,vector&lt;int&gt; alex_lee,int turn){</p>
<p>bool answer=false;</p>
<p>if(piles.empty())</p>
<p>return alex_lee[0]&gt;alex_lee[1];</p>
<p>alex_lee[(turn++)%2]+=*start;</p>
<p>if(piles.begin()==start)</p>
<p>piles.erase(piles.begin());</p>
<p>else piles.erase(next(piles.end(),-1));</p>
<p>return DFS(piles,piles.begin(),alex_lee,turn) || DFS(piles,next(piles.end(),-1),alex_lee,turn);</p>
<p>}</p>
<p>bool stoneGame(vector&lt;int&gt;&amp; piles) {</p>
<p>return DFS(piles,piles.begin(),vector&lt;int&gt;{2,0},0) || DFS(piles,next(piles.end(),-1),vector&lt;int&gt;{2,0},0);</p>
<p>}</p>
<p>};</p>
<p>[86. [<strong>1026] Maximum Difference Between Node and Ancestor – find the greatest difference between an ancestor and decendant]</strong></p>
<p>- In my algorithm, I should’ve used both DFS and BFS for brute-force.</p>
<p>- The algorithm is quite vivid. For each node, I check differeces between the current node and its decendants.</p>
<p>- see the code. the speed was bad. It was just 5.20% beats.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int DFS(TreeNode* root,int cur_val){</p>
<p>if(!root) return 0;</p>
<p>return max(abs(root-&gt;val-cur_val),max(DFS(root-&gt;left,cur_val),DFS(root-&gt;right,cur_val)));</p>
<p>}</p>
<p>int maxAncestorDiff(TreeNode* root) {</p>
<p>queue&lt;TreeNode*&gt; que;</p>
<p>TreeNode* cur;</p>
<p>que.push(root);</p>
<p>int answer=0;</p>
<p>while(!que.empty()){</p>
<p>cur=que.front();</p>
<p>que.pop();</p>
<p>if(cur-&gt;left) que.push(cur-&gt;left);</p>
<p>if(cur-&gt;right) que.push(cur-&gt;right);</p>
<p>answer=max(answer,max(DFS(cur-&gt;left,cur-&gt;val),DFS(cur-&gt;right,cur-&gt;val)));</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>- In the discussion, there is such a superb approach using 1d vector.</p>
<p>- The algorithm is below.</p>
<p>&gt; 1. finding every paht from root to leaf. and push to vector.</p>
<p>&gt; 2. Then a lefter element is an ancestor of righter element.</p>
<p>&gt; 3. by using this vector, we can find the maximum difference.</p>
<p>- This algorithm was just O(n) where n is the number of nodes.</p>
<p>- Even, we don’t need the 1d vector, we just have to maintain current maximum and minimum value so that when we meet a leaf node, we can use it to calculate a local maximum difference.</p>
<p>- the speed was 69.22% beats. I reckon it quite fast enough.</p>
<p>-see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void DFS(TreeNode* root, int&amp; answer,int maximum,int minimum){</p>
<p>maximum=max(maximum,root-&gt;val);</p>
<p>minimum=min(minimum,root-&gt;val);</p>
<p>if(!root-&gt;left &amp;&amp; !root-&gt;right){</p>
<p>answer=max(answer,maximum-minimum);</p>
<p>return;</p>
<p>}</p>
<p>if(root-&gt;left) DFS(root-&gt;left,answer,maximum,minimum);</p>
<p>if(root-&gt;right) DFS(root-&gt;right,answer,maximum,minimum);</p>
<p>}</p>
<p>int maxAncestorDiff(TreeNode* root) {</p>
<p>int answer=0;</p>
<p>DFS(root,answer,INT_MIN,INT_MAX);</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[87. [<strong>841] Keys and Rooms – each room has a list of keys to enter rooms. return true if it is possible to enter every room]</strong></p>
<p>- Algorithm is below.</p>
<p>&gt; 1. when I enter a room, inserting every key into queue and recording all the key into can_visit. Finally, removing all the key in the room.</p>
<p>&gt; 2. pop a key from the queue, if I already visited the key’s room, continue. otherwise repeat from 1.</p>
<p>&gt; 3. when queue is empty, checking whether the given the number of rooms is same to can_visit.</p>
<p>- the speed was 68.01% beats.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) {</p>
<p>unordered_set&lt;int&gt; can_visit;</p>
<p>queue&lt;int&gt; que;</p>
<p>int cur_room;</p>
<p>can_visit.insert(0);</p>
<p>for(int i : rooms[0]){</p>
<p>que.push(i);</p>
<p>can_visit.insert(i);</p>
<p>}</p>
<p>rooms[0].clear();</p>
<p>while(!que.empty()){</p>
<p>cur_room=que.front();</p>
<p>que.pop();</p>
<p>if(rooms[cur_room].empty()) continue;</p>
<p>for(int i : rooms[cur_room]){</p>
<p>que.push(i);</p>
<p>can_visit.insert(i);</p>
<p>}</p>
<p>rooms[cur_room].clear();</p>
<p>}</p>
<p>return rooms.size()==can_visit.size();</p>
<p>}</p>
<p>};</p>
<p>[88. <strong> [912] Sort an Array – just sorting an array]</strong></p>
<p><strong>-</strong> I implement merge sort. But the speed was suck! 5.17% beats.</p>
<p>- so I impelment quick sort as well. But the speed was just 16.25% beats.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;int&gt; merge(vector&lt;int&gt; nums){</p>
<p>if(nums.size()==1) return {nums[0]};</p>
<p>vector&lt;int&gt;::iterator mid=next(nums.begin(),nums.size()/2);</p>
<p>vector&lt;int&gt; left;</p>
<p>vector&lt;int&gt; right;</p>
<p>left=merge({nums.begin(),mid});</p>
<p>right=merge({mid,nums.end()});</p>
<p>vector&lt;int&gt; res;</p>
<p>int i=0,j=0;</p>
<p>while(i&lt;left.size() &amp;&amp; j&lt;right.size()){</p>
<p>if(left[i]&gt;right[j]){</p>
<p>res.push_back(right[j]);</p>
<p>j++;</p>
<p>continue;</p>
<p>}</p>
<p>else{</p>
<p>res.push_back(left[i]);</p>
<p>i++;</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<p>while(i&lt;left.size()) res.push_back(left[i++]);</p>
<p>while(j&lt;right.size()) res.push_back(right[j++]);</p>
<p>return res;</p>
<p>}</p>
<p>void quick(vector&lt;int&gt;&amp; nums, int left, int right){</p>
<p>if(left&gt;=right) return;</p>
<p>int pivot=left;</p>
<p>int i=left+1;</p>
<p>int j=right;</p>
<p>while(i&lt;j){</p>
<p>while(i&lt;j &amp;&amp; nums[pivot]&gt;nums[i]) i++;</p>
<p>while(i&lt;j &amp;&amp; nums[pivot]&lt;nums[j]) j--;</p>
<p>if(i&gt;=j) break;</p>
<p>int temp=nums[i];</p>
<p>nums[i]=nums[j];</p>
<p>nums[j]=temp;</p>
<p>i++;</p>
<p>j--;</p>
<p>}</p>
<p>if(nums[pivot]&gt;nums[j]){</p>
<p>int temp=nums[j];</p>
<p>nums[j]=nums[pivot];</p>
<p>nums[pivot]=temp;</p>
<p>}</p>
<p>quick(nums,left,j-1);</p>
<p>quick(nums,j,right);</p>
<p>}</p>
<p>vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {</p>
<p>quick(nums,0,nums.size()-1);</p>
<p>return nums;</p>
<p>}</p>
<p>};</p>
<p>[89. [<strong>406] Queue Reconstruction by Height – standing people by given a height rule]</strong></p>
<p><strong>-</strong> a person have a height and a number which represents the number of person who have a height higher than or equal to the person. by using it, we have sort the given array.</p>
<p>- this problem was quite difficult. Algorithm didn’t happen in my brain.</p>
<p>- Algorithm is below.</p>
<p>&gt; 1. sorting max-height people as a subarray.</p>
<p>&gt; 2. using the value k that each person has as an index, inserting every person to answer vector.</p>
<p>&gt; 3. repeating from 1, until the given array people is empty.</p>
<p>- the speed was 11.52% beats.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;vector&lt;int&gt;&gt; MaxSubarray(int cur_max_value,vector&lt;vector&lt;int&gt;&gt;&amp; people){</p>
<p>vector&lt;vector&lt;int&gt;&gt; cur_max;</p>
<p>vector&lt;vector&lt;int&gt;&gt;::iterator iter=next(people.end(),-1);</p>
<p>for(;iter!=next(people.begin(),-1);iter--){</p>
<p>if(cur_max_value!=iter[0][0]){</p>
<p>iter++;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if(iter==next(people.begin(),-1)) iter=people.begin();</p>
<p>cur_max={iter,people.end()};</p>
<p>people.erase(iter,people.end());</p>
<p>sort(cur_max.begin(),cur_max.end());</p>
<p>return cur_max;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) {</p>
<p>if(people.empty()) return {};</p>
<p>sort(people.begin(),people.end());</p>
<p>vector&lt;vector&lt;int&gt;&gt; cur_max;</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>int cur_max_value=people[people.size()-1][0];</p>
<p>answer=MaxSubarray(cur_max_value,people);</p>
<p>while(!people.empty()){</p>
<p>cur_max_value=people[people.size()-1][0];</p>
<p>cur_max=MaxSubarray(cur_max_value,people);</p>
<p>for(vector&lt;int&gt; person : cur_max)</p>
<p>answer.insert(next(answer.begin(),person[1]),person);</p>
<p>cout&lt;&lt;endl;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[90. [<strong>429] N-ary Tree Level Order Traversal – split given tree based on levels]</strong></p>
<p>- I think there are two method to solve the problem. one is to use two queues, the other is to use only one queue and to count how many nodes we have to consider in a level</p>
<p>- I chose a second algorithm.</p>
<p>- Algorithm is below.</p>
<p>&gt; 1. For each iteration, memorize how many children are there at a certain level. Then we can use the number as a next level’s the number of nodes.</p>
<p>&gt; 2. And for each iteration, if we met NULL, skip it. otherwise put the node’s children into the queue.</p>
<p>&gt; 3. repeating from 1. until queue becomes empty.</p>
<p>- the speed was 52.03% beats.</p>
<p>-see the code. notice that I added the Node class since it’s not the usual form of normal Node Class.</p>
<p>/*</p>
<p>// Definition for a Node.</p>
<p>class Node {</p>
<p>public:</p>
<p>int val;</p>
<p>vector&lt;Node*&gt; children;</p>
<p>Node() {}</p>
<p>Node(int _val) {</p>
<p>val = _val;</p>
<p>}</p>
<p>Node(int _val, vector&lt;Node*&gt; _children) {</p>
<p>val = _val;</p>
<p>children = _children;</p>
<p>}</p>
<p>};</p>
<p>*/</p>
<p>class Solution {</p>
<p>public:</p>
<p>void levelOrder(Node* root,queue&lt;Node*&gt;&amp; que,vector&lt;int&gt;&amp; cur_level){</p>
<p>if(!root) return;</p>
<p>for(Node* i : root-&gt;children){</p>
<p>que.push(i);</p>
<p>cur_level.push_back(i-&gt;val);</p>
<p>}</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) {</p>
<p>if(!root) return {};</p>
<p>queue&lt;Node*&gt; que;</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>vector&lt;int&gt; cur_level;</p>
<p>que.push(root);</p>
<p>Node* cur;</p>
<p>int need=1;</p>
<p>answer.push_back({{root-&gt;val}});</p>
<p>while(!que.empty()){</p>
<p>for(int count=0;count&lt;need;count++){</p>
<p>cur=que.front();</p>
<p>que.pop();</p>
<p>levelOrder(cur,que,cur_level);</p>
<p>}</p>
<p>if(!cur_level.empty()) answer.push_back(cur_level);</p>
<p>need=cur_level.size();</p>
<p>cur_level.clear();</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[91. [<strong>1238] Circular Permutation in Binary Representation – return a permutation such that p[i] and p[i+1] differ by only one bit in their binary representation]</strong></p>
<p><strong>-</strong> My algorithm is below.</p>
<p>&gt; 1. put string “0” and “1” into vector table as a initial values. since n’s least limit is 1.</p>
<p>&gt; 2. push_back the strings in the vector table in a reverse order.</p>
<p>&gt; 3. add 0’s for the number of table.size()/2 and add 1’s for the rest.</p>
<p>&gt; 4. From 1 to n, repeat the algorithm from 2 to 4.</p>
<p>&gt; 5. reverse all the string in the vector table.</p>
<p>&gt; 6. covert all the string in the vector table to int. the method is below.</p>
<p>&gt;&gt;&gt; Notice: usage of stoi</p>
<p>int i = std::stoi(&quot;01000101&quot;, nullptr, 2);</p>
<ul class="incremental">
<li><blockquote>
<p>The returned value is the converted int value.</p>
</blockquote></li>
<li><blockquote>
<p>The first argument is the std::string you want to convert.</p>
</blockquote></li>
<li><blockquote>
<p>The second is a size_t * where it'll save the index of the first non digit character.</p>
</blockquote></li>
<li><blockquote>
<p>The third is an int that corresponds to the base that'll be used for conversion..</p>
</blockquote></li>
</ul>
<p>&gt; 7. find start position and reconstruct vector to return.</p>
<p>- refer to the picture I drew.</p>
<p><img src="data:image/png;base64,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" style="width:6.26806in;height:5.80139in" /></p>
<p>- the speed was not good. It was just 9.85% beats.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void reverseConcatenate(vector&lt;string&gt;&amp; table){</p>
<p>for(int i=table.size()-1;i&gt;=0;i--)</p>
<p>table.push_back(table[i]);</p>
<p>}</p>
<p>void addBits(vector&lt;string&gt;&amp; table){</p>
<p>for(int i=0;i&lt;table.size()/2;i++)</p>
<p>table[i]+='0';</p>
<p>for(int i=table.size()/2;i&lt;table.size();i++)</p>
<p>table[i]+='1';</p>
<p>}</p>
<p>void reverseStrings(vector&lt;string&gt;&amp; table){</p>
<p>for(int i=0;i&lt;table.size();i++)</p>
<p>reverse(table[i].begin(),table[i].end());</p>
<p>}</p>
<p>vector&lt;int&gt; binaryToInt(vector&lt;string&gt; table){</p>
<p>vector&lt;int&gt; answer;</p>
<p>for(string s : table)</p>
<p>answer.push_back(std::stoi(s,nullptr,2));</p>
<p>return answer;</p>
<p>}</p>
<p>vector&lt;int&gt; circularPermutation(int n, int start) {</p>
<p>vector&lt;string&gt; table={&quot;0&quot;,&quot;1&quot;};</p>
<p>for(int i=2;i&lt;=n;i++){</p>
<p>reverseConcatenate(table);</p>
<p>addBits(table);</p>
<p>}</p>
<p>reverseStrings(table);</p>
<p>vector&lt;int&gt; answer=binaryToInt(table);</p>
<p>vector&lt;int&gt;::iterator iter=find(answer.begin(),answer.end(),start);</p>
<p>vector&lt;int&gt; res={iter,answer.end()};</p>
<p>for(vector&lt;int&gt;::iterator res_iter=answer.begin();res_iter!=iter;res_iter++)</p>
<p>res.push_back(*res_iter);</p>
<p>return res;</p>
<p>}</p>
<p>};</p>
<p>[92. [<strong>998] Maximum Binary Tree II – insert the given value into max heap]</strong></p>
<p>- Algorithm is below.</p>
<p>&gt; 1. if root is exist and root-&gt;val &gt; given value, call the helper function with giving root-&gt;right as a parameter.</p>
<p>&gt; 2. if root is not exist or root-&gt;val&lt;=given value, create a new node of given value.</p>
<p>&gt; 3. Allocate the new node-&gt;left = root. And return the node.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>TreeNode* helper(TreeNode* root, int val){</p>
<p>if(root &amp;&amp; root-&gt;val&gt;val){</p>
<p>root-&gt;right=helper(root-&gt;right,val);</p>
<p>return root;</p>
<p>}</p>
<p>TreeNode* node=new TreeNode(val);</p>
<p>node-&gt;left=root;</p>
<p>return node;</p>
<p>}</p>
<p>TreeNode* insertIntoMaxTree(TreeNode* root, int val) {</p>
<p>return helper(root,val);</p>
<p>}</p>
<p>};</p>
<p>[93. [<strong>739] Daily Temperatures – determine how many days we have to wait so that a temperatur is wamer than today.]</strong></p>
<p>- Algorithm is below.</p>
<p>&gt; 1. make stack and push the last element in the given vector T as a pair with count 0 : (T[i],0)</p>
<p>&gt; 2. For i where t.end-2 to 0, if stack’s top is less than T[i], pop and accumulate count.</p>
<p>&gt; 3. if stack is empty, put the T[i] with 0. otherwise put the t[i] with count and put the count into answer[i]</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) {</p>
<p>stack&lt;pair&lt;int,int&gt;&gt; stk;</p>
<p>vector&lt;int&gt; answer(T.size(),0);</p>
<p>stk.push(make_pair(T.back(),0));</p>
<p>for(int i=T.size()-2;i&gt;=0;i--){</p>
<p>int count=1;</p>
<p>while(!stk.empty() &amp;&amp; stk.top().first&lt;=T[i]){</p>
<p>count+=stk.top().second;</p>
<p>stk.pop();</p>
<p>}</p>
<p>if(stk.empty()){</p>
<p>stk.push(make_pair(T[i],0));</p>
<p>}</p>
<p>else{</p>
<p>stk.push(make_pair(T[i],count));</p>
<p>answer[i]=count;</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[94. [<strong>973] K Closest Points to Origin – calculate Euclidean distance of given coordinates and find K CLosets Points to Origin]</strong></p>
<p>- I used map. key is Euclidean Distance and value is the coordinates.</p>
<p>- Since there might be same Euclidean Distance but different coordinates. I should’ve used vector&lt;vector&lt;int&gt;&gt; as a value of the map.</p>
<p>- the speed was 27.42% beats.</p>
<p>- I found we can use nth_element function that sort the list till given index is sorted.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int Euclidean(int x, int y){</p>
<p>return pow(x,2)+pow(y,2);</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>map&lt;int,vector&lt;vector&lt;int&gt;&gt;&gt; table;</p>
<p>for(vector&lt;int&gt; cor: points)</p>
<p>table[Euclidean(cor[0],cor[1])].push_back({cor[0],cor[1]});</p>
<p>int count=0;</p>
<p>map&lt;int,vector&lt;vector&lt;int&gt;&gt;&gt;::iterator iter=table.begin();</p>
<p>for(int i=0;count&lt;K;i++){</p>
<p>for(int j=0;j&lt;iter-&gt;second.size();j++){</p>
<p>if(count&gt;=K) break;</p>
<p>answer.push_back({iter-&gt;second[j][0],iter-&gt;second[j][1]});</p>
<p>count++;</p>
<p>}</p>
<p>iter++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[94. [<strong>1318] Minimum Flips to Make a OR b Equal to c – return how many filps we need to make a OR b == c]</strong></p>
<p>- Algorithm is below.</p>
<p>&gt; 1. given a,b and c, convert these to bitset.</p>
<p>&gt; 2. if C[i]==1 and A[i]==0 and B[i]==0, then filp++;</p>
<p>&gt; 3. if C[i]==0 and A[i]==1 ,flip++ ,or B[i]==1, filp++; where 0&lt;= i &lt; log2(max(a,b,c)) +1</p>
<p>- the speed was 100% beats.</p>
<p>-see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int minFlips(int a, int b, int c) {</p>
<p>bitset&lt;30&gt; A(a);</p>
<p>bitset&lt;30&gt; B(b);</p>
<p>bitset&lt;30&gt; C(c);</p>
<p>int maximum=max(a,(max(b,c)));</p>
<p>int max_count=log2(maximum)+1;</p>
<p>int flip=0;</p>
<p>for(int i=0;i&lt;max_count;i++){</p>
<p>if(C[i] &amp;&amp; !A[i] &amp;&amp; !B[i]){</p>
<p>flip++;</p>
<p>}</p>
<p>else if(!C[i]){</p>
<p>if(A[i]) flip++;</p>
<p>if(B[i]) flip++;</p>
<p>}</p>
<p>}</p>
<p>return flip;</p>
<p>}</p>
<p>};</p>
<p>[95. [<strong>1306] Jump Game III – determine whether we can reach the index I with value 0 from start position with given rules.]</strong></p>
<p><strong>-</strong> I used map to record which index I have to visit so as to visit current value. That is, map’s key is we want to visit, and map’s value is an index we need to visit the index.</p>
<p>- refer to the picture below.</p>
<p><img src="data:image/png;base64,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" style="width:6.23958in;height:8.64583in" /></p>
<p>&gt; the red rectangular is start position and key 3 is where 0 is.</p>
<p>- I implemented DFS by using stack so that when we have path to 0, find the answer as soon as possible.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>bool canReach(vector&lt;int&gt;&amp; arr, int start) {</p>
<p>if(arr[start]==0) return true;</p>
<p>unordered_map&lt;int,vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;int&gt; zeros;</p>
<p>for(int i=0;i&lt;arr.size();i++){</p>
<p>if(arr[i]==0) zeros.push_back(i);</p>
<p>if(i+arr[i]&lt;arr.size() &amp;&amp; arr[i]) table[i+arr[i]].push_back(i);</p>
<p>if(i-arr[i]&gt;=0 &amp;&amp; arr[i]) table[i-arr[i]].push_back(i);</p>
<p>}</p>
<p>stack&lt;int&gt; index;</p>
<p>for(int i=0;i&lt;zeros.size();i++){</p>
<p>int cur;</p>
<p>index.push(zeros[i]);</p>
<p>while(!index.empty()){</p>
<p>cur=index.top();</p>
<p>index.pop();</p>
<p>if(table.find(cur)==table.end()) continue;</p>
<p>for(int j=0;j&lt;table[cur].size();j++){</p>
<p>if(table[cur][j]==start) return true;</p>
<p>index.push(table[cur][j]);</p>
<p>}</p>
<p>table[cur].clear();</p>
<p>}</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>};</p>
<p>[96 [<strong>931] Minimum Falling Path Sum – find minimum sum of given rules]</strong></p>
<p><strong>-</strong> At first, I used DFS to consider all the path possible. but time limit exceeded occurred.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int helper(vector&lt;vector&lt;int&gt;&gt; A, int i,int j,int sum=0){</p>
<p>if(j&lt;0 || j&gt;=A[0].size()) return INT_MAX;</p>
<p>int cur=sum+A[i][j];</p>
<p>if(i==A.size()-1) return cur;</p>
<p>return min(helper(A,i+1,j-1,cur),min(helper(A,i+1,j,cur),helper(A,i+1,j+1,cur)));</p>
<p>}</p>
<p>int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; A) {</p>
<p>int minimum=INT_MAX;</p>
<p>for(int i=0;i&lt;A[0].size();i++){</p>
<p>minimum=min(minimum,helper(A,0,i));</p>
<p>}</p>
<p>return minimum;</p>
<p>}</p>
<p>};</p>
<p>- I changed my algorithm to DP.</p>
<p>- we don’t need to consider previous row after the minimum value of dp[i][j] is allocated.</p>
<p>- the speed was 99.24 % beats.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; A) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; dp(A.size(),vector&lt;int&gt;(A[0].size(),INT_MAX));</p>
<p>for(int i=0;i&lt;dp[0].size();i++)</p>
<p>dp[0][i]=A[0][i];</p>
<p>for(int i=0;i&lt;dp.size()-1;i++){</p>
<p>for(int j=0;j&lt;dp[0].size();j++){</p>
<p>if(j-1&gt;=0) dp[i+1][j-1]=min(dp[i+1][j-1],dp[i][j]+A[i+1][j-1]);</p>
<p>dp[i+1][j]=min(dp[i+1][j],dp[i][j]+A[i+1][j]);</p>
<p>if(j+1&lt;dp[0].size()) dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][j]+A[i+1][j+1]);</p>
<p>}</p>
<p>}</p>
<p>return *min_element(dp[dp.size()-1].begin(),dp[dp.size()-1].end());</p>
<p>}</p>
<p>};</p>
<p>[97. [<strong>1140] Stone Game II – return the most stones alex can win]</strong></p>
<p><strong>-</strong> Finally, I’ve solved this problem!!! I took almost 5 hours…</p>
<p>- I refered to discussion about (sum+helper())/2</p>
<p>- To resolve time limit exceeded, I used dp.</p>
<p>-see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int helper(vector&lt;int&gt;&amp; piles,int x,int M,bool alex,vector&lt;vector&lt;int&gt;&gt;&amp; dp){</p>
<p>if(dp[x][M]!=INT_MIN) return dp[x][M];</p>
<p>if(piles.size()-x&lt;=2*M){</p>
<p>int sum=0;</p>
<p>for(int i=x;i&lt;piles.size();i++)</p>
<p>sum+=piles[i];</p>
<p>return sum;</p>
<p>}</p>
<p>int res=INT_MIN;</p>
<p>int cur_sum=0;</p>
<p>for(int i=x;i&lt;x+2*M;i++){</p>
<p>cur_sum+=piles[i];</p>
<p>res=max(res,cur_sum-helper(piles,i+1,max(M,i-x+1),!alex,dp));</p>
<p>}</p>
<p>dp[x][M]=res;</p>
<p>return res;</p>
<p>}</p>
<p>int stoneGameII(vector&lt;int&gt;&amp; piles) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; dp(piles.size()+1,vector&lt;int&gt;(piles.size()+1,INT_MIN));</p>
<p>int sum=std::accumulate(piles.begin(),piles.end(),0);</p>
<p>int aa=helper(piles,0,1,true,dp);</p>
<p>int res=(sum+aa)/2;</p>
<p>return res;</p>
<p>}</p>
<p>};</p>
<p>int stoneGameII(vector&lt;int&gt;&amp; piles) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; dp(piles.size()+1,vector&lt;int&gt;(piles.size()+1,INT_MIN));</p>
<p>int sum=std::accumulate(piles.begin(),piles.end(),0);</p>
<p>int aa=helper(piles,0,1,true,dp);</p>
<p>int res=(sum+aa)/2;</p>
<p>return res;</p>
<p>}</p>
<p>};</p>
<p>- At first, I took brute force. But the time limit exceeded occurred.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int helper(vector&lt;int&gt;&amp; piles,int x,int M){</p>
<p>//if the rest stones are less then 2M, return all the rest stones</p>
<p>if(piles.size()-x&lt;=2*M){</p>
<p>int sum=0;</p>
<p>for(int i=x;i&lt;piles.size();i++)</p>
<p>sum+=piles[i];</p>
<p>return sum;</p>
<p>}</p>
<p>//else do brute force.</p>
<p>int sum=INT_MIN;// this variable will be returned.</p>
<p>int cur_sum=0;</p>
<p>int i;</p>
<p>for(int m=1;m&lt;=2*M;m++){ //for every m where 1&lt;=m&lt;=2M, find all the possible case.</p>
<p>cur_sum=0;</p>
<p>for(i=x;i&lt;x+m;i++)</p>
<p>cur_sum+=piles[i];</p>
<p>sum=max(sum,cur_sum-helper(piles,i,max(M,m)));</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>int stoneGameII(vector&lt;int&gt;&amp; piles) {</p>
<p>int sum=std::accumulate(piles.begin(),piles.end(),0);</p>
<p>// i think I have to do brute force.</p>
<p>return (sum+helper(piles,0,1))/2;</p>
<p>}</p>
<p>};</p>
<p>- I don’t understand the algorithm. I gave up…</p>
<p>- they say like, dp[i][j] is the maximum stones alex can get where starting at index I with M=j.</p>
<p>- fxxking DP!!!</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int stoneGameII(vector&lt;int&gt;&amp; piles) {</p>
<p>int length = piles.size();</p>
<p>vector&lt;vector&lt;int&gt;&gt;dp(length + 1, vector&lt;int&gt;(length + 1,0));</p>
<p>vector&lt;int&gt; sufsum (length + 1, 0);</p>
<p>for (int i = length - 1; i &gt;= 0; i--) {</p>
<p>sufsum[i] = sufsum[i + 1] + piles[i];</p>
<p>}</p>
<p>for (int i = 0; i &lt;= length; i++) {</p>
<p>dp[i][length] = sufsum[i];</p>
<p>}</p>
<p>for (int i = length - 1; i &gt;= 0; i--) {</p>
<p>for (int j = length - 1; j &gt;= 1; j--) {</p>
<p>for (int X = 1; X &lt;= 2 * j &amp;&amp; i + X &lt;= length; X++) {</p>
<p>dp[i][j] = max(dp[i][j], sufsum[i] - dp[i + X][max(j, X)]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return dp[0][1];</p>
<p>}</p>
<p>};</p>
<p>[98. [Samsung SW – A : connect processor]]</p>
<p>- I spent almost 5 hours for debugging…</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; drawTable(int cur_size, vector&lt;pair&lt;int, int&gt;&gt;&amp; position,int&amp; chips) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(cur_size, vector&lt;int&gt;(cur_size, 0));</p>
<p>int c;</p>
<p>for (int i = 0; i &lt; cur_size; i++) {</p>
<p>for (int j = 0; j &lt; cur_size;) {</p>
<p>cin &gt;&gt; c;</p>
<p>if (c == 0 || c == 1) {</p>
<p>table[i][j] = c;</p>
<p>if ((i == 0 || j == 0 || i == cur_size - 1 || j == cur_size - 1) &amp;&amp; c==1) {</p>
<p>chips++;</p>
<p>}</p>
<p>else if (c == 1) {</p>
<p>position.push_back(make_pair(i, j));</p>
<p>}</p>
<p>j++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>int cur_size = table.size();</p>
<p>for (int i = 0; i &lt; cur_size; i++) {</p>
<p>for (int j = 0; j &lt; table[i].size(); j++) {</p>
<p>cout &lt;&lt; table[i][j];</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>vector&lt;int&gt; DFS(vector&lt;vector&lt;int&gt;&gt; table, vector&lt;pair&lt;int, int&gt;&gt;&amp; position, int connect,int check, int lines,int numChips,int cur_size) {</p>
<p>if (check ==numChips) {</p>
<p>return { connect,lines };</p>
<p>}</p>
<p>bool flag = false;</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp = table;</p>
<p>int x = position[check].first;</p>
<p>int y = position[check].second;</p>
<p>vector&lt;int&gt; res = { 0,100 };</p>
<p>vector&lt;int&gt; cur = { 0,100 };</p>
<p>//north</p>
<p>for (int i = x - 1; i &gt;= -1; i--) {</p>
<p>if (i &lt; 0) {</p>
<p>flag = true;</p>
<p>res = DFS(temp, position, connect + 1, check+1,lines + x, numChips, cur_size);</p>
<p>if (cur[0] &lt; res[0]) {</p>
<p>cur = res;</p>
<p>}</p>
<p>else if (cur[0] == res[0] &amp;&amp; cur[1] &gt; res[1])</p>
<p>cur = res;</p>
<p>break;</p>
<p>}</p>
<p>if (temp[i][y] == 0) temp[i][y] = 1;</p>
<p>else break;</p>
<p>}</p>
<p>temp = table;</p>
<p>//south</p>
<p>for (int i = x + 1; i &lt;= cur_size; i++) {</p>
<p>if (i &gt;= cur_size) {</p>
<p>flag = true;</p>
<p>res = DFS(temp, position, connect + 1, check+1, lines + cur_size - (x+1 ), numChips, cur_size);</p>
<p>if (cur[0] &lt; res[0]) {</p>
<p>cur = res;</p>
<p>}</p>
<p>else if (cur[0] == res[0] &amp;&amp; cur[1] &gt; res[1])</p>
<p>cur = res;</p>
<p>break;</p>
<p>}</p>
<p>if (temp[i][y] == 0) temp[i][y] = 1;</p>
<p>else break;</p>
<p>}</p>
<p>temp = table;</p>
<p>//east</p>
<p>for (int i = y + 1; i &lt;= cur_size; i++) {</p>
<p>if (i &gt;= cur_size) {</p>
<p>flag = true;</p>
<p>res = DFS(temp, position, connect + 1, check + 1, lines + cur_size - (y+1), numChips, cur_size);</p>
<p>if (cur[0] &lt; res[0]) {</p>
<p>cur = res;</p>
<p>}</p>
<p>else if (cur[0] == res[0] &amp;&amp; cur[1] &gt; res[1])</p>
<p>cur = res;</p>
<p>break;</p>
<p>}</p>
<p>if (temp[x][i] == 0) temp[x][i] = 1;</p>
<p>else break;</p>
<p>}</p>
<p>temp = table;</p>
<p>//west</p>
<p>for (int i = y - 1; i &gt;= -1; i--) {</p>
<p>if (i &lt; 0) {</p>
<p>flag = true;</p>
<p>res = DFS(temp, position, connect + 1, check + 1, lines + y, numChips, cur_size);</p>
<p>if (cur[0] &lt; res[0]) {</p>
<p>cur = res;</p>
<p>}</p>
<p>else if (cur[0] == res[0] &amp;&amp; cur[1] &gt; res[1])</p>
<p>cur = res;</p>
<p>break;</p>
<p>}</p>
<p>if (temp[x][i] == 0) temp[x][i] = 1;</p>
<p>else break;</p>
<p>}</p>
<p>if (!flag) {</p>
<p>cur = DFS(temp, position, connect, check + 1, lines, numChips, cur_size);</p>
<p>}</p>
<p>return { cur[0],cur[1] };</p>
<p>}</p>
<p>int main(int argc, char** argv) {</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>int cur_size;</p>
<p>string cur_row;</p>
<p>int chips=0;</p>
<p>vector&lt;int&gt; answer;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case) {</p>
<p>cin &gt;&gt; cur_size;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; position;</p>
<p>chips = 0;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = drawTable(cur_size, position,chips);</p>
<p>//printTable(table);</p>
<p>answer = DFS(table, position, chips, 0,0,cur_size-chips, cur_size);</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; answer[1] &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;//정상종료시 반드시 0을 리턴해야합니다.</p>
<p>}</p>
<p>[99. [<strong>695] Max Area of Island] – return a maximum size of island]</strong></p>
<p><strong>-</strong> just use DFS or BFS. Emprically, DFS is faster than BFS.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x, int y,int area){</p>
<p>if(!grid[x][y]) return 0;</p>
<p>grid[x][y]=0;</p>
<p>if(x-1&gt;=0 &amp;&amp; grid[x-1][y]) area+=DFS(grid,x-1,y,0);</p>
<p>if(y-1&gt;=0 &amp;&amp; grid[x][y-1]) area+=DFS(grid,x,y-1,0);</p>
<p>if(x+1&lt;grid.size() &amp;&amp; grid[x+1][y]) area+=DFS(grid,x+1,y,0);</p>
<p>if(y+1&lt;grid[0].size() &amp;&amp; grid[x][y+1]) area+=DFS(grid,x,y+1,0);</p>
<p>return area+1;</p>
<p>}</p>
<p>int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</p>
<p>int answer=0;</p>
<p>int cur;</p>
<p>for(int i=0;i&lt;grid.size();i++){</p>
<p>for(int j=0;j&lt;grid[0].size();j++){</p>
<p>if(grid[i][j]==1){</p>
<p>cur=DFS(grid,i,j,0);</p>
<p>answer=max(answer,cur);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[100. [<strong>46] Permutations – find all the possible permutation]</strong></p>
<p><strong>-</strong> The function next_permutation return true if there is next permutation, and revise given vector to next</p>
<p>permutation. but the function can’t handle negative value.</p>
<p>- So I used DFS. Actually, it’s not such a DFS, but I think it is :).</p>
<p>- Algorithm is below.</p>
<p>&gt; 1. from 0 to nums.size(), input the value into new vector</p>
<p>&gt; 2. remove the value, and repeat from 1.</p>
<p>&gt; 3. if all the value in the given vector nums is removed, push the vector cur into answer vector</p>
<p>- The speed was 61.80% beats.</p>
<p>- see the code.</p>
<p>class Solution {</p>
<p>public:</p>
<p>void dfs(vector&lt;int&gt; nums,vector&lt;vector&lt;int&gt;&gt;&amp; answer,vector&lt;int&gt; cur,int start){</p>
<p>nums.erase(next(nums.begin(),start));</p>
<p>if(nums.size()==0){</p>
<p>answer.push_back(cur);</p>
<p>return;</p>
<p>}</p>
<p>for(int i=0;i&lt;nums.size();i++){</p>
<p>vector&lt;int&gt; temp=cur;</p>
<p>temp.push_back(nums[i]);</p>
<p>dfs(nums,answer,temp,i);</p>
<p>}</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>for(int i=0;i&lt;nums.size();i++){</p>
<p>vector&lt;int&gt; cur;</p>
<p>cur.push_back(nums[i]);</p>
<p>dfs(nums,answer,cur,i);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>};</p>
<p>[101. <strong>[BACKJOON – SAMSUNG SW : Marbles]]</strong></p>
<p>- I spent 6 hours…</p>
<p>- At first, I used DFS but some test case was not solved.</p>
<p>&gt; I think I solved rightly, but my print method might have been wrong…</p>
<p>- So I refered to a blog and used BFS</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; direction = { {0,-1},{0,1},{-1,0},{1,0} };//left right up dwon</p>
<p>int visit[10][10][10][10];</p>
<p>vector&lt;vector&lt;char&gt;&gt; makeTable2(vector&lt;int&gt;&amp; position) {</p>
<p>std::ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case.txt&quot;);</p>
<p>string row;</p>
<p>int N;</p>
<p>int M;</p>
<p>if (in.is_open()) {</p>
<p>in &gt;&gt; N;</p>
<p>in &gt;&gt; M;</p>
<p>}</p>
<p>vector&lt;vector&lt;char&gt;&gt; table(N+2, vector&lt;char&gt;(M+2, '#'));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>in &gt;&gt; row;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (row[j] == 'R') {</p>
<p>position[0] = i;</p>
<p>position[1] = j;</p>
<p>}</p>
<p>if (row[j] == 'B') {</p>
<p>position[2] = i;</p>
<p>position[3] = j;</p>
<p>}</p>
<p>if (row[j] == 'O') {</p>
<p>position[4] = i;</p>
<p>position[5] = j;</p>
<p>}</p>
<p>table[i][j] = row[j];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;char&gt;&gt; makeTable(vector&lt;int&gt;&amp; position) {</p>
<p>string row;</p>
<p>int N;</p>
<p>int M;</p>
<p>cin &gt;&gt; N;</p>
<p>cin &gt;&gt; M;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table(N+2, vector&lt;char&gt;(M+2, '#'));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; row;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (row[j] == 'R') {</p>
<p>position[0] = i;</p>
<p>position[1] = j;</p>
<p>}</p>
<p>if (row[j] == 'B') {</p>
<p>position[2] = i;</p>
<p>position[3] = j;</p>
<p>}</p>
<p>if (row[j] == 'O') {</p>
<p>position[4] = i;</p>
<p>position[5] = j;</p>
<p>}</p>
<p>table[i][j] = row[j];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;char&gt;&gt;&amp; table) {</p>
<p>cout &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : table) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void moveTo(vector&lt;vector&lt;char&gt;&gt;&amp; table,int&amp; x, int&amp; y, int k) {</p>
<p>while (true) {</p>
<p>x += direction[k][0]; y += direction[k][1];</p>
<p>//cout &lt;&lt; &quot; x : &quot; &lt;&lt; x &lt;&lt; &quot; y : &quot; &lt;&lt; y &lt;&lt; endl;</p>
<p>if (table[x][y] == '#') {</p>
<p>x -= direction[k][0]; y -= direction[k][1];</p>
<p>break;</p>
<p>}</p>
<p>else if (table[x][y] == 'O') break;</p>
<p>}</p>
<p>}</p>
<p>int BFS(vector&lt;vector&lt;char&gt;&gt;&amp; table,int a,int b,int c, int d,int e,int f) {</p>
<p>int count=0;</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push({ a,b,c,d,0 });</p>
<p>visit[a][b][c][d] = 1;</p>
<p>while (!que.empty()) {</p>
<p>vector&lt;int&gt; cur = que.front(); que.pop();</p>
<p>a = cur[0]; b = cur[1]; c = cur[2]; d = cur[3]; count = cur[4];</p>
<p>//cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;</p>
<p>if (count &gt; 10) break; // when the depth is over 10</p>
<p>if (a == e &amp;&amp; b == f) return count; // when red ball is placed at th hole.</p>
<p>//ball move</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int rx = a; int ry = b; int bx = c; int by = d;</p>
<p>moveTo(table,rx, ry, i);</p>
<p>moveTo(table,bx, by, i);</p>
<p>if (bx == e &amp;&amp; by == f) continue;</p>
<p>if (rx == bx &amp;&amp; ry == by) { //if they are overlapped.</p>
<p>switch (i){</p>
<p>case 0: //left</p>
<p>b &lt; d ? by++ : ry++;</p>
<p>break;</p>
<p>case 1: //right</p>
<p>d &lt; b ? by-- : ry--;</p>
<p>break;</p>
<p>case 2: //up</p>
<p>a &lt; c ? bx++ : rx++;</p>
<p>break;</p>
<p>case 3: //down</p>
<p>c &lt; a ? bx-- : rx--;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if (!visit[rx][ry][bx][by]) {</p>
<p>//cout &lt;&lt; &quot;input que : &quot; &lt;&lt; rx &lt;&lt; &quot; &quot;&lt;&lt; ry &lt;&lt; &quot; &quot; &lt;&lt; bx &lt;&lt; &quot; &quot; &lt;&lt; by &lt;&lt; endl;</p>
<p>que.push({ rx,ry,bx,by,count + 1 });</p>
<p>visit[rx][ry][bx][by] = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>int answer=-1;</p>
<p>vector&lt;int&gt; position(6,0);</p>
<p>vector&lt;vector&lt;char&gt;&gt; table = makeTable(position);</p>
<p>//vector&lt;vector&lt;char&gt;&gt; table = makeTable2(position);</p>
<p>visit[position[0]][position[1]][position[2]][position[3]] = 1;</p>
<p>//printTable(table);</p>
<p>answer = BFS(table, position[0], position[1], position[2], position[3],position[4],position[5]);</p>
<p>printf(&quot;%d&quot;, answer);</p>
<p>return 0;</p>
<p>}</p>
<p>[102. <strong>[BACKJOON – SAMSUNG SW : 2048]]</strong></p>
<p><strong>-</strong> I used BFS, but BFS is not the matter. move function was the main point.</p>
<p>- I made each direction’s function respectively. so I solved faster than before.</p>
<p>- it took 1 hour and half.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>std::ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_2048.txt&quot;);</p>
<p>int N;</p>
<p>int c;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;test_case is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N,vector&lt;int&gt;(N,0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N;) {</p>
<p>in &gt;&gt; c;</p>
<p>table[i][j++] = c;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N;</p>
<p>int c;</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N,vector&lt;int&gt;(N,0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N;) {</p>
<p>cin &gt;&gt; c;</p>
<p>table[i][j++] = c;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; &amp; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int findMax(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>int maximum = 0;</p>
<p>for (vector&lt;int&gt; row : table)</p>
<p>maximum = max(maximum, *max_element(row.begin(), row.end()));</p>
<p>return maximum;</p>
<p>}</p>
<p>/*</p>
<p>3</p>
<p>2 2 2</p>
<p>4 4 4</p>
<p>8 8 8</p>
<p>*/</p>
<p>// these functions are the main point of this problem.</p>
<p>// move left and right start from column but move up and down start from row.</p>
<p>vector&lt;vector&lt;int&gt;&gt; move_left(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>int cur_val;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(table.size(), vector&lt;int&gt;(table.size(), 0));</p>
<p>for (int col = 1; col &lt; table[0].size(); col++) {</p>
<p>for (int row = 0; row &lt; table.size(); row++) {</p>
<p>cur_val = table[row][col];</p>
<p>if (cur_val == 0) continue;</p>
<p>int j = col-1;</p>
<p>while (table[row][j] == 0 &amp;&amp; j&gt;0) j--; // finding a cell is not value 0.</p>
<p>table[row][col] = 0;</p>
<p>//if they have a same value.</p>
<p>if (table[row][j] == cur_val &amp;&amp; visit[row][j]==0) {</p>
<p>table[row][j] *= 2;</p>
<p>visit[row][j] = 1;</p>
<p>}</p>
<p>//if there is no value to be concerned and the cell is not visited yet.</p>
<p>else if (j==0 &amp;&amp; table[row][j]==0 &amp;&amp; visit[row][j]==0) table[row][0] = cur_val;</p>
<p>//if they have different values or the cell is already visited.</p>
<p>else if (table[row][j] != cur_val || visit[row][j]) table[row][j + 1] = cur_val;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; move_right(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>int cur_val;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(table.size(), vector&lt;int&gt;(table.size(), 0));</p>
<p>for (int col = table[0].size()-2; col&gt;=0; col--) {</p>
<p>for (int row = 0; row &lt; table.size(); row++) {</p>
<p>cur_val = table[row][col];</p>
<p>if (cur_val == 0) continue;</p>
<p>//cout &lt;&lt; &quot; row : &quot; &lt;&lt; row &lt;&lt; &quot; col : &quot; &lt;&lt; col &lt;&lt; &quot; cur_val : &quot; &lt;&lt; cur_val &lt;&lt; endl;</p>
<p>int j = col + 1;</p>
<p>while (table[row][j] == 0 &amp;&amp; j &lt; table[0].size()-1) j++; // finding a cell is not value 0.</p>
<p>table[row][col] = 0;</p>
<p>//if they have a same value.</p>
<p>if (table[row][j] == cur_val &amp;&amp; visit[row][j] == 0) {</p>
<p>table[row][j] *= 2;</p>
<p>visit[row][j] = 1;</p>
<p>}</p>
<p>//if there is no value to be concerned and the cell is not visited yet.</p>
<p>else if (j == table[0].size()-1 &amp;&amp; table[row][j] == 0 &amp;&amp; visit[row][j] == 0) table[row][table[0].size()-1] = cur_val;</p>
<p>//if they have different values or the cell is already visited.</p>
<p>else if (table[row][j] != cur_val || visit[row][j]) table[row][j - 1] = cur_val;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; move_up(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>int cur_val;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(table.size(), vector&lt;int&gt;(table.size(), 0));</p>
<p>for (int row = 1; row&lt;table.size(); row++) {</p>
<p>for (int col=0; col &lt; table[0].size(); col++) {</p>
<p>cur_val = table[row][col];</p>
<p>if (cur_val == 0) continue;</p>
<p>int i = row - 1;</p>
<p>while (table[i][col] == 0 &amp;&amp; i &gt;0) i--; // finding a cell is not value 0.</p>
<p>table[row][col] = 0;</p>
<p>//if they have a same value.</p>
<p>if (table[i][col] == cur_val &amp;&amp; visit[i][col] == 0) {</p>
<p>table[i][col] *= 2;</p>
<p>visit[i][col] = 1;</p>
<p>}</p>
<p>//if there is no value to be concerned and the cell is not visited yet.</p>
<p>else if (i == 0 &amp;&amp; table[i][col] == 0 &amp;&amp; visit[i][col] == 0) table[0][col] = cur_val;</p>
<p>//if they have different values or the cell is already visited.</p>
<p>else if (table[i][col] != cur_val || visit[i][col]) table[i+1][col] = cur_val;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; move_down(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>int cur_val;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(table.size(), vector&lt;int&gt;(table.size(), 0));</p>
<p>for (int row = table.size()-2; row&gt;=0; row--) {</p>
<p>for (int col = 0; col &lt; table[0].size(); col++) {</p>
<p>cur_val = table[row][col];</p>
<p>if (cur_val == 0) continue;</p>
<p>//cout &lt;&lt; &quot; row : &quot; &lt;&lt; row &lt;&lt; &quot; col : &quot; &lt;&lt; col &lt;&lt; &quot; cur_val : &quot; &lt;&lt; cur_val &lt;&lt; endl;</p>
<p>int i = row + 1;</p>
<p>while (table[i][col] == 0 &amp;&amp; i &lt; table.size()-1) i++; // finding a cell is not value 0.</p>
<p>table[row][col] = 0;</p>
<p>//if they have a same value.</p>
<p>if (table[i][col] == cur_val &amp;&amp; visit[i][col] == 0) {</p>
<p>table[i][col] *= 2;</p>
<p>visit[i][col] = 1;</p>
<p>}</p>
<p>//if there is no value to be concerned and the cell is not visited yet.</p>
<p>else if (i == table.size()-1 &amp;&amp; table[i][col] == 0 &amp;&amp; visit[i][col] == 0) table[table.size()-1][col] = cur_val;</p>
<p>//if they have different values or the cell is already visited.</p>
<p>else if (table[i][col] != cur_val || visit[i][col]) table[i - 1][col] = cur_val;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>int BFS(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>queue &lt;pair&lt;vector&lt;vector&lt;int&gt;&gt;,int&gt;&gt; que;</p>
<p>que.push(make_pair(table, 0));</p>
<p>vector&lt;vector&lt;int&gt;&gt; cur_table;</p>
<p>int depth;</p>
<p>int maximum = 0;</p>
<p>while (!que.empty()) {</p>
<p>cur_table = que.front().first;</p>
<p>depth = que.front().second;</p>
<p>que.pop();</p>
<p>//printTable(cur_table);</p>
<p>//cout &lt;&lt;&quot;depth : &quot;&lt;&lt;depth&lt;&lt;endl;</p>
<p>//if the depth is 5, finding the maximum value of it.</p>
<p>if (depth == 5) {</p>
<p>maximum = max(maximum, findMax(cur_table));</p>
<p>continue;</p>
<p>}</p>
<p>//for 4 directions, moving the current table.</p>
<p>que.push(make_pair(move_left(cur_table), depth + 1));</p>
<p>que.push(make_pair(move_right(cur_table), depth + 1));</p>
<p>que.push(make_pair(move_up(cur_table), depth + 1));</p>
<p>que.push(make_pair(move_down(cur_table), depth + 1));</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; table = makeTable();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable2();</p>
<p>//printTable(table);</p>
<p>// cout &lt;&lt; endl;</p>
<p>int answer=BFS(table);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[103. <strong>[BACKJOON – SAMSUNG SW : Snake]]</strong></p>
<p><strong>-</strong> I confused due to apple’s corordinate. they gave the corordiantes strating from row 1 and column 1 not 0 and 0.</p>
<p>- to follow tail, I used queue.</p>
<p>- I spent 1 hour and 10~20 minutes.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;queue&lt;pair&lt;int,char&gt;&gt;,vector&lt;vector&lt;int&gt;&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_snake.txt&quot;);</p>
<p>int N; int K;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; K;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0)); // 0 is empty.</p>
<p>table[0][0] = 2; // 2 is snake's body.</p>
<p>int row, col;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>in &gt;&gt; row; in &gt;&gt; col;</p>
<p>table[row-1][col-1] = 1; // 1 is apple.</p>
<p>}</p>
<p>int L; // the number of direction change.</p>
<p>in &gt;&gt; L;</p>
<p>int sec; char dir;</p>
<p>queue&lt;pair&lt;int, char&gt;&gt; direction;</p>
<p>for (int i = 0; i &lt; L; i++) {</p>
<p>in &gt;&gt; sec; in &gt;&gt; dir;</p>
<p>direction.push({ sec,dir});</p>
<p>}</p>
<p>return make_pair(direction, table);</p>
<p>}</p>
<p>pair&lt;queue&lt;pair&lt;int, char&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; makeTable2() {</p>
<p>int N; int K;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; K;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0)); // 0 is empty.</p>
<p>table[0][0] = 2; // 2 is snake's body.</p>
<p>int row, col;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>cin &gt;&gt; row; cin &gt;&gt; col;</p>
<p>table[row-1][col-1] = 1; // 1 is apple.</p>
<p>}</p>
<p>int L; // the number of direction change.</p>
<p>cin &gt;&gt; L;</p>
<p>int sec; char dir;</p>
<p>queue&lt;pair&lt;int, char&gt;&gt; direction;</p>
<p>for (int i = 0; i &lt; L; i++) {</p>
<p>cin &gt;&gt; sec; cin &gt;&gt; dir;</p>
<p>direction.push({ sec,dir });</p>
<p>}</p>
<p>return make_pair(direction, table);</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int helper(vector&lt;vector&lt;int&gt;&gt;&amp; table, queue&lt;pair&lt;int,char&gt;&gt;&amp; direction) {</p>
<p>int tx = 0, ty = 0;</p>
<p>int hx = 0, hy = 0;</p>
<p>int second = 0;</p>
<p>vector&lt;vector&lt;int&gt;&gt; dir = { {1,0},{0,-1},{-1,0},{0,1} }; // down left up right</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; tail;</p>
<p>tail.push(make_pair(0, 0));</p>
<p>int cur_dir = 3; //start direction</p>
<p>direction.push(make_pair(1000, 'L')); //At last time, snake has to move to a wall.</p>
<p>while (!direction.empty()) {</p>
<p>int cur_sec = direction.front().first;</p>
<p>int continue_sec = cur_sec - second;</p>
<p>char next_dir = direction.front().second;</p>
<p>direction.pop();</p>
<p>for (int i = 0; i &lt; continue_sec; i++) {</p>
<p>second++; // time plused.</p>
<p>hx += dir[cur_dir][0]; hy += dir[cur_dir][1];</p>
<p>tail.push(make_pair(hx, hy));</p>
<p>// if head meets body or wall.</p>
<p>if (hx &lt; 0 || hx &gt;= table.size() || hy &lt; 0 || hy &gt;= table[0].size()||table[hx][hy] == 2 ) return second;</p>
<p>// if head meets an apple.</p>
<p>else if (table[hx][hy] == 1) table[hx][hy] = 2; // notice that even though all the apple is eaten, the game won't be ended.</p>
<p>// if head meets nothing.</p>
<p>else {//tail has to be moved 1 cell.</p>
<p>tx = tail.front().first; ty = tail.front().second;</p>
<p>tail.pop();</p>
<p>table[tx][ty] = 0;</p>
<p>table[hx][hy] = 2;</p>
<p>}</p>
<p>//cout &lt;&lt; &quot;hx : &quot; &lt;&lt; hx &lt;&lt; &quot; hy : &quot; &lt;&lt; hy &lt;&lt; &quot; tx : &quot; &lt;&lt; tx &lt;&lt; &quot; ty : &quot; &lt;&lt; ty &lt;&lt;&quot; second : &quot;&lt;&lt; second&lt;&lt; endl;</p>
<p>//printTable(table);</p>
<p>}</p>
<p>if (next_dir == 'L') { // turn left</p>
<p>cur_dir--;</p>
<p>cur_dir == -1 ? cur_dir = 3 : cur_dir;</p>
<p>}</p>
<p>else cur_dir = (cur_dir + 1) % 4; //turn right</p>
<p>}</p>
<p>return second;</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;queue&lt;pair&lt;int, char&gt;&gt;, vector&lt;vector &lt;int &gt;&gt;&gt; input = makeTable();</p>
<p>pair&lt;queue&lt;pair&lt;int, char&gt;&gt;, vector&lt;vector &lt;int &gt;&gt;&gt; input = makeTable2();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = input.second;</p>
<p>queue&lt;pair&lt;int, char&gt;&gt; direction = input.first;</p>
<p>int answer= helper(table, direction);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[104. <strong>[BACKJOON – SAMSUNG SW : Exam Invigilator]]</strong></p>
<p><strong>-</strong> this exam’s trap is the range of number. since tue maximum number of people is 1,000,000 * 1,000,000 and the minimum number of that an invigilator can handle is 1.</p>
<p>- so we have to use long long (int) for the answer and double for the table having the number of people in a class.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cmath&gt; // for the function ceil</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;double&gt;,int&gt; makeTable() {</p>
<p>std::ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_exam_invigilator.txt&quot;);</p>
<p>int N;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>}</p>
<p>vector&lt;double&gt; table(N, 0);</p>
<p>int people;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>in &gt;&gt; people;</p>
<p>table[i] = people;</p>
<p>}</p>
<p>int B, C;</p>
<p>in &gt;&gt; B; in &gt;&gt; C;</p>
<p>for (int i = 0; i &lt; N; i++) table[i] -= B;</p>
<p>return make_pair(table, C);</p>
<p>}</p>
<p>pair&lt;vector&lt;double&gt;, int&gt; makeTable2() {</p>
<p>int N;</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;double&gt; table(N, 0);</p>
<p>int people;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; people;</p>
<p>table[i] = people;</p>
<p>}</p>
<p>int B, C;</p>
<p>cin &gt;&gt; B; cin &gt;&gt; C;</p>
<p>for (int i = 0; i &lt; N; i++) table[i] -= B;</p>
<p>return make_pair(table, C);</p>
<p>}</p>
<p>void printTable(vector&lt;double&gt; table) {</p>
<p>for (double i : table)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>unsigned long long findMinimum(vector&lt;double&gt; table, int C) {</p>
<p>unsigned long long minimum = table.size();</p>
<p>for (int i = 0; i &lt; table.size(); i++) {</p>
<p>if (table[i] &lt;= 0) continue;</p>
<p>minimum += ceil(table[i] / C);</p>
<p>}</p>
<p>return minimum;</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;vector&lt;float&gt;,int&gt; input = makeTable();</p>
<p>pair&lt;vector&lt;double&gt;, int&gt; input = makeTable2();</p>
<p>vector&lt;double&gt; table = input.first;</p>
<p>int C = input.second;</p>
<p>//printTable(table);</p>
<p>unsigned long long answer=findMinimum(table, C); //since 1,000,000 * 1,000,000 is the maximum number of student and the minimum number of that an invigiltor can handle is 1.</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[105. <strong>[BACKJOON – SAMSUNG SW : Rolling Dice]]</strong></p>
<p>- I spent less than 1 hour. it was not that hard to solve.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,vector&lt;int&gt;&gt; makeTable(int&amp; x, int&amp; y) {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_rolling_dice.txt&quot;);</p>
<p>int N, M, K;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M; in &gt;&gt; x; in &gt;&gt; y; in &gt;&gt; K;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N,vector&lt;int&gt;(M,0));</p>
<p>vector&lt;int&gt; order(K, 0);</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; M; j++) in &gt;&gt; table[i][j];</p>
<p>for (int i = 0; i &lt; K; i++) in &gt;&gt; order[i];</p>
<p>return make_pair(table, order);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;int&gt;&gt; makeTable2(int&amp; x, int&amp; y) {</p>
<p>int N, M, K;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M; cin &gt;&gt; x; cin &gt;&gt; y; cin &gt;&gt; K;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;int&gt; order(K, 0);</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; M; j++) cin &gt;&gt; table[i][j];</p>
<p>for (int i = 0; i &lt; K; i++) cin &gt;&gt; order[i];</p>
<p>return make_pair(table, order);</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>bool moveTheDice(int a, int b,int&amp; x, int&amp; y,int size_x, int size_y){</p>
<p>if (x + a &lt; 0 || x + a &gt;= size_x || y + b &lt; 0 || y + b &gt;= size_y) return false;</p>
<p>x = x + a; y = y + b;</p>
<p>return true;</p>
<p>}</p>
<p>void rollTheDice(vector&lt;vector&lt;int&gt;&gt;&amp; dice,int dir) {</p>
<p>int temp;</p>
<p>switch (dir) {</p>
<p>case 1: // east</p>
<p>temp = dice[1][2]; dice[1][2] = dice[1][1]; dice[1][1] = dice[1][0]; dice[1][0] = dice[3][1]; dice[3][1] = temp;</p>
<p>break;</p>
<p>case 2: // west</p>
<p>temp = dice[1][0]; dice[1][0] = dice[1][1]; dice[1][1] = dice[1][2]; dice[1][2] = dice[3][1]; dice[3][1] = temp;</p>
<p>break;</p>
<p>case 3: // north</p>
<p>temp = dice[0][1]; dice[0][1] = dice[1][1]; dice[1][1] = dice[2][1]; dice[2][1] = dice[3][1]; dice[3][1] = temp;</p>
<p>break;</p>
<p>case 4: // south</p>
<p>temp = dice[3][1]; dice[3][1] = dice[2][1]; dice[2][1] = dice[1][1]; dice[1][1] = dice[0][1]; dice[0][1] = temp;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>void paintTheDice(vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;vector&lt;int&gt;&gt;&amp; dice,int x, int y) {</p>
<p>if (!table[x][y]) {</p>
<p>table[x][y] = dice[3][1]; // dice[3][1] is bottom.</p>
<p>return;</p>
<p>}</p>
<p>dice[3][1] = table[x][y];</p>
<p>table[x][y] = 0;</p>
<p>return;</p>
<p>}</p>
<p>void followingOrder(vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;int&gt; order, vector&lt;vector&lt;int&gt;&gt; dice,int&amp; x,int&amp; y) {</p>
<p>int dir[4][2] = { {0,1},{0,-1},{-1,0},{1,0} }; //east west north south</p>
<p>for (int i = 0; i &lt; order.size(); i++) {</p>
<p>if (!moveTheDice(dir[order[i] - 1][0], dir[order[i] - 1][1], x, y, table.size(), table[0].size())) continue;</p>
<p>//cout &lt;&lt; &quot; x :&quot; &lt;&lt; x &lt;&lt; &quot; y : &quot; &lt;&lt; y &lt;&lt; endl;</p>
<p>rollTheDice(dice,order[i]);</p>
<p>paintTheDice(table,dice,x,y);</p>
<p>cout &lt;&lt; dice[1][1] &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>int x, y;</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;,vector&lt;int&gt;&gt; input = makeTable(x,y);</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;int&gt;&gt; input = makeTable2(x,y);</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = input.first;</p>
<p>vector&lt;int&gt; order = input.second;</p>
<p>vector&lt;vector&lt;int&gt;&gt; dice(4, vector &lt; int&gt;(3,0));</p>
<p>followingOrder(table,order,dice,x,y);</p>
<p>return 0;</p>
<p>}</p>
<p>[106. <strong>[BACKJOON – SAMSUNG SW : Tetromino]]</strong></p>
<p><strong>-</strong> I struggled to implement slinding. I spent 1 hour or so.</p>
<p>- it was a quite dirty problem, since I had to make all the possible tetromino with my own hands.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_tetromino.txt&quot;);</p>
<p>int N, M;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; M; j++) in &gt;&gt; table[i][j];</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N, M;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; M; j++) cin &gt;&gt; table[i][j];</p>
<p>return table;</p>
<p>}</p>
<p>queue&lt;vector&lt;vector&lt;int&gt;&gt;&gt; makeTetromino() {</p>
<p>queue&lt;vector&lt;vector&lt;int&gt;&gt;&gt; que;</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{{1,1,1,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1}, { 1 }, { 1 }, {1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1}, { 1,1 }});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1,0}, { 1,0 }, { 1 ,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {0, 1}, { 0,1 }, {1,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1}, { 1,0 }, { 1,0 }});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1}, { 0,1 }, {0,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1, 1}, { 0,0,1 }});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1, 1}, {1,0,0}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 0, 0}, {1,1,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {0, 0, 1}, {1,1,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 0}, { 1,1 }, {0,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {0, 1}, { 1,1 }, {1,0}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1, 0}, {0,1,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {0, 1, 1}, {1,1,0}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {0, 1, 0}, {1,1,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 1, 1}, {0,1,0}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {0, 1}, { 1,1 }, {0,1}});</p>
<p>que.push(vector&lt;vector&lt;int&gt;&gt;{ {1, 0}, { 1,1 }, {1,0}});</p>
<p>return que;</p>
<p>}</p>
<p>// this function is the key of this problem.</p>
<p>int slideTetro(vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;vector&lt;int&gt;&gt;&amp; tetro) {</p>
<p>int sum = 0;</p>
<p>int maximum = 0;</p>
<p>// we have to get a window.</p>
<p>// window size is tetro.size() X tetro[0].size()</p>
<p>vector&lt;vector&lt;int&gt;&gt; window;</p>
<p>for (int i = 0; i + tetro.size()&lt;= table.size(); i++) {</p>
<p>for (int j = 0; j+tetro[0].size()&lt;=table[0].size(); j++) {</p>
<p>sum = 0;</p>
<p>//from here, the indice are for window.</p>
<p>for (int k = i; k &lt; i + tetro.size(); k++) {</p>
<p>for (int l = j; l &lt; j + tetro[0].size(); l++) {</p>
<p>if (tetro[k-i][l-j]) sum += table[k][l];</p>
<p>}</p>
<p>}</p>
<p>maximum = max(maximum, sum);</p>
<p>}</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>int findMaximum(vector&lt;vector&lt;int&gt;&gt;&amp; table,queue&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; que) {</p>
<p>int maximum = 0;</p>
<p>while (!que.empty()) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; tetro = que.front();</p>
<p>que.pop();</p>
<p>maximum = max(maximum,slideTetro(table,tetro));</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; table = makeTable();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable2();</p>
<p>queue &lt; vector&lt;vector&lt;int&gt;&gt;&gt; que = makeTetromino();</p>
<p>cout&lt;&lt;findMaximum(table, que);</p>
<p>return 0;</p>
<p>}</p>
<p>[107. <strong>[BACKJOON – SAMSUNG SW : Quit The Job]]</strong></p>
<p>- it was dp problem. I made dp from the last day.</p>
<p>- dp[i] has the maximum money we can earn after ith day.</p>
<p>- the point is that where dp[i], we don’t need to choose ith day if it couldn’t make maximum money.</p>
<p>- dp has table.size()+1 memory, since I started table.size()-1 index and it’s possible we can’t consult at the last day.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>std::ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_quit_the_job.txt&quot;);</p>
<p>int N;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(2, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>in &gt;&gt; table[i][0]; in &gt;&gt; table[i][1];</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N;</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(2, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; table[i][0]; cin &gt;&gt; table[i][1];</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int findMaximum(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>int last_day = table.size();</p>
<p>int cur_max = 0;</p>
<p>vector&lt;int&gt; dp(last_day+1, 0); // dp is the maximum money we can earn after ith day. whether choosing ith day or not doesn't matter.</p>
<p>for (int i = last_day - 1; i &gt;= 0; i--) {</p>
<p>// if a consulting continues over the last day, just take dp[i+1]</p>
<p>if (table[i][0] - 1 + i &gt;= last_day) {</p>
<p>dp[i] = dp[i + 1];</p>
<p>continue;</p>
<p>}</p>
<p>// if not, take maximum between current day's money + dp of next possible day and just dp[i+1]</p>
<p>dp[i] = max(table[i][1] + dp[i + table[i][0]], dp[i+1]);</p>
<p>//cout &lt;&lt; &quot;dp[&quot; &lt;&lt; i &lt;&lt; &quot;] : &quot; &lt;&lt; dp[i] &lt;&lt; endl;</p>
<p>}</p>
<p>return dp[0];</p>
<p>}</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; table=makeTable();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable2();</p>
<p>cout &lt;&lt; findMaximum(table);</p>
<p>return 0;</p>
<p>}</p>
<p>[108. <strong>[BACKJOON – SAMSUNG SW : LAB]]</strong></p>
<p>- At first, I tried brute force. But it took so much time so I sholud’ve changed the algorithm</p>
<p>- the brute force algorithm is below.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,queue&lt;vector&lt;int&gt;&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_LAB.txt&quot;);</p>
<p>int N, M;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M;</p>
<p>}</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 2) que.push(vector&lt;int&gt;{ {i, j}});</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table,que);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, queue&lt;vector&lt;int&gt;&gt;&gt; makeTable2() {</p>
<p>int N, M;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M;</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 2) que.push(vector&lt;int&gt;{ {i, j}});</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, que);</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void BFS(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;int&gt; virus) {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(virus);</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1];</p>
<p>que.pop();</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; table[x - 1][y] == 0) {</p>
<p>table[x - 1][y] = 2;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y});</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; table[x][y - 1] == 0) {</p>
<p>table[x][y - 1] = 2;</p>
<p>que.push(vector&lt;int&gt;{ x,y - 1 });</p>
<p>}</p>
<p>if (x + 1 &lt; table.size() &amp;&amp; table[x + 1][y] == 0) {</p>
<p>table[x + 1][y] = 2;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y});</p>
<p>}</p>
<p>if (y + 1 &lt; table.size() &amp;&amp; table[x][y + 1] == 0) {</p>
<p>table[x][y + 1] = 2;</p>
<p>que.push(vector&lt;int&gt;{x, y + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int safetyArea(vector&lt;vector&lt;int&gt;&gt; table,queue&lt;vector&lt;int&gt;&gt; que) {</p>
<p>while (!que.empty()) {</p>
<p>BFS(table, que.front());</p>
<p>que.pop();</p>
<p>}</p>
<p>int sum = 0;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>i == 0 ? sum++ : 0;</p>
<p>}</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt; table,queue&lt;vector&lt;int&gt;&gt; que,int depth) {</p>
<p>if (depth == 3) {</p>
<p>return safetyArea(table,que);</p>
<p>}</p>
<p>int maximum = 0;</p>
<p>for (int i = 0; i &lt; table.size(); i++) {</p>
<p>for (int j = 0; j &lt; table[0].size(); j++) {</p>
<p>if (table[i][j] != 0) continue;</p>
<p>table[i][j] = 1;</p>
<p>maximum=max(maximum,DFS(table, que, depth + 1));</p>
<p>table[i][j] = 0;</p>
<p>}</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>int main() {</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,queue&lt;vector&lt;int&gt;&gt;&gt; input = makeTable();</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;, queue&lt;vector&lt;int&gt;&gt;&gt; input = makeTable2();</p>
<p>cout &lt;&lt; DFS(input.first,input.second,0);</p>
<p>return 0;</p>
<p>}</p>
<p>- Now, I have to find another solution.</p>
<p>- But most people solve this problem as brute force. so I changed DFS to BFS.</p>
<p>- I have no idea why it’s wrong! at 11%, failure occurs.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,queue&lt;vector&lt;int&gt;&gt;&gt; makeTable(vector&lt;vector&lt;int&gt;&gt;&amp; empty) {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_LAB.txt&quot;);</p>
<p>int N, M;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M;</p>
<p>}</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 2) que.push(vector&lt;int&gt;{ {i, j}});</p>
<p>else if (table[i][j] == 0) empty.push_back({i,j});</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table,que);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, queue&lt;vector&lt;int&gt;&gt;&gt; makeTable2(vector&lt;vector&lt;int&gt;&gt; &amp; empty) {</p>
<p>int N, M;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M;</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 2) que.push(vector&lt;int&gt;{ {i, j}});</p>
<p>else if (table[i][j] == 0) empty.push_back({ i,j });</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, que);</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int safetyArea(vector&lt;vector&lt;int&gt;&gt; &amp; table) {</p>
<p>int sum = 0;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>if (i == 0) sum++;</p>
<p>}</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>int contagion(vector&lt;vector&lt;int&gt;&gt; table,queue&lt;vector&lt;int&gt;&gt; que) {</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1];</p>
<p>que.pop();</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; table[x - 1][y] == 0) {</p>
<p>table[x - 1][y] = 2;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y});</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; table[x][y - 1] == 0) {</p>
<p>table[x][y - 1] = 2;</p>
<p>que.push(vector&lt;int&gt;{ x,y - 1 });</p>
<p>}</p>
<p>if (x + 1 &lt; table.size() &amp;&amp; table[x + 1][y] == 0) {</p>
<p>table[x + 1][y] = 2;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y});</p>
<p>}</p>
<p>if (y + 1 &lt; table.size() &amp;&amp; table[x][y + 1] == 0) {</p>
<p>table[x][y + 1] = 2;</p>
<p>que.push(vector&lt;int&gt;{x, y + 1});</p>
<p>}</p>
<p>}</p>
<p>return safetyArea(table);</p>
<p>}</p>
<p>int BFS(vector&lt;vector&lt;int&gt;&gt; table, queue&lt;vector&lt;int&gt;&gt; que, vector&lt;vector&lt;int&gt;&gt; empty) {</p>
<p>int maximum = 0;</p>
<p>int depth = 0;</p>
<p>for (int i = 0; i &lt; empty.size()-2; i++) {</p>
<p>table[empty[i][0]][empty[i][1]] = 3;</p>
<p>for (int j = i+1; j &lt; empty.size()-1; j++) {</p>
<p>table[empty[j][0]][empty[j][1]] = 3;</p>
<p>for (int k = j+1; k &lt; empty.size(); k++) {</p>
<p>table[empty[k][0]][empty[k][1]] = 3;</p>
<p>maximum=max(maximum,contagion(table, que));</p>
<p>table[empty[k][0]][empty[k][1]] = 0;</p>
<p>}</p>
<p>table[empty[j][0]][empty[j][1]] = 0;</p>
<p>}</p>
<p>table[empty[i][0]][empty[i][1]] = 0;</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>int main() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; empty;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,queue&lt;vector&lt;int&gt;&gt;&gt; input = makeTable(empty);</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;, queue&lt;vector&lt;int&gt;&gt;&gt; input = makeTable2(empty);</p>
<p>//printTable(input.first);</p>
<p>cout &lt;&lt; BFS(input.first, input.second, empty);</p>
<p>return 0;</p>
<p>}</p>
<p>- Finally, I found the error.</p>
<p>- when I compare the range in the function contagion. I compare y index with table.size() not table[0].size().</p>
<p>- due to [0], I took almost 3 hours. what the fxxk!</p>
<p>- see the final code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; makeTable(vector&lt;vector&lt;int&gt;&gt;&amp; empty, queue&lt;vector&lt;int&gt;&gt;&amp; que) {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_LAB.txt&quot;);</p>
<p>int N, M;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M;</p>
<p>}</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(N, vector&lt;int&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 2) {</p>
<p>que.push(vector&lt;int&gt;{ {i, j}});</p>
<p>//visit[i][j] = 1;</p>
<p>}</p>
<p>else if (table[i][j] == 0) empty.push_back({i,j});</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, visit);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; makeTable2(vector&lt;vector&lt;int&gt;&gt; &amp; empty, queue&lt;vector&lt;int&gt;&gt;&amp; que) {</p>
<p>int N, M;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M;</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(N, vector&lt;int&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 2) {</p>
<p>que.push(vector&lt;int&gt;{ {i, j}});</p>
<p>//visit[i][j] = 1;</p>
<p>}</p>
<p>else if (table[i][j] == 0) empty.push_back({ i,j });</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, visit);</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int safetyArea(vector&lt;vector&lt;int&gt;&gt; &amp; table) {</p>
<p>int sum = 0;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>if (i == 0) sum++;</p>
<p>}</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>int contagion(vector&lt;vector&lt;int&gt;&gt; table,queue&lt;vector&lt;int&gt;&gt; que, vector&lt;vector&lt;int&gt;&gt; visit) {</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1];</p>
<p>que.pop();</p>
<p>if (visit[x][y] == 1) continue;</p>
<p>visit[x][y] = 1;</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; table[x - 1][y] == 0) {</p>
<p>table[x - 1][y] = 2;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y});</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; table[x][y - 1] == 0) {</p>
<p>table[x][y - 1] = 2;</p>
<p>que.push(vector&lt;int&gt;{ x,y - 1 });</p>
<p>}</p>
<p>if (x + 1 &lt; table.size() &amp;&amp; table[x + 1][y] == 0) {</p>
<p>table[x + 1][y] = 2;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y});</p>
<p>}</p>
<p>if (y + 1 &lt; table[0].size() &amp;&amp; table[x][y + 1] == 0) {</p>
<p>table[x][y + 1] = 2;</p>
<p>que.push(vector&lt;int&gt;{x, y + 1});</p>
<p>}</p>
<p>}</p>
<p>return safetyArea(table);</p>
<p>}</p>
<p>int BFS(vector&lt;vector&lt;int&gt;&gt; table, queue&lt;vector&lt;int&gt;&gt; que, vector&lt;vector&lt;int&gt;&gt; empty,vector&lt;vector&lt;int&gt;&gt; visit) {</p>
<p>int maximum = 0;</p>
<p>int depth = 0;</p>
<p>for (int i = 0; i &lt; empty.size()-2; i++) {</p>
<p>table[empty[i][0]][empty[i][1]] = 3;</p>
<p>for (int j = i+1; j &lt; empty.size()-1; j++) {</p>
<p>table[empty[j][0]][empty[j][1]] = 3;</p>
<p>for (int k = j+1; k &lt; empty.size(); k++) {</p>
<p>table[empty[k][0]][empty[k][1]] = 3;</p>
<p>maximum=max(maximum,contagion(table, que,visit));</p>
<p>table[empty[k][0]][empty[k][1]] = 0;</p>
<p>}</p>
<p>table[empty[j][0]][empty[j][1]] = 0;</p>
<p>}</p>
<p>table[empty[i][0]][empty[i][1]] = 0;</p>
<p>}</p>
<p>return maximum;</p>
<p>}</p>
<p>int main() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; empty;</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;,vector&lt;vector&lt;int&gt;&gt;&gt; input = makeTable(empty,que);</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; input = makeTable2(empty,que);</p>
<p>//printTable(input.first);</p>
<p>cout &lt;&lt; BFS(input.first, que, empty,input.second);</p>
<p>return 0;</p>
<p>}</p>
<p>[109. <strong>[BACKJOON – SAMSUNG SW : Robot Vacuum Cleaner]]</strong></p>
<p>- this problem’s hardest point was to determine when cleaning is end.</p>
<p>- without it, not that hard, just followed given rules.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,vector&lt;int&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_robot_vacuum_cleaner.txt&quot;);</p>
<p>int N, M;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;int&gt; pos(3, 0);</p>
<p>for (int i = 0; i &lt; 3; i++) in &gt;&gt; pos[i];</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table,pos);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N, M;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;int&gt; pos(3, 0);</p>
<p>for (int i = 0; i &lt; 3; i++) cin &gt;&gt; pos[i];</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, pos);</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int is_end(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;int&gt;&amp; pos) {</p>
<p>int x = pos[0]; int y = pos[1];</p>
<p>vector&lt;vector&lt;int&gt;&gt; dir = { {1,0},{0,-1},{-1,0},{0,1} }; //reverse of north east south west</p>
<p>if ((x - 1 &lt; 0 || table[x - 1][y])&amp;&amp; (y - 1 &lt; 0 || table[x][y - 1])&amp;&amp; (x + 1 &gt;= table.size() || table[x + 1][y])&amp;&amp; (y + 1 &gt;= table[0].size() || table[x][y + 1])) {</p>
<p>int cx = x + dir[pos[2]][0]; int cy = y + dir[pos[2]][1];</p>
<p>if ((cx&lt;0 || cx &gt;= table.size() || cy &lt; 0 || cy &gt;= table[0].size() || table[cx][cy]==1)) return 1;</p>
<p>return 2;</p>
<p>}</p>
<p>return 3;</p>
<p>}</p>
<p>int cleaning(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;int&gt;&amp; pos,int count) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; dir = { {-1,0},{0,1},{1,0},{0,-1} }; // north east south west</p>
<p>vector&lt;vector&lt;int&gt;&gt; back= { {1,0},{0,-1},{-1,0},{0,1} }; // reverse of north east south west</p>
<p>int x = pos[0]; int y = pos[1]; int head = pos[2];</p>
<p>if (table[x][y] == 0) {</p>
<p>count++;</p>
<p>table[x][y] = 2;</p>
<p>}</p>
<p>int end = is_end(table, pos);</p>
<p>if (end == 1) return count; //when cleaning is end.</p>
<p>else if (end == 2) { //when vacuum moves backward.</p>
<p>pos[0] = x + back[pos[2]][0]; pos[1] = y + back[pos[2]][1];</p>
<p>return cleaning(table, pos, count);</p>
<p>}</p>
<p>int left=head;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>left - 1 &lt; 0 ? left = 3 : left--;</p>
<p>int cx = x + dir[left][0]; int cy = y + dir[left][1];</p>
<p>if (cx&gt;=0 &amp;&amp; cx&lt;table.size() &amp;&amp; cy&gt;=0 &amp;&amp; cy&lt;table[0].size() &amp;&amp; table[cx][cy]==0) {</p>
<p>pos[0] = cx; pos[1] = cy; pos[2] = left;</p>
<p>return cleaning(table, pos, count);</p>
<p>}</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;,vector&lt;int&gt;&gt; input = makeTable();</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;int&gt;&gt; input = makeTable2();</p>
<p>cout &lt;&lt; cleaning(input.first, input.second,0);</p>
<p>return 0;</p>
<p>}</p>
<p>[110. <strong>[BACKJOON – SAMSUNG SW : Insert Operator]]</strong></p>
<p>- by using next_permutation, we can solve this problem very easily.</p>
<p>- but there was a trap, the function next_permutation ant in ascending order.</p>
<p>- so we have to insert our operators in following order *,+,-,/.</p>
<p>- cf.) ascii number of each operator is that * : 42, + : 43, - : 45, / : 47.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_insert_operator.txt&quot;);</p>
<p>int N;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>}</p>
<p>vector&lt;int&gt; table(N, 0);</p>
<p>vector&lt;int&gt; oper(4, 0);</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>in &gt;&gt; table[i];</p>
<p>for (int i = 0; i &lt; 4; i++)</p>
<p>in &gt;&gt; oper[i];</p>
<p>return make_pair(table, oper);</p>
<p>}</p>
<p>pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N;</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;int&gt; table(N, 0);</p>
<p>vector&lt;int&gt; oper(4, 0);</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>cin &gt;&gt; table[i];</p>
<p>for (int i = 0; i &lt; 4; i++)</p>
<p>cin &gt;&gt; oper[i];</p>
<p>return make_pair(table, oper);</p>
<p>}</p>
<p>int calculate(vector&lt;int&gt;&amp; table, vector&lt;char&gt; oper) {</p>
<p>int result = table[0];</p>
<p>for (int i = 0; i &lt; oper.size(); i++) {</p>
<p>if (oper[i] == '+') {</p>
<p>result += table[i + 1];</p>
<p>}</p>
<p>else if (oper[i] == '-') {</p>
<p>result -= table[i + 1];</p>
<p>}</p>
<p>else if (oper[i] == '*') {</p>
<p>result *= table[i + 1];</p>
<p>}</p>
<p>else if (oper[i] == '/') {</p>
<p>result /= table[i + 1];</p>
<p>}</p>
<p>}</p>
<p>return result;</p>
<p>}</p>
<p>pair&lt;int,int&gt; insertOperator(vector&lt;int&gt;&amp; table, vector&lt;int&gt;&amp; oper) {</p>
<p>vector&lt;char&gt; opers;</p>
<p>// to use next_permutation operators have to be inserted with following order : * + - /</p>
<p>//since next_permutation act as ascending order.</p>
<p>// c.f ) ascii number of operands are 42, 43, 45, 47 in order.</p>
<p>for (int i = 0; i &lt; oper[2]; i++) opers.push_back('*');</p>
<p>for (int i = 0; i &lt; oper[0]; i++) opers.push_back('+');</p>
<p>for (int i = 0; i &lt; oper[1]; i++) opers.push_back('-');</p>
<p>for (int i = 0; i &lt; oper[3]; i++) opers.push_back('/');</p>
<p>int minimum = INT_MAX;</p>
<p>int maximum = INT_MIN;</p>
<p>int cur_value;</p>
<p>do {</p>
<p>cur_value = calculate(table, opers);</p>
<p>minimum = min(minimum, cur_value);</p>
<p>maximum = max(maximum, cur_value);</p>
<p>} while (next_permutation(opers.begin(), opers.end()));</p>
<p>return make_pair(maximum, minimum);</p>
<p>}</p>
<p>void printTable(vector&lt;int&gt;&amp; table, vector&lt;int&gt;&amp; oper) {</p>
<p>for (int i : table)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>for (int i : oper)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; input = makeTable();</p>
<p>pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; input = makeTable2();</p>
<p>pair&lt;int,int&gt; answer= insertOperator(input.first,input.second);</p>
<p>cout &lt;&lt; answer.first &lt;&lt; endl &lt;&lt; answer.second &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>[111. <strong>[BACKJOON – SAMSUNG SW : Start and Link]]</strong></p>
<p>- at first, I solved using next_permuation but time limit exceeded occurred.</p>
<p>- so I changed the algorithm to DFS, but it was same.</p>
<p>- code below is DFS.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>unordered_map&lt;string, int&gt; visit;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_start_and_link.txt&quot;);</p>
<p>int N;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N;</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void printTeam(vector&lt;int&gt;&amp; team) {</p>
<p>for (int i : team)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int statDifference(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;int&gt;&amp; red,vector&lt;int&gt;&amp; blue,int middle,string reds) {</p>
<p>int red_sum = 0; int blue_sum = 0;</p>
<p>string blues;</p>
<p>for (int i : blue)</p>
<p>blues += i+ '0';</p>
<p>if (visit[blues]) {</p>
<p>return INT_MAX;</p>
<p>}</p>
<p>visit[reds] = 1;</p>
<p>for (int i = 0; i &lt; middle; i++) {</p>
<p>for (int j = 0; j &lt; middle; j++) {</p>
<p>red_sum += table[red[i]-1][red[j]-1];</p>
<p>blue_sum += table[blue[i]-1][blue[j]-1];</p>
<p>}</p>
<p>}</p>
<p>return abs(red_sum - blue_sum);</p>
<p>}</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;int&gt; red, vector&lt;int&gt; blue,int middle,string reds) {</p>
<p>if (red.size() == middle) return statDifference(table,red,blue,middle,reds);</p>
<p>int minimum = INT_MAX;</p>
<p>for (int i = 0; i &lt; blue.size(); i++) {</p>
<p>vector&lt;int&gt; red_temp = red;</p>
<p>vector&lt;int&gt; blue_temp = blue;</p>
<p>red_temp.push_back(blue[i]);</p>
<p>reds += blue[i] + '0';</p>
<p>blue_temp.erase(next(blue_temp.begin(), i));</p>
<p>minimum=min(minimum,DFS(table, red_temp, blue_temp, middle,reds));</p>
<p>}</p>
<p>return minimum;</p>
<p>}</p>
<p>// 1 2 3 4 5 6</p>
<p>//1 2 4</p>
<p>// 3 5 6</p>
<p>int makeTeam(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>vector&lt;int&gt; member;</p>
<p>int minimum = INT_MAX;</p>
<p>int middle = table.size() / 2;</p>
<p>for (int i = 0; i &lt; table.size(); i++)</p>
<p>member.push_back(i + 1);</p>
<p>return DFS(table, {}, member, middle,&quot;&quot;);</p>
<p>}</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; table = makeTable();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable2();</p>
<p>cout&lt;&lt;makeTeam(table);</p>
<p>return 0;</p>
<p>}</p>
<p>- I should’ve revised the code.</p>
<p>- At first, we don’t need to check all the possible red team.</p>
<p>- Since if red team has player 1,2, and 3, then blue must have 4,5, and 6.</p>
<p>- And instead of moving a player from one to another, just select players to be red team.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_start_and_link.txt&quot;);</p>
<p>int N;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>int N;</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void printTeam(vector&lt;int&gt;&amp; team) {</p>
<p>for (int i : team)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int statDifference(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;bool&gt;&amp; visit, int middle) {</p>
<p>vector&lt;int&gt; red; vector&lt;int&gt; blue;</p>
<p>//In here, make team</p>
<p>for (int i = 0; i &lt; visit.size(); i++) {</p>
<p>visit[i] ? red.push_back(i) : blue.push_back(i);</p>
<p>}</p>
<p>int red_sum = 0; int blue_sum = 0;</p>
<p>for (int i = 0; i &lt; red.size(); i++) {</p>
<p>for (int j = 0; j &lt; red.size(); j++) {</p>
<p>red_sum += table[red[i]][red[j]];</p>
<p>blue_sum += table[blue[i]][blue[j]];</p>
<p>}</p>
<p>}</p>
<p>return abs(red_sum - blue_sum);</p>
<p>}</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;bool&gt; visit,int count,int middle,int next) {</p>
<p>if (count == middle) return statDifference(table,visit,middle);</p>
<p>int minimum = INT_MAX;</p>
<p>// instead of making red and blue vectors and moving player one to another, just select players to be red team.</p>
<p>for (int i = next; i &lt; visit.size(); i++) {</p>
<p>visit[i] = true;</p>
<p>minimum=min(minimum,DFS(table, visit, count + 1, middle,i+1));</p>
<p>visit[i] = false;</p>
<p>}</p>
<p>return minimum;</p>
<p>}</p>
<p>int makeTeam(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>vector&lt;int&gt; member;</p>
<p>vector&lt;bool&gt; visit(table.size(),false);</p>
<p>int minimum = INT_MAX;</p>
<p>int middle = table.size() / 2;</p>
<p>// we don't neet to check all the possible red team</p>
<p>// since if red choose 1,2,3, blue must choose 4,5,6 and vice verse.</p>
<p>// that is the case of that red choose 4,5,6 isn't needed.</p>
<p>for (int i = 0; i &lt; middle; i++) {</p>
<p>visit[i] = true;</p>
<p>minimum = min(minimum, DFS(table, visit, 1, middle, i + 1));</p>
<p>visit[i] = false;</p>
<p>}</p>
<p>return minimum;</p>
<p>}</p>
<p>//1 2 3 4 5 6</p>
<p>//6 5 4 3 2 1</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; table = makeTable();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable2();</p>
<p>cout &lt;&lt; makeTeam(table);</p>
<p>return 0;</p>
<p>}</p>
<p>[112. <strong>[BACKJOON – SAMSUNG SW : Ramp]]</strong></p>
<p>- there was lots of error in this problem. I mean the errors the problem has.</p>
<p>- this problem didn’t describe exactly. Even having wrong information.</p>
<p>- I made an algorithm including all the possible case but I didn’t need to actually.</p>
<p>- However, i didn’t want to spent much time to revise for this problem. I just submited my answer and got marked.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,int&gt; makeTable(){</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_ramp.txt&quot;);</p>
<p>int N; int L;</p>
<p>if (in.is_open()) {</p>
<p>cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; L;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; N; j++)</p>
<p>in &gt;&gt; table[i][j];</p>
<p>return make_pair(table,L);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt; makeTable2() {</p>
<p>int N; int L;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; L;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; N; j++)</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>return make_pair(table, L);</p>
<p>}</p>
<p>// we have to consider row first and column first search.</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,int&gt; rowSearch(vector&lt;vector&lt;int&gt;&gt; table,int L, vector&lt;vector&lt;int&gt;&gt; visit,int count) {</p>
<p>int n = table.size();</p>
<p>vector&lt;int&gt; path;</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>int cur_height = table[i][0];</p>
<p>int length = 1;</p>
<p>bool flag = false;</p>
<p>for (int j = 1; j &lt; n; j++) {</p>
<p>if (table[i][j] == cur_height + 1) { // higher</p>
<p>if (length &gt;= L) {</p>
<p>for (int s = 0; s &lt; L; s++) if (visit[i][j - 1 - s] == 1) { flag = true; break; }</p>
<p>if (flag) break;</p>
<p>if (j == n - 1) { count++; path.push_back(i); break; }</p>
<p>for (int s = 0; s &lt; L; s++) visit[i][j - 1 - s] = 1;</p>
<p>length = 1; cur_height++;</p>
<p>continue;</p>
<p>}</p>
<p>else break;</p>
<p>}</p>
<p>else if (table[i][j] == cur_height) { // same height</p>
<p>if (j == n - 1) { count++; path.push_back(i); break; }</p>
<p>length++;</p>
<p>continue;</p>
<p>}</p>
<p>else if (table[i][j]==cur_height-1) { // lower</p>
<p>if (n - j &lt; L) break;</p>
<p>for (int s = j; s &lt; j + L; s++) if ( visit[i][s] == 1 || table[i][s]!=cur_height-1) { flag = true; break; }</p>
<p>if (flag) break;</p>
<p>for (int s = j; s &lt; j + L; s++) visit[i][s] = 1;</p>
<p>j += L - 1;</p>
<p>if (j == n - 1) { count++; path.push_back(i); break; }</p>
<p>length = L;</p>
<p>cur_height--;</p>
<p>}</p>
<p>else break;</p>
<p>}</p>
<p>}</p>
<p>return make_pair(visit, count);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt; colSearch(vector&lt;vector&lt;int&gt;&gt; table,int L,vector&lt;vector&lt;int&gt;&gt; visit,int count) {</p>
<p>int n = table.size();</p>
<p>vector&lt;int&gt; path;</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>int cur_height = table[0][j];</p>
<p>int length = 1;</p>
<p>bool flag = false;</p>
<p>for (int i = 1; i &lt; n; i++) {</p>
<p>if (table[i][j] == cur_height + 1) { // higher</p>
<p>if (length &gt;= L) {</p>
<p>for (int s = 0; s &lt; L; s++) if (visit[i - 1 - s][j] == 1) { flag = true; break; }</p>
<p>if (flag) break;</p>
<p>if (i == n - 1) { count++; path.push_back(j); break; }</p>
<p>for (int s = 0; s &lt; L; s++) visit[i - 1 - s][j] = 1;</p>
<p>length = 1; cur_height++;</p>
<p>continue;</p>
<p>}</p>
<p>else break;</p>
<p>}</p>
<p>else if (table[i][j] == cur_height) { // same height</p>
<p>if (i == n - 1) { count++; path.push_back(j); break; }</p>
<p>length++;</p>
<p>continue;</p>
<p>}</p>
<p>else if (table[i][j] == cur_height - 1) { // lower</p>
<p>if (n - i &lt; L) break;</p>
<p>for (int s = i; s &lt; i + L; s++) if (visit[s][j] == 1|| table[s][j] != cur_height - 1) { flag = true; break; }</p>
<p>if (flag) break;</p>
<p>for (int s = i; s &lt; i + L; s++) visit[s][j] = 1;</p>
<p>i += L - 1;</p>
<p>if (i == n - 1) { count++; path.push_back(j); break; }</p>
<p>length = L;</p>
<p>cur_height--;</p>
<p>}</p>
<p>else break;</p>
<p>}</p>
<p>}</p>
<p>return make_pair(visit, count);</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt; input = makeTable();</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt; input = makeTable2();</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(input.first.size(), vector&lt;int&gt;(input.first.size(), 0));</p>
<p>pair &lt; vector&lt;vector&lt;int&gt;&gt;, int&gt; row_first = rowSearch(input.first, input.second, visit, 0);</p>
<p>row_first = colSearch(input.first, input.second, visit, row_first.second);</p>
<p>cout&lt;&lt;row_first.second;</p>
<p>return 0;</p>
<p>}</p>
<p>[113. <strong>[BACKJOON – SAMSUNG SW : Gears ]]</strong></p>
<p>- I think there are at least 2 method to solve this problem. one is DFS and another one is just to use many if-condintion clause.</p>
<p>- I chose the latter one.</p>
<p>- the trap was that before rotate a gear, we have to check the next gear will be rotated or not.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;,vector&lt;vector&lt;int&gt;&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_gears.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(4,vector&lt;int&gt;(8,0));</p>
<p>string row;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>in &gt;&gt; row;</p>
<p>for (int j = 0; j &lt; row.length(); j++) {</p>
<p>table[i][j] = row[j]-'0';</p>
<p>}</p>
<p>}</p>
<p>int K;</p>
<p>in &gt;&gt; K;</p>
<p>int a; int b;</p>
<p>vector&lt;vector&lt;int&gt;&gt; rotate(K,vector&lt;int&gt;(2,0));</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>in &gt;&gt; a; in &gt;&gt; b;</p>
<p>rotate[i][0] = a; rotate[i][1] = b;</p>
<p>}</p>
<p>return make_pair(table, rotate);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; makeTable2() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(4, vector&lt;int&gt;(8, 0));</p>
<p>string row;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>cin &gt;&gt; row;</p>
<p>for (int j = 0; j &lt; row.length(); j++) {</p>
<p>table[i][j] = row[j] - '0';</p>
<p>}</p>
<p>}</p>
<p>int K;</p>
<p>cin &gt;&gt; K;</p>
<p>int a; int b;</p>
<p>vector&lt;vector&lt;int&gt;&gt; rotate(K, vector&lt;int&gt;(2, 0));</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>cin &gt;&gt; a; cin &gt;&gt; b;</p>
<p>rotate[i][0] = a; rotate[i][1] = b;</p>
<p>}</p>
<p>return make_pair(table, rotate);</p>
<p>}</p>
<p>vector&lt;int&gt; move(vector&lt;int&gt; gear, int dir) {</p>
<p>if (dir == 1) {</p>
<p>int temp = gear[7];</p>
<p>for (int i = gear.size() - 2; i &gt;= 0; i--)</p>
<p>gear[i + 1] = gear[i];</p>
<p>gear[0] = temp;</p>
<p>return gear;</p>
<p>}</p>
<p>else {</p>
<p>int temp = gear[0];</p>
<p>for (int i = 0; i &lt; gear.size() - 1; i++)</p>
<p>gear[i] = gear[i + 1];</p>
<p>gear[7] = temp;</p>
<p>return gear;</p>
<p>}</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; gears) {</p>
<p>for (vector&lt;int&gt; row : gears) {</p>
<p>for (int i : row)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int tonado(vector&lt;vector&lt;int&gt;&gt; gears,vector&lt;vector&lt;int&gt;&gt; rotate) {</p>
<p>// 2 is east, 6 is west.</p>
<p>int cur_gear; int dir;</p>
<p>for (int i = 0; i &lt; rotate.size(); i++) {</p>
<p>cur_gear = rotate[i][0]-1; dir = rotate[i][1];</p>
<p>gears[cur_gear] = move(gears[cur_gear], dir);</p>
<p>int temp_dir = dir;</p>
<p>//to left</p>
<p>for (int left = cur_gear - 1; left &gt;= 0; left--) {</p>
<p>if (temp_dir == 1 &amp;&amp; gears[left+1][7]!=gears[left][2]) gears[left] = move(gears[left], temp_dir=-1);</p>
<p>else if(temp_dir==-1 &amp;&amp; gears[left+1][5]!=gears[left][2]) gears[left] = move(gears[left], temp_dir=1);</p>
<p>else break;</p>
<p>}</p>
<p>//to right</p>
<p>temp_dir = dir;</p>
<p>for (int right = cur_gear + 1; right &lt; gears.size(); right++) {</p>
<p>if(temp_dir==1 &amp;&amp; gears[right-1][3]!=gears[right][6]) gears[right] = move(gears[right], temp_dir=-1);</p>
<p>else if (temp_dir ==-1 &amp;&amp; gears[right - 1][1] != gears[right][6]) gears[right] = move(gears[right], temp_dir = 1);</p>
<p>else break;</p>
<p>}</p>
<p>}</p>
<p>return gears[0][0] + gears[1][0] * 2 + gears[2][0] * 4 + gears[3][0] * 8;</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; input = makeTable();</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; input = makeTable2();</p>
<p>vector&lt;vector&lt;int&gt;&gt; gears = input.first;</p>
<p>vector&lt;vector&lt;int&gt;&gt; rotate = input.second;</p>
<p>cout &lt;&lt; tonado(gears, rotate);</p>
<p>return 0;</p>
<p>}</p>
<p>[114. <strong>[BACKJOON – SAMSUNG SW : Monitoring ]]</strong></p>
<p>- just following rules, removing blind spot is the main point of this problem.</p>
<p>- DFS is needed.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_monitoring.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>int N; int M;</p>
<p>in &gt;&gt; N; in &gt;&gt; M;</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;vector&lt;int&gt;&gt; camera;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>in &gt;&gt; temp;</p>
<p>if (1 &lt;= temp &amp;&amp; temp &lt;= 5) camera.push_back({ i,j,temp });</p>
<p>table[i][j] = temp;</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, camera);</p>
<p>}</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; makeTable2() {</p>
<p>int N; int M;</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M;</p>
<p>int temp;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>vector&lt;vector&lt;int&gt;&gt; camera;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; temp;</p>
<p>if (1 &lt;= temp &amp;&amp; temp &lt;= 5) camera.push_back({ i,j,temp });</p>
<p>table[i][j] = temp;</p>
<p>}</p>
<p>}</p>
<p>return make_pair(table, camera);</p>
<p>}</p>
<p>int blindSpot(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>int spot = 0;</p>
<p>for (vector&lt;int&gt; row : table)</p>
<p>for (int i : row)</p>
<p>if (i == 0) spot++;</p>
<p>return spot;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; East(vector&lt;vector&lt;int&gt;&gt; table, int x, int y) {</p>
<p>for (int j = y; j &lt; table[0].size(); j++) {</p>
<p>if (table[x][j] == 6) break;</p>
<p>if (table[x][j] == 0) table[x][j] = 9; // 9 is where we can monitor.</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; West(vector&lt;vector&lt;int&gt;&gt; table, int x, int y) {</p>
<p>for (int j = y; j &gt;= 0; j--) {</p>
<p>if (table[x][j] == 6) break;</p>
<p>if (table[x][j] == 0) table[x][j] = 9; // 9 is where we can monitor.</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; South(vector&lt;vector&lt;int&gt;&gt; table, int x, int y) {</p>
<p>for (int i = x; i &gt;= 0; i--) {</p>
<p>if (table[i][y] == 6) break;</p>
<p>if (table[i][y] == 0) table[i][y] = 9; // 9 is where we can monitor.</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; North(vector&lt;vector&lt;int&gt;&gt; table, int x, int y) {</p>
<p>for (int i = x; i &lt; table.size(); i++) {</p>
<p>if (table[i][y] == 6) break;</p>
<p>if (table[i][y] == 0) table[i][y] = 9; // 9 is where we can monitor.</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; Monitoring(vector&lt;vector&lt;int&gt;&gt; table,int x, int y, int dir) {</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; res_table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp_table;</p>
<p>switch (dir) {</p>
<p>case 1:</p>
<p>// East</p>
<p>res_table.push_back(East(table, x, y));</p>
<p>// West</p>
<p>res_table.push_back(West(table, x, y));</p>
<p>// North</p>
<p>res_table.push_back(North(table, x, y));</p>
<p>// South</p>
<p>res_table.push_back(South(table, x, y));</p>
<p>return res_table;</p>
<p>case 2:</p>
<p>//horizontal</p>
<p>temp_table = table;</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>//vertical</p>
<p>temp_table = table;</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>return res_table;</p>
<p>case 3 :</p>
<p>// North East</p>
<p>temp_table = table;</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>// South East</p>
<p>temp_table = table;</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>// North West</p>
<p>temp_table = table;</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>// South West</p>
<p>temp_table = table;</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>return res_table;</p>
<p>case 4:</p>
<p>// without South</p>
<p>temp_table = table;</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>// without West</p>
<p>temp_table = table;</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>// without North</p>
<p>temp_table = table;</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>// without East</p>
<p>temp_table = table;</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>return res_table;</p>
<p>case 5:</p>
<p>temp_table = table;</p>
<p>temp_table = South(temp_table, x, y);</p>
<p>temp_table = West(temp_table, x, y);</p>
<p>temp_table = North(temp_table, x, y);</p>
<p>temp_table = East(temp_table, x, y);</p>
<p>res_table.push_back(temp_table);</p>
<p>return res_table;</p>
<p>}</p>
<p>}</p>
<p>int DFS(vector&lt;vector&lt;int&gt;&gt; table, vector&lt;vector&lt;int&gt;&gt; camera,int start) {</p>
<p>if (start == camera.size()) return blindSpot(table);</p>
<p>int minimum = INT_MAX;</p>
<p>int x = camera[start][0]; int y = camera[start][1]; int dir = camera[start][2];</p>
<p>vector &lt; vector&lt;vector&lt;int&gt;&gt;&gt; res_table = Monitoring(table, x, y, dir);</p>
<p>for (int i = 0; i &lt; res_table.size(); i++) minimum=min(minimum,DFS(res_table[i], camera, start + 1));</p>
<p>return minimum;</p>
<p>}</p>
<p>int main() {</p>
<p>//pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; input = makeTable();</p>
<p>pair&lt;vector&lt;vector&lt;int&gt;&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; input = makeTable2();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = input.first;</p>
<p>vector&lt;vector&lt;int&gt;&gt; camera = input.second;</p>
<p>cout &lt;&lt; DFS(table, camera,0);</p>
<p>return 0;</p>
<p>}</p>
<p>[115. <strong>[BACKJOON – SAMSUNG SW : Ladder Rigging]]</strong></p>
<p>- I spent 5 hour to reach the limit.</p>
<p>- At first, I used DFS but time limit exceeded occurred.</p>
<p>- So I changed my algorithm to BFS but it was same!!!</p>
<p>- so I changed again and make all the thing small and use global variable to reduce the transfer time during calling functions.</p>
<p>- Finally, I got correct mark. I refered to disccusion.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>using namespace std;</p>
<p>int answer = INT_MAX;</p>
<p>int table[31][11];</p>
<p>int N; int M; int H;</p>
<p>void makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_ladder_rigging.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M; in &gt;&gt; H;</p>
<p>int a; int b;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>in &gt;&gt; a; in &gt;&gt; b;</p>
<p>table[a ][b] = 2;// 2 is horizon line.</p>
<p>}</p>
<p>}</p>
<p>void makeTable2() {</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M; cin &gt;&gt; H;</p>
<p>int a; int b;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>cin &gt;&gt; a; cin &gt;&gt; b;</p>
<p>table[a ][b] = 2;// 2 is horizon line.</p>
<p>}</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (int i = 0; i &lt; H;i++) {</p>
<p>for (int j = 0; j &lt; N; j++)</p>
<p>cout &lt;&lt; table[i][j] &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>inline bool isSameEnd() {</p>
<p>for (int j = 1; j &lt;=N; j++) {</p>
<p>int pos = j;</p>
<p>for (int i = 1; i &lt;= H; i++) {</p>
<p>if (table[i][pos - 1] == 2) pos -= 1;</p>
<p>else if (table[i][pos] == 2) pos += 1;</p>
<p>}</p>
<p>if (j != pos) return false;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>void DFS(int count, int start) {</p>
<p>if(count &gt;= 4) return;</p>
<p>if (isSameEnd()) {</p>
<p>answer = min(answer, count);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = 1; i &lt;=H; i++) {</p>
<p>for (int j = start; j &lt; N; j++) {</p>
<p>if (table[i][j] == 2) continue;</p>
<p>if (table[i][j - 1] == 2) continue;</p>
<p>if (table[i][j + 1] == 2) continue;</p>
<p>table[i][j] = 2;</p>
<p>DFS( count + 1, j);</p>
<p>table[i][j] = 0;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>makeTable2();</p>
<p>if (isSameEnd()) {</p>
<p>cout &lt;&lt; 0;</p>
<p>return 0;</p>
<p>}</p>
<p>DFS( 0, 1);</p>
<p>answer== INT_MAX? cout&lt;&lt;-1:cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[116. <strong>[BACKJOON – SAMSUNG SW : Dragon Curve]]</strong></p>
<p>- this problem’s main point was the way to make the dragon curve with generation.</p>
<p>- I used a stack to record previous directions and take it all when new generation was started with rotating the directions 90 degrees.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int table[101][101] = { 0, };</p>
<p>int N,X, Y, d, g;</p>
<p>int direction[4][2] = { {0,1},{-1,0},{0,-1},{1,0} }; // east north west south</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_dragon_curve.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; curve;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>in &gt;&gt; X &gt;&gt; Y &gt;&gt; d &gt;&gt; g;</p>
<p>curve.push_back(vector&lt;int&gt;{X, Y, d, g});</p>
<p>}</p>
<p>return curve;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; curve;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; X &gt;&gt; Y &gt;&gt; d &gt;&gt; g;</p>
<p>curve.push_back(vector&lt;int&gt;{X, Y, d, g});</p>
<p>}</p>
<p>return curve;</p>
<p>}</p>
<p>void printCurve(vector&lt;vector&lt;int&gt;&gt; curve) {</p>
<p>for (int i = 0; i &lt; curve.size(); i++) {</p>
<p>for (int j = 0; j &lt; curve[0].size(); j++)</p>
<p>cout &lt;&lt; curve[i][j] &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (int i = 0; i &lt; 101; i++) {</p>
<p>for (int j = 0; j &lt; 101; j++) {</p>
<p>cout &lt;&lt; table[i][j] &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; Drawing(vector&lt;int&gt; stack, int ex, int ey) {</p>
<p>vector&lt;int&gt; res = stack;</p>
<p>for (int i = stack.size() - 1; i &gt;= 0; i--) {</p>
<p>int dir = (stack[i] + 1) % 4;</p>
<p>ex += direction[dir][1]; ey += direction[dir][0];</p>
<p>table[ey][ex] = 1;</p>
<p>res.push_back(dir);</p>
<p>}</p>
<p>return make_pair(res, vector&lt;int&gt;{ex, ey});</p>
<p>}</p>
<p>void makeDragonCurve(vector&lt;vector&lt;int&gt;&gt; curve) {</p>
<p>//how to make rotate 90 degree?</p>
<p>for (vector&lt;int&gt; row : curve) {</p>
<p>int x = row[0]; int y = row[1]; int dir = row[2]; int generation = row[3];</p>
<p>int ex = x + direction[dir][1]; int ey = y + direction[dir][0];</p>
<p>table[y][x] = 1;</p>
<p>table[ey][ex] = 1;</p>
<p>vector&lt;int&gt; stack = { dir };</p>
<p>for (int i = 1; i &lt;= generation; i++) {</p>
<p>pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; res = Drawing(stack, ex, ey);</p>
<p>stack = res.first; ex = res.second[0]; ey = res.second[1];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int findAnswer() {</p>
<p>int sum = 0;</p>
<p>for (int i = 1; i &lt; 101; i++) {</p>
<p>for (int j = 1; j &lt; 101; j++) {</p>
<p>if (table[i][j] &amp;&amp; table[i - 1][j] &amp;&amp; table[i][j - 1] &amp;&amp; table[i - 1][j - 1]) sum++;</p>
<p>}</p>
<p>}</p>
<p>return sum;</p>
<p>}</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; curve = makeTable();</p>
<p>vector&lt;vector&lt;int&gt;&gt; curve = makeTable2();</p>
<p>makeDragonCurve(curve);</p>
<p>cout&lt;&lt;findAnswer();</p>
<p>return 0;</p>
<p>}</p>
<p>[117. <strong>[BACKJOON – SAMSUNG SW : Chicken Delivery]]</strong></p>
<p>- DFS was needed to choose which chicken house will be alive.</p>
<p>- BFS was a significant problem, since when I used queue for BFS, time limit exceeded occurred.</p>
<p>- so I throw the fxxking queue out and using vector to recored which chicken houses were chosen.</p>
<p>- From the chosen chicken house, calculated distance between all the houses.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; chicken;</p>
<p>vector&lt;vector&lt;int&gt;&gt; house;</p>
<p>vector&lt;int&gt; chosen;</p>
<p>int N; int M;</p>
<p>void makeTable() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_chicken_delivery.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N&gt;&gt;M;</p>
<p>int temp;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>table.push_back(vector&lt;int&gt;(N, 0));</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>in &gt;&gt; temp;</p>
<p>if (temp == 2) { chicken.push_back({ i,j }); continue;}</p>
<p>if (temp == 1) house.push_back({ i,j });</p>
<p>table[i][j] = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void makeTable2() {</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>int temp;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>table.push_back(vector&lt;int&gt;(N, 0));</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; temp;</p>
<p>if (temp == 2) { chicken.push_back({ i,j }); continue; }</p>
<p>if (temp == 1) house.push_back({ i,j });</p>
<p>table[i][j] = 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int BFS() {</p>
<p>int distance = 0;</p>
<p>for (int k = 0; k &lt; house.size(); k++) {</p>
<p>int hx = house[k][0]; int hy = house[k][1];</p>
<p>int minimum = INT_MAX;</p>
<p>for (int i = 0; i &lt; chosen.size(); i++) {</p>
<p>int a = chosen[i];</p>
<p>minimum = min(minimum, abs(hx - chicken[a][0]) + abs(hy - chicken[a][1]));</p>
<p>}</p>
<p>distance += minimum;</p>
<p>}</p>
<p>return distance;</p>
<p>}</p>
<p>int DFS(int start,int count) {</p>
<p>if (count &gt;= M) {</p>
<p>return BFS();</p>
<p>}</p>
<p>int minimum = INT_MAX;</p>
<p>for (int i = start; i &lt; chicken.size(); i++) {</p>
<p>int x = chicken[i][0]; int y = chicken[i][1];</p>
<p>chosen.push_back(i);</p>
<p>table[x][y] = 2;</p>
<p>minimum=min(minimum,DFS(i + 1,count+1));</p>
<p>table[x][y] = 0;</p>
<p>chosen.pop_back();</p>
<p>}</p>
<p>return minimum;</p>
<p>}</p>
<p>int main() {</p>
<p>//makeTable();</p>
<p>makeTable2();</p>
<p>cout &lt;&lt; DFS(0,0);</p>
<p>return 0;</p>
<p>}</p>
<p>[118. <strong>[BACKJOON – SAMSUNG SW : Cubing]]</strong></p>
<p>- it was not a solving algorhthm! I think it was just a time consuming work actually.</p>
<p>- making cube and make it move following the given rules. was suck!</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; front;</p>
<p>vector&lt;vector&lt;char&gt;&gt; back;</p>
<p>vector&lt;vector&lt;char&gt;&gt; Left;</p>
<p>vector&lt;vector&lt;char&gt;&gt; Right;</p>
<p>vector&lt;vector&lt;char&gt;&gt; up;</p>
<p>vector&lt;vector&lt;char&gt;&gt; down;</p>
<p>vector&lt;vector&lt;string&gt;&gt; rule;</p>
<p>int N;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_cubing.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>int temp;</p>
<p>string rotate;</p>
<p>rule.assign(N, vector&lt;string&gt;{});</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>in &gt;&gt; temp;</p>
<p>for (int j = 0; j &lt; temp; j++) {</p>
<p>in &gt;&gt; rotate;</p>
<p>rule[i].push_back(rotate);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; N;</p>
<p>int temp;</p>
<p>string rotate;</p>
<p>rule.assign(N, vector&lt;string&gt;{});</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; temp;</p>
<p>for (int j = 0; j &lt; temp; j++) {</p>
<p>cin &gt;&gt; rotate;</p>
<p>rule[i].push_back(rotate);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void printRule() {</p>
<p>for (vector&lt;string&gt; row : rule) {</p>
<p>for (int i = 0; i &lt; row.size(); i++) {</p>
<p>cout &lt;&lt; row[i];</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void initCube() {</p>
<p>front = { {'r','r','r'},{'r','r','r'},{'r','r','r'} };</p>
<p>back = { {'o','o','o'},{'o','o','o'},{'o','o','o'} };</p>
<p>Left = { {'g','g','g'},{'g','g','g'},{'g','g','g'} };</p>
<p>Right = { {'b','b','b'},{'b','b','b'},{'b','b','b'} };</p>
<p>up = { {'w','w','w'},{'w','w','w'},{'w','w','w'} };</p>
<p>//up = { {'1','2','3'},{'4','5','6'},{'7','8','9'} };</p>
<p>down = { {'y','y','y'},{'y','y','y'},{'y','y','y'} };</p>
<p>}</p>
<p>vector&lt;vector&lt;char&gt;&gt; moveFront(vector&lt;vector&lt;char&gt;&gt; Left, string dir) {</p>
<p>char temp,temp2,temp3;</p>
<p>if (dir == &quot;-&quot;) {</p>
<p>temp = Left[0][0]; temp2 = Left[0][1];</p>
<p>Left[0][0] = Left[0][2]; Left[0][1] = Left[1][2]; Left[0][2] = Left[2][2]; Left[1][2] = Left[2][1]; Left[2][2] = Left[2][0]; Left[2][1] = Left[1][0];</p>
<p>Left[2][0] = temp; Left[1][0] = temp2;</p>
<p>}</p>
<p>else {</p>
<p>temp = Left[0][0]; temp2 = Left[1][0];</p>
<p>Left[0][0] = Left[2][0]; Left[1][0] = Left[2][1]; Left[2][0] = Left[2][2]; Left[2][1] = Left[1][2]; Left[2][2] = Left[0][2]; Left[1][2] = Left[0][1];</p>
<p>Left[0][2] = temp; Left[0][1] = temp2;</p>
<p>}</p>
<p>return Left;</p>
<p>}</p>
<p>void moveSide(char&amp; a, char&amp; b, char&amp; c, char&amp; d, char&amp; e, char&amp; f, char&amp; g, char&amp; h, char&amp; i, char&amp; j, char&amp; l, char&amp; m,string dir) {</p>
<p>char temp = a, temp2 = b, temp3 = c;</p>
<p>if (dir == &quot;-&quot;) {</p>
<p>a = d; b = e; c = f; d = g; e = h; f = i; g = j; h = l; i = m; j = temp; l = temp2; m = temp3;</p>
<p>}</p>
<p>else {</p>
<p>a = j; b = l; c = m; j = g; l = h; m = i; g = d; h = e; i = f; d = temp; e = temp2; f = temp3;</p>
<p>}</p>
<p>}</p>
<p>void rotateCube(string side, string dir) {</p>
<p>char temp, temp2, temp3;</p>
<p>//cout &lt;&lt; &quot;&lt;&lt;&quot;&lt;&lt;side&lt;&lt;&quot;&gt;&gt;&quot; &lt;&lt; endl;</p>
<p>if (side == &quot;L&quot;) {</p>
<p>Left = moveFront(Left, dir);</p>
<p>moveSide(front[0][0], front[1][0], front[2][0], down[0][0], down[1][0], down[2][0], back[0][0], back[1][0], back[2][0], up[0][0], up[1][0], up[2][0], dir);</p>
<p>}</p>
<p>else if (side == &quot;R&quot;) {</p>
<p>Right = moveFront(Right, dir);</p>
<p>moveSide(front[0][2], front[1][2], front[2][2], up[0][2], up[1][2], up[2][2], back[0][2], back[1][2], back[2][2], down[0][2], down[1][2], down[2][2], dir);</p>
<p>}</p>
<p>else if (side == &quot;U&quot;) {</p>
<p>up = moveFront(up, dir);</p>
<p>moveSide(front[0][2], front[0][1], front[0][0], Left[0][2], Left[0][1], Left[0][0], back[2][0], back[2][1], back[2][2], Right[0][2], Right[0][1], Right[0][0],dir);</p>
<p>}</p>
<p>else if (side == &quot;D&quot;) {</p>
<p>down = moveFront(down, dir);</p>
<p>moveSide(front[2][0], front[2][1], front[2][2], Right[2][0], Right[2][1], Right[2][2], back[0][2], back[0][1], back[0][0], Left[2][0], Left[2][1], Left[2][2], dir);</p>
<p>}</p>
<p>else if (side == &quot;F&quot;) {</p>
<p>front = moveFront(front, dir);</p>
<p>moveSide(up[2][0], up[2][1], up[2][2], Right[0][0], Right[1][0], Right[2][0], down[0][2], down[0][1], down[0][0], Left[2][2], Left[1][2], Left[0][2], dir);</p>
<p>}</p>
<p>else if (side == &quot;B&quot;) {</p>
<p>back = moveFront(back, dir);</p>
<p>moveSide(up[0][2], up[0][1], up[0][0], Left[0][0], Left[1][0], Left[2][0], down[2][0], down[2][1], down[2][2], Right[2][2], Right[1][2], Right[0][2], dir);</p>
<p>}</p>
<p>}</p>
<p>void printCubeTop() {</p>
<p>for (vector&lt;char&gt; row : up) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void printCube() {</p>
<p>cout &lt;&lt; &quot;up&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : up) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;front&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : front) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;Left&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : Left) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;Right&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : Right) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;back&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : back) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;down&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;char&gt; row : down) {</p>
<p>for (char c : row) {</p>
<p>cout &lt;&lt; c;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void followingRules() {</p>
<p>string side; string dir;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>initCube();</p>
<p>for (int j = 0; j &lt; rule[i].size(); j++) {</p>
<p>side = rule[i][j][0]; dir = rule[i][j][1];</p>
<p>rotateCube(side, dir);</p>
<p>}</p>
<p>printCubeTop();</p>
<p>//printCube();</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>//Input();</p>
<p>Input2();</p>
<p>followingRules();</p>
<p>return 0;</p>
<p>}</p>
<p>[119. <strong>[Programmers– KAKAO 2020 : String Compression]]</strong></p>
<p>- we need to be careful when we handle how many substring occurred.</p>
<p>- I used std::to_string to convert int to string.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>string s;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_string_compression.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; s;</p>
<p>}</p>
<p>int solution(string s) {</p>
<p>int answer = s.size();</p>
<p>for (int cur_size = 1; cur_size &lt; s.size()/2+1; cur_size++) {</p>
<p>vector&lt;string&gt; res = { s.substr(0,cur_size) };</p>
<p>vector&lt;int&gt; num = { 1 };</p>
<p>string temp;</p>
<p>int i;</p>
<p>for (i = cur_size; i + cur_size &lt;= s.size(); i += cur_size) {</p>
<p>temp = s.substr(i, cur_size);</p>
<p>if (res.back() == temp) { num[num.size() - 1]++; continue; }</p>
<p>res.push_back(temp);</p>
<p>num.push_back(1);</p>
<p>}</p>
<p>string compression;</p>
<p>for (int j = 0; j &lt; res.size(); j++) {</p>
<p>if (num[j] == 1) compression += res[j];</p>
<p>else {</p>
<p>compression += to_string(num[j]);</p>
<p>compression += res[j];</p>
<p>}</p>
<p>}</p>
<p>for (; i &lt; s.size(); i++)</p>
<p>compression += s[i];</p>
<p>answer = min(answer, compression.length());</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>Input();</p>
<p>cout &lt;&lt; solution(s);</p>
<p>return 0;</p>
<p>}</p>
<p>[120. <strong>[Programmers– KAKAO 2020 : Converting Parenthesis]]</strong></p>
<p>- this problem’s main point was to follow given rule to make valid parenthesis.</p>
<p>- but the given rule was quite ambiguous. so referring to example in a detailed fashion was important.</p>
<p>- be careful when you handle DFS.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>using namespace std;</p>
<p>string Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_converting_parenthesis.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>string p; in &gt;&gt; p;</p>
<p>return p;</p>
<p>}</p>
<p>pair&lt;string, string&gt; splitUV(string p) {</p>
<p>string u; string v;</p>
<p>int left = 0; int right = 0;</p>
<p>int i=0;</p>
<p>for (i = 0; i &lt; p.size(); i++) {</p>
<p>u += p[i];</p>
<p>if (p[i] == '(') left++;</p>
<p>else if (p[i] == ')') right++;</p>
<p>if (left == right) break;</p>
<p>}</p>
<p>for (int j = i + 1; j &lt; p.size(); j++) v += p[j];</p>
<p>return make_pair(u, v);</p>
<p>}</p>
<p>bool isValid(string u) {</p>
<p>int valid = 0;</p>
<p>for (char c : u) {</p>
<p>if (c == '(') valid++;</p>
<p>else if (c == ')') valid--;</p>
<p>if (valid &lt; 0) return false;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>string reverse(string p) {</p>
<p>for (int i = 0; i &lt; p.size(); i++)</p>
<p>p[i] == '(' ? p[i] = ')' : p[i] = '(';</p>
<p>return p;</p>
<p>}</p>
<p>string firstStep(string p) {</p>
<p>string res;</p>
<p>if (p.empty()) return &quot;&quot;;</p>
<p>pair&lt;string, string&gt; split = splitUV(p);</p>
<p>string u = split.first; string v = split.second;</p>
<p>if (isValid(u)) { res += u; res += firstStep(v);}</p>
<p>else {</p>
<p>res += &quot;(&quot;+ firstStep(v)+&quot;)&quot;;</p>
<p>u.erase(u.begin()); u.erase(next(u.end(),-1));</p>
<p>u = reverse(u);</p>
<p>res += u;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>string solution(string p) {</p>
<p>string answer = &quot;&quot;;</p>
<p>answer = firstStep(p);</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>string p= Input();</p>
<p>cout &lt;&lt; solution(p);</p>
<p>return 0;</p>
<p>}</p>
<p>[121. <strong>[Programmers– KAKAO 2020 : Lock and Key]]</strong></p>
<p>- implementing slicing using C++ is quite hard for me.</p>
<p>- I made slicing to determine whether the given key is valid or not.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable(int k,int l,vector&lt;vector&lt;int&gt;&gt; lock) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(k * 2 - 2 + l, vector&lt;int&gt;(k * 2 - 2 + l, 2));</p>
<p>for (int i = k - 1; i &lt; k - 1 + l; i++) {</p>
<p>for (int j = k - 1; j &lt; k - 1 + l; j++) {</p>
<p>table[i][j] = lock[i - (k - 1)][j - (k - 1)];</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; rotateKey(vector&lt;vector&lt;int&gt;&gt; key) {</p>
<p>int k = key.size();</p>
<p>vector&lt;vector&lt;int&gt;&gt; res(k, vector&lt;int&gt;(k));</p>
<p>for (int i = 0; i &lt; k; i++) {</p>
<p>for (int j = 0; j &lt; k; j++) {</p>
<p>res[i][j] = key[k-j-1][i];</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>void printKey(vector&lt;vector&lt;int&gt;&gt; key) {</p>
<p>for (vector&lt;int&gt; row : key) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>bool isValid(vector&lt;vector&lt;int&gt;&gt; key, vector&lt;vector&lt;int&gt;&gt; table,vector&lt;vector&lt;int&gt;&gt; lock){</p>
<p>int k = key.size(); int t = table.size();</p>
<p>for (int i = 0; i &lt; t-k+1; i++) {</p>
<p>for (int j = 0; j &lt; t-k+1; j++) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp_lock = table;</p>
<p>bool flag = true;</p>
<p>for (int a = 0; a &lt; k; a++) {</p>
<p>for (int b = 0; b &lt; k; b++) {</p>
<p>if (table[i + a][j + b] == 2) { temp_lock[i+a][j+b] = 1; continue; }</p>
<p>else if ((table[i + a][j + b] == 0 &amp;&amp; key[a][b] == 1) || (table[i + a][j + b] == 1 &amp;&amp; key[a][b] == 0)) {</p>
<p>temp_lock[i+a][j+b] = 1;</p>
<p>continue;</p>
<p>}</p>
<p>else { flag = false; break;}</p>
<p>}</p>
<p>}</p>
<p>if (flag) {</p>
<p>bool flag2 = true;</p>
<p>for (int i = k - 1; i &lt; t - k + 1;i++) {</p>
<p>for (int j = k - 1; j &lt; t - k + 1; j++) {</p>
<p>if (temp_lock[i][j] == 0) { flag2 = false; break; }</p>
<p>}</p>
<p>}</p>
<p>if (flag2) {</p>
<p>return true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>bool solution(vector&lt;vector&lt;int&gt;&gt; key, vector&lt;vector&lt;int&gt;&gt; lock) {</p>
<p>bool answer = true;</p>
<p>int k = key.size(); int l = lock.size();</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable(k, l,lock);</p>
<p>//rotate the given key at most 3 times.</p>
<p>if (isValid(key, table,lock)) return true;</p>
<p>for (int i = 0; i &lt; 3; i++) {</p>
<p>key=rotateKey(key);</p>
<p>if (isValid(key, table,lock)) return true;</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>int main() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; key = { {0,0},{1,0} };</p>
<p>vector&lt;vector&lt;int&gt;&gt; lock = { {0,0},{0,0} };</p>
<p>cout&lt;&lt;solution(key, lock);</p>
<p>return 0;</p>
<p>}</p>
<p>[122. <strong>[Programmers– KAKAO 2020 : Lyrics Searcing]]</strong></p>
<p>- I had solved correctly, but time limit exceeded occurred. so I had to change my algorithm for efficiency.</p>
<p>- below code is before changing the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;string&gt;, vector&lt;string&gt;&gt; Input() {</p>
<p>vector&lt;string&gt; words; vector&lt;string&gt; queries;</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_lyrics_searching.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>int N;</p>
<p>in &gt;&gt; N;</p>
<p>string temp;</p>
<p>for (int i = 0; i &lt; N; i++) { in &gt;&gt; temp; words.push_back(temp); }</p>
<p>while (!in.eof()) { in &gt;&gt; temp; queries.push_back(temp); }</p>
<p>return make_pair(words, queries);</p>
<p>}</p>
<p>void printInput(vector&lt;string&gt; input) {</p>
<p>for (string s : input)</p>
<p>cout &lt;&lt; s &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void printAnswer(vector&lt;int&gt; answer) {</p>
<p>for (int i : answer)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int numOfValidString(vector&lt;string&gt; words, string quer) {</p>
<p>if (words.empty()) return 0;</p>
<p>int i;</p>
<p>int num = 0;</p>
<p>int size = words[0].size();</p>
<p>if (quer[0] == '?') {</p>
<p>for (i = 0; i &lt; quer.size(); i++) if (quer[i] != '?') break;</p>
<p>int first = i;</p>
<p>int distance = size - first;</p>
<p>for (int j = 0; j &lt; words.size(); j++) {</p>
<p>if (words[j].substr(first, distance) == quer.substr(first, distance)) num++;</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>for(i=quer.size()-1; i&gt;=0;i--) if (quer[i] != '?') break;</p>
<p>int last = i;</p>
<p>for (int j = 0; j &lt; words.size(); j++) {</p>
<p>if (words[j].substr(0, last + 1) == quer.substr(0, last + 1)) num++;</p>
<p>}</p>
<p>}</p>
<p>return num;</p>
<p>}</p>
<p>vector&lt;int&gt; solution(vector&lt;string&gt; words, vector&lt;string&gt; queries) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>unordered_map&lt;int, vector&lt;string&gt;&gt; length;</p>
<p>for (int i = 0; i &lt; words.size(); i++) length[words[i].size()].push_back(words[i]);</p>
<p>for (int i = 0; i &lt; queries.size(); i++) answer.push_back(numOfValidString(length[queries[i].size()],queries[i]));</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>pair&lt;vector&lt;string&gt;, vector&lt;string&gt;&gt; input = Input();</p>
<p>vector&lt;string&gt; words = input.first;</p>
<p>vector&lt;string&gt; queries = input.second;</p>
<p>solution(words, queries);</p>
<p>return 0;</p>
<p>}</p>
<p>- I had to use trie structure to get marked at efficiency test.</p>
<p>- trie structure is often used when we handle string search.</p>
<p>- trie acts like a dictionary. so it has functions like insert, find.</p>
<p>- see the below code. I spent almost 4~5 hours.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;vector&lt;string&gt;, vector&lt;string&gt;&gt; Input() {</p>
<p>vector&lt;string&gt; words; vector&lt;string&gt; queries;</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_lyrics_searching.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>int N;</p>
<p>in &gt;&gt; N;</p>
<p>string temp;</p>
<p>for (int i = 0; i &lt; N; i++) { in &gt;&gt; temp; words.push_back(temp); }</p>
<p>while (!in.eof()) { in &gt;&gt; temp; queries.push_back(temp); }</p>
<p>return make_pair(words, queries);</p>
<p>}</p>
<p>void printInput(vector&lt;string&gt; input) {</p>
<p>for (string s : input)</p>
<p>cout &lt;&lt; s &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void printAnswer(vector&lt;int&gt; answer) {</p>
<p>for (int i : answer)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>// we have to use trie tree to record words and reversed words.</p>
<p>// we consider trie structure as a dictionary.</p>
<p>class Trie {</p>
<p>private:</p>
<p>Trie* children[26];</p>
<p>bool terminal;</p>
<p>unordered_map&lt;int, int&gt; length;</p>
<p>public:</p>
<p>Trie() {</p>
<p>fill(children, children + 26, nullptr);</p>
<p>this-&gt;terminal = false;</p>
<p>}</p>
<p>~Trie() {</p>
<p>for (int i = 0; i &lt; 26; i++) if(children[i]!=NULL) delete children[i];</p>
<p>}</p>
<p>void insert(const char* s,int size) {</p>
<p>if (*s =='\0') {</p>
<p>terminal = true;</p>
<p>return;</p>
<p>}</p>
<p>length[size] += 1;</p>
<p>if (children[*s - 'a'] == NULL)</p>
<p>children[*s - 'a'] = new Trie;</p>
<p>children[*s - 'a']-&gt;insert(s+1, size);</p>
<p>}</p>
<p>int find(const char* s,int size) {</p>
<p>if (*s == '\0') return terminal;</p>
<p>int count = 0;</p>
<p>if (*s == '?') count += length[size];</p>
<p>else {</p>
<p>if (children[*s - 'a'] == NULL) return 0;</p>
<p>count=children[*s - 'a']-&gt;find(s+1, size);</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>};</p>
<p>vector&lt;int&gt; solution(vector&lt;string&gt; words, vector&lt;string&gt; queries) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>Trie* prefix = new Trie;</p>
<p>Trie* suffix = new Trie;</p>
<p>int match;</p>
<p>for (int i = 0; i &lt; words.size(); i++) {</p>
<p>prefix-&gt;insert(&amp;words[i][0], words[i].size());</p>
<p>string temp = { words[i].rbegin(),words[i].rend() };</p>
<p>suffix-&gt;insert(&amp;temp[0], temp.size());</p>
<p>}</p>
<p>for (int i = 0; i &lt; queries.size(); i++) {</p>
<p>if (queries[i][0] == '?') {</p>
<p>string temp = { queries[i].rbegin(), queries[i].rend() };</p>
<p>answer.push_back(suffix-&gt;find(&amp;temp[0], temp.size()));</p>
<p>}</p>
<p>else answer.push_back(prefix-&gt;find(&amp;queries[i][0], queries[i].size()));</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>pair&lt;vector&lt;string&gt;, vector&lt;string&gt;&gt; input = Input();</p>
<p>vector&lt;string&gt; words = input.first;</p>
<p>vector&lt;string&gt; queries = input.second;</p>
<p>printAnswer(solution(words, queries));</p>
<p>return 0;</p>
<p>}</p>
<p>[123. <strong>[Programmers– KAKAO 2020 : Pillar and Beam]]</strong></p>
<p>- it was a quite dirty and time spending work.</p>
<p>- I had to implement all the possible condition by given rules.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#define pillar 0</p>
<p>#define beam 1</p>
<p>using namespace std;</p>
<p>inline int toY(int y, int n) { return n - y - 1; }</p>
<p>void printTable(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; table, int n) {</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>cout &lt;&lt; table[i][j][pillar] &lt;&lt; &quot;,&quot; &lt;&lt; table[i][j][beam] &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void printAnswer(vector&lt;vector&lt;int&gt;&gt;&amp; answer) {</p>
<p>for (vector&lt;int&gt; row : answer) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void Create(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; table, int x, int y, bool isBeam,int n) {</p>
<p>if (!isBeam) { //when it is a pillar.</p>
<p>if(y==n-1) table[y][x][pillar] = 1;</p>
<p>else if(table[y][x][beam]) table[y][x][pillar] = 1;</p>
<p>else if(x-1&gt;=0 &amp;&amp; table[y][x-1][beam]) table[y][x][pillar] = 1;</p>
<p>else if(table[y+1][x][pillar]) table[y][x][pillar] = 1;</p>
<p>}</p>
<p>else { // when it is a beam.</p>
<p>if(y+1&lt;n &amp;&amp; table[y+1][x][pillar]) table[y][x][beam] = 1;</p>
<p>else if (x + 1 &lt; n &amp;&amp; y + 1 &lt; n &amp;&amp; table[y + 1][x + 1][pillar]) table[y][x][beam] = 1;</p>
<p>else if (x-1&gt;=0 &amp;&amp; table[y][x-1][beam] &amp;&amp; x+1&lt;n &amp;&amp; table[y][x+1][beam]) table[y][x][beam] = 1;</p>
<p>}</p>
<p>}</p>
<p>void Delete(vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; table, int x, int y, bool isBeam,int n) {</p>
<p>if (!isBeam) {</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; table[y - 1][x][pillar] &amp;&amp; table[y - 1][x][beam] == 0 &amp;&amp; (x - 1 &lt;0 || table[y - 1][x - 1][beam] == 0)) return;</p>
<p>else if (y - 1 &gt;= 0 &amp;&amp; table[y - 1][x][beam] &amp;&amp; (x + 1 &gt;= n || table[y][x + 1][pillar] == 0) &amp;&amp; ((x+1&gt;=n || table[y - 1][x + 1][beam] == 0) || (x - 1 &lt; 0 || table[y - 1][x - 1][beam] == 0))) return;</p>
<p>else if (y - 1 &gt;= 0 &amp;&amp; x - 1 &gt;= 0 &amp;&amp; table[y - 1][x - 1][beam] &amp;&amp; table[y][x - 1][pillar] == 0 &amp;&amp; ((x - 2 &lt; 0 || table[y - 1][x - 2][beam] == 0) || (table[y - 1][x][beam] == 0))) return;</p>
<p>else table[y][x][pillar] = 0;</p>
<p>}</p>
<p>else {</p>
<p>if (table[y][x][pillar] &amp;&amp; (x - 1 &lt; 0 || table[y][x - 1][beam] == 0) &amp;&amp; table[y + 1][x][pillar] == 0) return;</p>
<p>else if ((x + 1 &lt; n &amp;&amp; table[y][x + 1][pillar]) &amp;&amp; table[y + 1][x + 1][pillar] == 0 &amp;&amp; table[y][x + 1][beam] == 0) return;</p>
<p>else if ((x - 1 &gt;= 0 &amp;&amp; table[y][x - 1][beam] == 1) &amp;&amp; table[y + 1][x - 1][pillar] == 0 &amp;&amp; table[y + 1][x][pillar] == 0) return;</p>
<p>else if((x+1&lt;n &amp;&amp; table[y][x+1][beam]==1) &amp;&amp; table[y+1][x+1][pillar]==0 &amp;&amp; (x+2&gt;=n || table[y+1][x+2][pillar]==0 )) return;</p>
<p>else table[y][x][beam] = 0;</p>
<p>}</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; solution(int n, vector&lt;vector&lt;int&gt;&gt; build_frame) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>// notice that the table's row is y not x. And the origin is bottom-left not top-left.</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; table(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(2, 0)));</p>
<p>// make table</p>
<p>for (int i = 0; i &lt; build_frame.size(); i++) {</p>
<p>int x = build_frame[i][0]; int y = toY(build_frame[i][1],n); bool isBeam = build_frame[i][2]; bool create = build_frame[i][3];</p>
<p>create ? Create(table, x, y, isBeam,n) : Delete(table, x, y, isBeam,n);</p>
<p>}</p>
<p>printTable(table, n);</p>
<p>// make answer</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>for (int i = n-1; i&gt;=0; i--) {</p>
<p>if (table[i][j][pillar]) answer.push_back({ j,toY(i,n),0 });</p>
<p>if (table[i][j][beam]) answer.push_back({ j,toY(i,n),1 });</p>
<p>}</p>
<p>}</p>
<p>printAnswer(answer);</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>//vector&lt;vector&lt;int&gt;&gt; input = {0,0,0,1},{2,0,0,1},{4,0,0,1},{0,1,1,1},{1,1,1,1},{2,1,1,1},{3,1,1,1},{2,0,0,0},{1,1,1,0},{2,2,0,1}};</p>
<p>vector&lt;vector&lt;int&gt;&gt; input = { {1,0,0,1},{1,1,1,1},{2,1,0,1},{2,2,1,1},{5,0,0,1},{5,1,0,1},{4,2,1,1},{3,2,1,1} };</p>
<p>//vector&lt;vector&lt;int&gt;&gt; input = { {1,0,0,1},{1,1,1,1},{1,1,0,1},{2,1,0,1},{2,2,1,1},{5,0,0,1},{5,1,0,1},{4,2,1,1},{3,2,1,1} };</p>
<p>solution(6, input);</p>
<p>return 0;</p>
<p>}</p>
<p>[124. <strong>[Programmers– KAKAO 2020 : Outer Wall Check]]</strong></p>
<p>- I first used DFS to implement a brutr force, but time limit exceeded occurred.</p>
<p>- see the DFS code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>using namespace std;</p>
<p>int minimum = INT_MAX;</p>
<p>inline bool isCheckedAll(vector&lt;int&gt; table) {</p>
<p>if (find(table.begin(), table.end(), 1) == table.end()) return true;</p>
<p>return false;</p>
<p>}</p>
<p>vector&lt;int&gt; ChecKWall(vector&lt;int&gt; table,int dist, int start,bool left,int n) {</p>
<p>if (left) {</p>
<p>while (dist&gt;=0) {</p>
<p>table[start] = 0;</p>
<p>start - 1 &lt; 0 ? start = n - 1 : start--;</p>
<p>dist--;</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>while (dist&gt;=0) {</p>
<p>table[start] = 0;</p>
<p>start = (start + 1) % n;</p>
<p>dist--;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>void DFS(vector&lt;int&gt; table,vector&lt;int&gt;weak, vector&lt;int&gt; dist, int n,int count) {</p>
<p>if (isCheckedAll(table)) { minimum = min(minimum, count); return; }</p>
<p>else if (dist.empty()) return;</p>
<p>for (int i = 0; i &lt; weak.size(); i++) {</p>
<p>int start = weak[i];</p>
<p>vector&lt;int&gt; temp_weak = weak;</p>
<p>temp_weak.erase(next(temp_weak.begin(), i));</p>
<p>for (int j = 0; j &lt; dist.size(); j++) {</p>
<p>vector&lt;int&gt; temp_dist = dist;</p>
<p>temp_dist.erase(next(temp_dist.begin(), j));</p>
<p>DFS(ChecKWall(table, dist[j], start, true, n),temp_weak,temp_dist,n,count+1);</p>
<p>DFS(ChecKWall(table, dist[j], start, false, n), temp_weak, temp_dist, n, count + 1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int solution(int n, vector&lt;int&gt; weak, vector&lt;int&gt; dist) {</p>
<p>vector&lt;int&gt; table(n,0);</p>
<p>for (int i = 0; i &lt; weak.size(); i++) table[weak[i]] = 1;</p>
<p>DFS(table,weak,dist,n,0);</p>
<p>int answer = minimum;</p>
<p>return answer==INT_MAX? -1 : answer;</p>
<p>}</p>
<p>- So I have to change for efficiency.</p>
<p>- It was not I had expected. It had a lot of complexity.</p>
<p>- My algorithm is below.</p>
<p>&gt; 1. choose the number of people we use to check from 1 to dist.size() with decending order.</p>
<p>&gt; 2. with chosen people, do permutation and check if they can check all the outer wall. If we can, return the number of people as an answer.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>using namespace std;</p>
<p>inline bool isAllOnes(vector&lt;int&gt; check) {</p>
<p>if (find(check.begin(), check.end(), 0) == check.end()) return true;</p>
<p>return false;</p>
<p>}</p>
<p>bool isCheckedAll(int people, vector&lt;int&gt;&amp; dist,vector&lt;int&gt; weak,int n) {</p>
<p>vector&lt;int&gt; chosen = { dist.rbegin(),next(dist.rbegin(),people) };</p>
<p>do {</p>
<p>for (int i = 0; i &lt; weak.size(); i++) {</p>
<p>//cout &lt;&lt; &quot;&lt;&lt;people :: &quot; &lt;&lt; people &lt;&lt; endl;</p>
<p>int start = i;</p>
<p>//cout &lt;&lt; &quot; weak[start] : &quot; &lt;&lt; weak[start] &lt;&lt; endl;</p>
<p>vector&lt;int&gt; check(weak.size(), 0);</p>
<p>check[start] = 1;</p>
<p>for (int j = 0; j &lt; chosen.size(); j++) { //start= 10 length = 14 -&gt; 2</p>
<p>//cout &lt;&lt; &quot; cur_start : &quot; &lt;&lt; start &lt;&lt; endl;</p>
<p>int length = chosen[j] + weak[start];</p>
<p>if (length &gt;= n) {</p>
<p>length %= n;</p>
<p>int k;</p>
<p>for (k = start; k &lt; check.size(); k++) check[k] = 1;</p>
<p>for (k = 0; k &lt; start; k++) {</p>
<p>if (weak[k] &lt;= length) check[k] = 1;</p>
<p>else break;</p>
<p>}</p>
<p>if (isAllOnes(check)) return true;</p>
<p>else start = k % weak.size();</p>
<p>}</p>
<p>else {</p>
<p>int k;</p>
<p>for (k = start; k &lt; weak.size(); k++) {</p>
<p>if (length &gt;= weak[k]) check[k] = 1;</p>
<p>else break;</p>
<p>}</p>
<p>if (isAllOnes(check)) return true;</p>
<p>else start = k % weak.size();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} while (prev_permutation(chosen.begin(), chosen.end()));</p>
<p>return false;</p>
<p>}</p>
<p>int solution(int n, vector&lt;int&gt; weak, vector&lt;int&gt; dist) {</p>
<p>vector&lt;int&gt; table(n, 0);</p>
<p>sort(dist.begin(), dist.end());</p>
<p>int minimum = INT_MAX;</p>
<p>for (int i = 0; i &lt; weak.size(); i++) table[weak[i]] = 1;</p>
<p>// when we need just one person.</p>
<p>for (int i = 0; i &lt; weak.size(); i++) {</p>
<p>int length = dist.back() + weak[i];</p>
<p>if (length &gt;= n) {</p>
<p>if (i == 0 || (weak[i - 1] &lt;= length % n)) return 1;</p>
<p>}</p>
<p>else if (length &gt;= weak.back() &amp;&amp; i == 0) return 1;</p>
<p>}</p>
<p>// when we need more than one person.</p>
<p>for (int people = 2; people &lt;= dist.size(); people++) {</p>
<p>if (isCheckedAll(people, dist, weak, n)) return people;</p>
<p>}</p>
<p>return -1; //when we failed to check all the outer wall even if we used all the people.</p>
<p>}</p>
<p>int main() {</p>
<p>//cout&lt;&lt;solution(12, { 1,5,6,10 }, { 1,2,3,4 })&lt;&lt;endl;</p>
<p>//cout &lt;&lt; solution(12, { 1,3,4,9,10 }, { 3,5,7 }) &lt;&lt; endl;</p>
<p>//cout &lt;&lt; solution(50, { 1, 5, 10, 12, 22, 25 }, { 4, 3, 2, 1 }) &lt;&lt; endl;</p>
<p>cout &lt;&lt; solution(50, { 1, 5, 10, 16, 22, 25 }, { 3,4,6 }) &lt;&lt; endl;</p>
<p>//cout &lt;&lt; solution(50, { 1 }, { 6 }) &lt;&lt; endl;</p>
<p>//cout &lt;&lt; solution(12, { 1,5 }, { 2,3,7 });</p>
<p>return 0;</p>
<p>}</p>
<p>[125. <strong>[Programmers– KAKAO 2020 : Moving Block]]</strong></p>
<p>- At first, I used DFS to implement brute force, but I failed lots of test case and time limit exceeded occurred.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>using namespace std;</p>
<p>int minimum = INT_MAX;</p>
<p>typedef struct cell {</p>
<p>bool wall=false;</p>
<p>bool right = false;</p>
<p>bool down = false;</p>
<p>}cell;</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void DFS(vector&lt;vector&lt;int&gt;&gt; board, vector&lt;vector&lt;cell&gt;&gt; visit, int bs, int x, int y, bool isRight, int count) {</p>
<p>// initialize</p>
<p>int rx; int ry;</p>
<p>if (isRight) { rx = x; ry = y + 1; visit[x][y].right = true; }</p>
<p>else { rx = x + 1; ry = y; visit[x][y].down = true; }</p>
<p>//cout &lt;&lt; &quot;x : &quot; &lt;&lt; x &lt;&lt; &quot; y : &quot; &lt;&lt; y &lt;&lt;&quot; Right : &quot;&lt;&lt;isRight&lt;&lt; endl;</p>
<p>// check arriving</p>
<p>if (rx == bs - 1 &amp;&amp; ry == bs - 1) { minimum = min(minimum, count); return; }</p>
<p>// DFS</p>
<p>//cout &lt;&lt; &quot; x : &quot; &lt;&lt; x &lt;&lt; &quot; y : &quot; &lt;&lt; y &lt;&lt;&quot; rx : &quot;&lt;&lt;rx&lt;&lt;&quot; ry : &quot;&lt;&lt;ry&lt;&lt; &quot; Right : &quot;&lt;&lt;isRight&lt;&lt;&quot; count : &quot;&lt;&lt;count&lt;&lt; endl;</p>
<p>// isRight</p>
<p>if (isRight) {</p>
<p>//cout &lt;&lt; &quot;right&quot; &lt;&lt; endl;</p>
<p>//move</p>
<p>//right</p>
<p>if (ry + 1 &lt; bs &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[rx][ry].right == false) { DFS(board, visit, bs, rx, ry, true, count + 1); }</p>
<p>//down</p>
<p>if (x + 1 &lt; bs &amp;&amp; board[x + 1][y] == 0 &amp;&amp; board[rx + 1][ry] == 0 &amp;&amp; visit[x + 1][y].right == false) { DFS(board, visit, bs, x + 1, y, true, count + 1); }</p>
<p>//left</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y-1] == 0 &amp;&amp; visit[x][y-1].right == false) { DFS(board, visit, bs, x, y-1, true, count + 1); }</p>
<p>//up</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; board[rx - 1][y] == 0 &amp;&amp; visit[x - 1][y].right == false) { DFS(board, visit, bs, x - 1, y, true, count + 1); }</p>
<p>//rotate</p>
<p>//left axis - clockwise</p>
<p>//cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</p>
<p>if (rx &lt; bs &amp;&amp; ry &lt; bs &amp;&amp;x+1&lt;bs&amp;&amp; board[rx+1][ry] == 0&amp;&amp; board[x+1][y]==0 &amp;&amp; visit[x][y].down == false) { DFS(board, visit, bs, x, y, false, count + 1); }</p>
<p>//left axis - anticlockwise</p>
<p>//cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;</p>
<p>if (rx &lt; bs &amp;&amp; ry &lt;&lt; bs &amp;&amp; x - 1 &gt;= 0 &amp;&amp; board[rx - 1][ry] == 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; visit[x - 1][y].down == false) { DFS(board, visit, bs, x - 1, y, false, count + 1); }</p>
<p>//right axis - clockwise</p>
<p>//cout &lt;&lt; &quot;3&quot; &lt;&lt; endl;</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; board[rx - 1][ry] == 0 &amp;&amp; visit[rx - 1][ry].down == false) { DFS(board, visit, bs, rx - 1, ry, false, count + 1); }</p>
<p>//right axis - anticlockwise</p>
<p>//cout &lt;&lt; &quot;4&quot; &lt;&lt; endl;</p>
<p>if (x + 1 &lt; bs &amp;&amp; board[x + 1][y] == 0 &amp;&amp; board[rx + 1][rx] == 0 &amp;&amp; visit[rx][ry].down == false) { DFS(board, visit, bs, rx, ry, false, count + 1); }</p>
<p>}</p>
<p>// is Down</p>
<p>else {</p>
<p>//cout &lt;&lt; &quot;down&quot; &lt;&lt; endl;</p>
<p>//move</p>
<p>//right</p>
<p>if (y + 1 &lt; bs &amp;&amp; board[x][y + 1] == 0 &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[x][y + 1].down == false) { DFS(board,visit,bs,x,y+1,false,count+1); }</p>
<p>//down</p>
<p>if (rx + 1 &lt; bs &amp;&amp; board[rx + 1][y] == 0 &amp;&amp; visit[rx][rx].down == false) { DFS(board, visit, bs, rx, ry, false, count + 1); }</p>
<p>//left</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; board[rx][ry - 1] == 0 &amp;&amp; visit[x][y - 1].down == false) { DFS(board, visit, bs, x, y - 1, false, count + 1); }</p>
<p>//up</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; visit[x - 1][y].down == false) { DFS(board, visit, bs, x - 1, y, false, count + 1); }</p>
<p>//rotate</p>
<p>//top axis - clockwise</p>
<p>//cout &lt;&lt; &quot;5&quot; &lt;&lt; endl;</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; board[rx][ry - 1] == 0 &amp;&amp; visit[x][y - 1].right == false) { DFS(board, visit, bs, x , y-1, true, count + 1); }</p>
<p>//top axis - anticlockwise</p>
<p>//cout &lt;&lt; &quot;6&quot; &lt;&lt; endl;</p>
<p>if (y + 1 &lt; bs &amp;&amp; board[x][y+1] == 0 &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[x][y].right == false) { DFS(board, visit, bs, x, y, true, count + 1); }</p>
<p>//bottom axis - clockwise</p>
<p>//cout &lt;&lt; &quot;7&quot; &lt;&lt; endl;</p>
<p>if (y + 1 &lt; bs &amp;&amp; board[x][y + 1] == 0 &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[rx][ry].right == false) { DFS(board, visit, bs, rx, ry, true, count + 1); }</p>
<p>//bottom axis - anticlockwise</p>
<p>//cout &lt;&lt; &quot;8&quot; &lt;&lt; endl;</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; board[rx][ry - 1] == 0 &amp;&amp; visit[rx][ry - 1].right == false) { DFS(board, visit, bs, rx, ry - 1, true, count + 1); }</p>
<p>}</p>
<p>}</p>
<p>int solution(vector&lt;vector&lt;int&gt;&gt; board) {</p>
<p>int answer = 0;</p>
<p>int bs = board.size();</p>
<p>vector&lt;vector&lt;cell&gt;&gt; visit(bs,vector&lt;cell&gt;(bs));</p>
<p>for (int i = 0; i &lt; bs; i++) {</p>
<p>for (int j = 0; j &lt; bs; j++) {</p>
<p>if (board[i][j] == 1) visit[i][j].wall = true;</p>
<p>}</p>
<p>}</p>
<p>//printTable(board);</p>
<p>//cout &lt;&lt; endl;</p>
<p>DFS(board, visit, bs,0,0,true,0);</p>
<p>answer = minimum;</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; solution({ {0, 0, 0, 1, 1}, {0, 0, 0, 1, 0}, {0, 1, 0, 1, 1}, {1, 1, 0, 0, 1}, {0, 0, 0, 0, 0} });</p>
<p>return 0;</p>
<p>}</p>
<p>- so I had to change the algorithm to BFS and revise some codes but time limit exceeded occurred also.</p>
<p>- below is the BFS code I used.</p>
<p>int BFS(vector&lt;vector&lt;int&gt;&gt; board, vector&lt;vector&lt;cell&gt;&gt; visit, int bs, int x, int y, bool isRight) {</p>
<p>queue &lt; pair&lt;vector&lt;vector&lt;cell&gt;&gt;, vector&lt;int&gt;&gt;&gt; que;</p>
<p>int count = 0;</p>
<p>int rx, ry;</p>
<p>que.push(make_pair(visit, vector&lt;int&gt;{x, y, isRight, count}));</p>
<p>while (!que.empty()) {</p>
<p>visit = que.front().first;</p>
<p>vector&lt;int&gt; front = que.front().second;</p>
<p>x = front[0]; y = front[1]; isRight = front[2]; count = front[3];</p>
<p>que.pop();</p>
<p>if (isRight) { rx = x; ry = y + 1; visit[x][y].right = true; }</p>
<p>else { rx = x + 1; ry = y; visit[x][y].down = true; }</p>
<p>if (rx == bs - 1 &amp;&amp; ry == bs - 1) return count;</p>
<p>if (isRight) {</p>
<p>//move</p>
<p>//right</p>
<p>if (ry + 1 &lt; bs &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[rx][ry].right == false)</p>
<p>{ que.push(make_pair(visit,vector&lt;int&gt;{ rx, ry, true, count + 1 })); }</p>
<p>//down</p>
<p>if (x + 1 &lt; bs &amp;&amp; board[x + 1][y] == 0 &amp;&amp; board[rx + 1][ry] == 0 &amp;&amp; visit[x + 1][y].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x+1, y, true, count + 1 })); }</p>
<p>//left</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; visit[x][y - 1].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x, y-1, true, count + 1 })); }</p>
<p>//up</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; board[rx - 1][y] == 0 &amp;&amp; visit[x - 1][y].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x-1, y, true, count + 1 })); }</p>
<p>//rotate</p>
<p>//left axis - clockwise</p>
<p>if (x+1&lt;bs &amp;&amp; board[rx + 1][ry] == 0 &amp;&amp; board[x + 1][y] == 0 &amp;&amp; visit[x][y].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x, y, false, count + 1 })); }</p>
<p>//left axis - anticlockwise</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[rx - 1][ry] == 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; visit[x - 1][y].down == false)</p>
<p>{que.push(make_pair(visit, vector&lt;int&gt;{ x-1, y, false, count + 1 })); }</p>
<p>//right axis - clockwise</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; board[rx - 1][ry] == 0 &amp;&amp; visit[rx - 1][ry].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ rx-1, ry, false, count + 1 })); }</p>
<p>//right axis - anticlockwise</p>
<p>if (x + 1 &lt; bs &amp;&amp; board[x + 1][y] == 0 &amp;&amp; board[rx + 1][ry] == 0 &amp;&amp; visit[rx][ry].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ rx, ry, false, count + 1 }));}</p>
<p>}</p>
<p>else {</p>
<p>//move</p>
<p>//right</p>
<p>if (y + 1 &lt; bs &amp;&amp; board[x][y + 1] == 0 &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[x][y + 1].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x, y+1, false, count + 1 })); }</p>
<p>//down</p>
<p>if (rx + 1 &lt; bs &amp;&amp; board[rx + 1][y] == 0 &amp;&amp; visit[rx][ry].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ rx, ry, false, count + 1 })); }</p>
<p>//left</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; board[rx][ry - 1] == 0 &amp;&amp; visit[x][y - 1].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x, y-1, false, count + 1 })); }</p>
<p>//up</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; board[x - 1][y] == 0 &amp;&amp; visit[x - 1][y].down == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x-1, y, false, count + 1 })); }</p>
<p>//rotate</p>
<p>//top axis - clockwise</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; board[rx][ry - 1] == 0 &amp;&amp; visit[x][y - 1].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x, y-1, true, count + 1 })); }</p>
<p>//top axis - anticlockwise</p>
<p>if (y + 1 &lt; bs &amp;&amp; board[x][y + 1] == 0 &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[x][y].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ x, y, true, count + 1 })); }</p>
<p>//bottom axis - clockwise</p>
<p>if (y + 1 &lt; bs &amp;&amp; board[x][y + 1] == 0 &amp;&amp; board[rx][ry + 1] == 0 &amp;&amp; visit[rx][ry].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ rx, ry, true, count + 1 })); }</p>
<p>//bottom axis - anticlockwise</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; board[x][y - 1] == 0 &amp;&amp; board[rx][ry - 1] == 0 &amp;&amp; visit[rx][ry - 1].right == false)</p>
<p>{ que.push(make_pair(visit, vector&lt;int&gt;{ rx, ry-1, true, count + 1 })); }</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- so I made NewBFS, I got all test cases’ mark but, time limit exceeded occurred at tc 13, 14.</p>
<p>- see the NewBFS code.</p>
<p>int NewBFS(vector&lt;vector&lt;cell&gt;&gt; visit) {</p>
<p>int bs = visit.size();</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{0, 0, 1,0});//x,y, isRIght;</p>
<p>while ( !que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; bool isRight = que.front()[2]; int count = que.front()[3];</p>
<p>que.pop();</p>
<p>if (isRight &amp;&amp; x == bs - 1 &amp;&amp; y + 1 == bs - 1) return count;</p>
<p>else if (x + 1 == bs - 1 &amp;&amp; y == bs - 1) return count;</p>
<p>isRight ? visit[x][y].right = false : visit[x][y].down = false;</p>
<p>if (isRight) {</p>
<p>//move</p>
<p>if (y + 2 &lt; bs &amp;&amp; visit[x][y + 1].right&amp;&amp; visit[x][y+2].wall) que.push(vector&lt;int&gt;{x, y + 1, true, count + 1});</p>
<p>if (y-1&gt;=0 &amp;&amp; visit[x][y-1].right &amp;&amp; visit[x][y-1].wall) que.push( vector&lt;int&gt;{x, y -1, true, count + 1});</p>
<p>if(x+1&lt;bs &amp;&amp; visit[x+1][y].wall &amp;&amp; visit[x+1][y+1].wall &amp;&amp; visit[x+1][y].right) que.push(vector&lt;int&gt;{x+1, y, true, count + 1});</p>
<p>if(x-1&gt;=0 &amp;&amp; visit[x-1][y].wall &amp;&amp; visit[x-1][y+1].wall &amp;&amp; visit[x-1][y].right) que.push(vector&lt;int&gt;{x-1, y, true, count + 1});</p>
<p>//rotate</p>
<p>if (x + 1 &lt; bs &amp;&amp; visit[x + 1][y].wall &amp;&amp; visit[x + 1][y + 1].wall ) {</p>
<p>if( visit[x][y].down) que.push( vector&lt;int&gt;{x, y, false, count + 1});</p>
<p>if( visit[x][y + 1].down) que.push(vector&lt;int&gt;{x, y+1, false, count + 1});</p>
<p>}</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; visit[x - 1][y].wall &amp;&amp; visit[x - 1][y + 1].wall ) {</p>
<p>if( visit[x - 1][y].down) que.push( vector&lt;int&gt;{x - 1, y, false, count + 1});</p>
<p>if( visit[x - 1][y + 1].down) que.push(vector&lt;int&gt;{x - 1, y + 1, false, count + 1});</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>//move</p>
<p>if(y+1&lt;bs &amp;&amp; visit[x][y+1].wall &amp;&amp; visit[x+1][y+1].wall &amp;&amp; visit[x][y+1].down) que.push(vector&lt;int&gt;{x, y+1, false, count + 1});</p>
<p>if(y-1&gt;=0 &amp;&amp; visit[x][y-1].wall &amp;&amp; visit[x+1][y-1].wall &amp;&amp; visit[x][y-1].down) que.push(vector&lt;int&gt;{x, y-1, false, count + 1});</p>
<p>if(x+2&lt;bs &amp;&amp; visit[x+2][y].wall &amp;&amp; visit[x+1][y].down) que.push(vector&lt;int&gt;{x+1, y, false, count + 1});</p>
<p>if(x-1&gt;=0 &amp;&amp; visit[x-1][y].wall &amp;&amp; visit[x-1][y].down) que.push(vector&lt;int&gt;{x-1, y, false, count + 1});</p>
<p>//rotate</p>
<p>if (y + 1 &lt; bs &amp;&amp; visit[x][y + 1].wall &amp;&amp; visit[x + 1][y + 1].wall) {</p>
<p>if( visit[x][y].right) que.push( vector&lt;int&gt;{x, y, true, count + 1});</p>
<p>if( visit[x+1][y].right) que.push( vector&lt;int&gt;{x+1, y, true, count + 1});</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; visit[x][y - 1].wall &amp;&amp; visit[x + 1][y - 1].wall) {</p>
<p>if( visit[x][y-1].right) que.push(vector&lt;int&gt;{x, y-1, true, count + 1});</p>
<p>if( visit[x+1][y-1].right) que.push(vector&lt;int&gt;{x+1, y-1, true, count + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- I resolved the time limit exceeded at tc 13,14 by changing the location of allocating visit state.</p>
<p>- before I changed it, I allocate visit state when I poped the queue.front().</p>
<p>- but I changed it before I pushed a state into queue.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>typedef struct cell {</p>
<p>bool wall = true;</p>
<p>bool right = true;</p>
<p>bool down = true;</p>
<p>}cell;</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>int NewBFS(vector&lt;vector&lt;cell&gt;&gt; visit) {</p>
<p>int bs = visit.size();</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{0, 0, 1,0});//x,y, isRIght;</p>
<p>while ( !que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; bool isRight = que.front()[2]; int count = que.front()[3];</p>
<p>que.pop();</p>
<p>if (isRight &amp;&amp; x == bs - 1 &amp;&amp; y + 1 == bs - 1) return count;</p>
<p>else if (x + 1 == bs - 1 &amp;&amp; y == bs - 1) return count;</p>
<p>if (isRight) {</p>
<p>//move</p>
<p>if (y + 2 &lt; bs &amp;&amp; visit[x][y + 1].right &amp;&amp; visit[x][y + 2].wall) {</p>
<p>visit[x][y+1].right = false;</p>
<p>que.push(vector&lt;int&gt;{x, y + 1, true, count + 1});</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; visit[x][y - 1].right &amp;&amp; visit[x][y - 1].wall) {</p>
<p>visit[x][y -1].right = false;</p>
<p>que.push(vector&lt;int&gt;{x, y - 1, true, count + 1});</p>
<p>}</p>
<p>if (x + 1 &lt; bs &amp;&amp; visit[x + 1][y].wall &amp;&amp; visit[x + 1][y + 1].wall &amp;&amp; visit[x + 1][y].right) {</p>
<p>visit[x+1][y].right = false;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y, true, count + 1});</p>
<p>}</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; visit[x - 1][y].wall &amp;&amp; visit[x - 1][y + 1].wall &amp;&amp; visit[x - 1][y].right) {</p>
<p>visit[x -1][y].right = false;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y, true, count + 1});</p>
<p>}</p>
<p>//rotate</p>
<p>if (x + 1 &lt; bs &amp;&amp; visit[x + 1][y].wall &amp;&amp; visit[x + 1][y + 1].wall ) {</p>
<p>if (visit[x][y].down) {</p>
<p>visit[x][y].down = false;</p>
<p>que.push(vector&lt;int&gt;{x, y, false, count + 1});</p>
<p>}</p>
<p>if (visit[x][y + 1].down) {</p>
<p>visit[x][y+1].down = false;</p>
<p>que.push(vector&lt;int&gt;{x, y + 1, false, count + 1});</p>
<p>}</p>
<p>}</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; visit[x - 1][y].wall &amp;&amp; visit[x - 1][y + 1].wall ) {</p>
<p>if (visit[x - 1][y].down) {</p>
<p>visit[x-1][y].down = false;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y, false, count + 1});</p>
<p>}</p>
<p>if (visit[x - 1][y + 1].down) {</p>
<p>visit[x - 1][y+1].down = false;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y + 1, false, count + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>//move</p>
<p>if (y + 1 &lt; bs &amp;&amp; visit[x][y + 1].wall &amp;&amp; visit[x + 1][y + 1].wall &amp;&amp; visit[x][y + 1].down) {</p>
<p>visit[x][y + 1].down = false;</p>
<p>que.push(vector&lt;int&gt;{x, y + 1, false, count + 1});</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; visit[x][y - 1].wall &amp;&amp; visit[x + 1][y - 1].wall &amp;&amp; visit[x][y - 1].down) {</p>
<p>visit[x][y - 1].down = false;</p>
<p>que.push(vector&lt;int&gt;{x, y - 1, false, count + 1});</p>
<p>}</p>
<p>if (x + 2 &lt; bs &amp;&amp; visit[x + 2][y].wall &amp;&amp; visit[x + 1][y].down) {</p>
<p>visit[x+1][y].down = false;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y, false, count + 1});</p>
<p>}</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; visit[x - 1][y].wall &amp;&amp; visit[x - 1][y].down) {</p>
<p>visit[x -1][y].down = false;</p>
<p>que.push(vector&lt;int&gt;{x - 1, y, false, count + 1});</p>
<p>}</p>
<p>//rotate</p>
<p>if (y + 1 &lt; bs &amp;&amp; visit[x][y + 1].wall &amp;&amp; visit[x + 1][y + 1].wall) {</p>
<p>if (visit[x][y].right) {</p>
<p>visit[x ][y].right = false;</p>
<p>que.push(vector&lt;int&gt;{x, y, true, count + 1});</p>
<p>}</p>
<p>if (visit[x + 1][y].right) {</p>
<p>visit[x+1][y].right = false;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y, true, count + 1});</p>
<p>}</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; visit[x][y - 1].wall &amp;&amp; visit[x + 1][y - 1].wall) {</p>
<p>if (visit[x][y - 1].right) {</p>
<p>visit[x ][y-1].right = false;</p>
<p>que.push(vector&lt;int&gt;{x, y - 1, true, count + 1});</p>
<p>}</p>
<p>if (visit[x + 1][y - 1].right) {</p>
<p>visit[x+1][y - 1].right = false;</p>
<p>que.push(vector&lt;int&gt;{x + 1, y - 1, true, count + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>int solution(vector&lt;vector&lt;int&gt;&gt; board) {</p>
<p>int answer = 0;</p>
<p>int bs = board.size();</p>
<p>vector&lt;vector&lt;cell&gt;&gt; visit(bs,vector&lt;cell&gt;(bs));</p>
<p>for (int i = 0; i &lt; bs; i++) {</p>
<p>for (int j = 0; j &lt; bs; j++) {</p>
<p>if (board[i][j] == 1) visit[i][j].wall = false;</p>
<p>}</p>
<p>}</p>
<p>answer = NewBFS(visit);</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; solution({ {0, 0, 0, 1, 1}, {0, 0, 0, 1, 0}, {0, 1, 0, 1, 1}, {1, 1, 0, 0, 1}, {0, 0, 0, 0, 0} });</p>
<p>return 0;</p>
<p>}</p>
<p>[126. <strong>[Programmers– KAKAO 2019 :Open Chat Room]]</strong></p>
<p>- it was an easy problem, but I needed to handle complex unordered_map structure. it was quite confusing.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;sstream&gt;</p>
<p>#include &lt;iostream&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;string&gt; res;</p>
<p>int index = 0;</p>
<p>unordered_map&lt;string, pair&lt;string, vector&lt;int&gt;&gt;&gt; table;</p>
<p>void Tokenize(string s) {</p>
<p>stringstream ss(s);</p>
<p>string token;</p>
<p>getline(ss, token, ' '); string in_out = token;</p>
<p>getline(ss, token, ' '); string uid = token;</p>
<p>getline(ss, token, ' '); string name = token;</p>
<p>if (in_out == &quot;Enter&quot;) res.push_back(&quot;님이 들어왔습니다.&quot;);</p>
<p>else if (in_out == &quot;Leave&quot;) res.push_back(&quot;님이 나갔습니다.&quot;);</p>
<p>if (table[uid].second.empty()) {</p>
<p>if(in_out==&quot;Enter&quot;) table[uid] = make_pair(name, vector&lt;int&gt;{index++});</p>
<p>else if(in_out==&quot;Change&quot;) table[uid] = make_pair(name, vector&lt;int&gt;{});</p>
<p>}</p>
<p>else {</p>
<p>if (in_out == &quot;Change&quot;) table[uid].first = name;</p>
<p>else if(in_out==&quot;Enter&quot;){</p>
<p>table[uid].first = name;</p>
<p>table[uid].second.push_back(index++);</p>
<p>}</p>
<p>else {</p>
<p>table[uid].second.push_back(index++);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>vector&lt;string&gt; solution(vector&lt;string&gt; record) {</p>
<p>vector&lt;string&gt; answer;</p>
<p>for (string s : record) Tokenize(s);</p>
<p>answer.assign(index, &quot;&quot;);</p>
<p>for (unordered_map&lt;string, pair&lt;string, vector&lt;int&gt;&gt;&gt;::iterator iter = table.begin(); iter != table.end(); iter++) {</p>
<p>for (int i : iter-&gt;second.second) {</p>
<p>answer[i] = iter-&gt;second.first + res[i];</p>
<p>}</p>
<p>}</p>
<p>for (string s : answer)</p>
<p>cout &lt;&lt; s &lt;&lt; endl;</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>solution(vector&lt;string&gt;{ &quot;Enter uid1234 Muzi&quot;, &quot;Enter uid4567 Prodo&quot;,&quot;Change uid4567 Ryan&quot;, &quot;Leave uid1234&quot;, &quot;Enter uid1234 Prodo&quot; });</p>
<p>return 0;</p>
<p>}</p>
<p>[127. <strong>[Programmers– KAKAO 2019 :Fail Rate]]</strong></p>
<p>- This problem’s point was to find order of index using fail rate.</p>
<p>- I used map, since map dose sort automatically.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include &lt;iostream&gt;</p>
<p>#include&lt;map&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; makeOrder(vector&lt;double&gt;&amp; failure,vector&lt;int&gt; answer) {</p>
<p>map&lt;double, vector&lt;int&gt;&gt; res;</p>
<p>for (int i = 1; i &lt; failure.size(); i++) {</p>
<p>res[failure[i]].push_back(i);</p>
<p>}</p>
<p>for (map&lt;double, vector&lt;int&gt;&gt;::reverse_iterator iter = res.rbegin(); iter != res.rend(); iter++) {</p>
<p>for (int i = 0; i &lt; iter-&gt;second.size(); i++) {</p>
<p>answer.push_back(iter-&gt;second[i]);</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>vector&lt;int&gt; solution(int N, vector&lt;int&gt; stages) {</p>
<p>sort(stages.begin(), stages.end());</p>
<p>vector&lt;double&gt; failure(N+1); //index starts from 1 not 0.</p>
<p>double cur_pass = 0;</p>
<p>int i;</p>
<p>for (i = stages.size() - 1; i &gt;= 0; i--) {</p>
<p>if (stages[i] == N + 1) cur_pass++;</p>
<p>else break;</p>
<p>}</p>
<p>double cur_stage = 0;</p>
<p>for (i; i &gt;= 0;) {</p>
<p>if (stages[i] == N) {</p>
<p>cur_stage++;</p>
<p>if (i == 0) {</p>
<p>cur_pass += cur_stage;</p>
<p>failure[N] = cur_stage / cur_pass;</p>
<p>break;</p>
<p>}</p>
<p>i--;</p>
<p>}</p>
<p>else {</p>
<p>cur_pass += cur_stage;</p>
<p>failure[N] = cur_stage / cur_pass;</p>
<p>N--;</p>
<p>cur_stage = 0;</p>
<p>}</p>
<p>}</p>
<p>vector&lt;int&gt; answer= makeOrder(failure, vector&lt;int&gt;{});</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>solution(5, { 2, 1, 2, 6, 2, 4, 3, 3 });</p>
<p>return 0;</p>
<p>}</p>
<p>[128. <strong>[Programmers– KAKAO 2019 :Candidate Key]]</strong></p>
<p>- it was fxxkcing difficult for me. Indeed, it was not that difficult. but I spent so much time.</p>
<p>- since I had to make all the possible combination first. it was okay even though I spent 1 hour or so.</p>
<p>- But to satisfy minimality, I had to remove duplicate keys, it took a lot of time.</p>
<p>- HOWEVER!!! the main problem that took so much time was!!!! I’ve read problem in a wrong way…</p>
<p>- I thought the problem want me to return maximum size of a possible cadidate key. Sadly, it wans’t.</p>
<p>- I just had to return the number of cadidate keys which is valid….</p>
<p>- oh my poor hand, brain, time… :(</p>
<p>- by the way, I used bitset to remove duplicates and BFS to make all the possible combination. when I made BFS, the queue structure was quite complex, since there were quite many condition.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#include&lt;bitset&gt;</p>
<p>#define max(a,b) a&gt;b ? a : b</p>
<p>using namespace std;</p>
<p>int n; int m;</p>
<p>vector&lt;vector&lt;int&gt;&gt; valid;</p>
<p>vector&lt;vector&lt;int&gt;&gt; all;</p>
<p>bool isValid(vector&lt;string&gt; temp) {</p>
<p>unordered_set&lt;string&gt; check;</p>
<p>for (int i = 0; i &lt; temp.size(); i++)</p>
<p>check.insert(temp[i]);</p>
<p>//cout &lt;&lt; &quot;size : &quot; &lt;&lt; check.size() &lt;&lt; endl;</p>
<p>if (check.size() == n) return true;</p>
<p>return false;</p>
<p>}</p>
<p>void Combination(vector&lt;vector&lt;string&gt;&gt; table) {</p>
<p>queue&lt;pair&lt;vector&lt;string&gt;,pair&lt;vector&lt;int&gt;,int&gt;&gt;&gt; que;</p>
<p>for (int i = 0; i &lt; table.size(); i++) {</p>
<p>que.push(make_pair(table[i], make_pair(vector&lt;int&gt;{ i },i+1)));</p>
<p>}</p>
<p>while (!que.empty()) {</p>
<p>vector&lt;string&gt; temp = que.front().first;</p>
<p>vector&lt;int&gt; indice = que.front().second.first;</p>
<p>int start = que.front().second.second;</p>
<p>que.pop();</p>
<p>/*cout &lt;&lt; &quot;indice : &quot;;</p>
<p>for (int i : indice)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>for (string s : temp)</p>
<p>cout &lt;&lt; s &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;*/</p>
<p>if (isValid(temp)) valid.push_back(indice);</p>
<p>all.push_back(indice);</p>
<p>for (int i = start; i &lt; m; i++) {</p>
<p>vector&lt;string&gt; temp_table = temp;</p>
<p>vector&lt;int&gt; temp_indice = indice;</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>temp_table[j] +=&quot; &quot;+ table[i][j];</p>
<p>}</p>
<p>temp_indice.push_back(i);</p>
<p>que.push(make_pair(temp_table, make_pair(temp_indice, i + 1)));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void printValid() {</p>
<p>for (vector&lt;int&gt; row : valid) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void printAll() {</p>
<p>for (vector&lt;int&gt; row : all) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>void Minimalize() {</p>
<p>vector&lt;bitset&lt;20&gt;&gt; bits(valid.size());</p>
<p>for (int i = 0; i &lt; valid.size(); i++) {</p>
<p>for (int j = 0; j &lt; valid[i].size(); j++) {</p>
<p>bits[i][valid[i][j]] = 1;</p>
<p>}</p>
<p>}</p>
<p>for (int i = 0; i &lt; bits.size();i++) {</p>
<p>bitset&lt;20&gt; cur_bit = bits[i];</p>
<p>for (int j = i + 1; j &lt; bits.size();) {</p>
<p>bitset&lt;20&gt; temp = cur_bit &amp; bits[j];</p>
<p>if (temp == cur_bit) {</p>
<p>valid.erase(next(valid.begin(), j));</p>
<p>bits.erase(next(bits.begin(), j));</p>
<p>}</p>
<p>else j++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int solution(vector&lt;vector&lt;string&gt;&gt; relation) {</p>
<p>n = relation.size();</p>
<p>m = relation[0].size();</p>
<p>vector&lt;vector&lt;string&gt;&gt; table(m);</p>
<p>for (int j = 0; j &lt; m; j++) {</p>
<p>vector&lt;string&gt; temp;</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>temp.push_back(relation[i][j]);</p>
<p>}</p>
<p>table[j] = temp;</p>
<p>}</p>
<p>Combination(table);</p>
<p>Minimalize();</p>
<p>int answer = 0;</p>
<p>return valid.size();</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution({</p>
<p>{&quot;100&quot;, &quot;ryan&quot;, &quot;music&quot;, &quot;2&quot;},</p>
<p>{&quot;200&quot;, &quot;apeach&quot;, &quot;math&quot;, &quot;2&quot;},</p>
<p>{&quot;300&quot;, &quot;tube&quot;, &quot;computer&quot;, &quot;3&quot;},</p>
<p>{&quot;400&quot;, &quot;con&quot;, &quot;computer&quot;, &quot;4&quot;},</p>
<p>{&quot;500&quot;, &quot;muzi&quot;, &quot;music&quot;, &quot;3&quot;},</p>
<p>{&quot;600&quot;, &quot;apeach&quot;, &quot;music&quot;, &quot;2&quot;}} );</p>
<p>return 0;</p>
<p>}</p>
<p>[129. <strong>[Programmers– KAKAO 2019 :Muji’s Muckbang Live]]</strong></p>
<p>- this problem has efficiency test as well.</p>
<p>- as you guess, I passed accuracy tests but not efficiency tests.</p>
<p>- below code is the code passing accuracy tests.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;map&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; ReduceNumber(vector&lt;int&gt; food_times,int eat_number) {</p>
<p>for (long i = 0; i &lt; food_times.size(); i++) {</p>
<p>if (food_times[i] == 0) continue;</p>
<p>else food_times[i] -= eat_number;</p>
<p>}</p>
<p>return food_times;</p>
<p>}</p>
<p>void printTable(vector&lt;int&gt; food_times) {</p>
<p>for (int i : food_times)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl&lt;&lt;endl;</p>
<p>}</p>
<p>int solution(vector&lt;int&gt; food_times, long long k) {</p>
<p>int answer = 0;</p>
<p>int rest_food = food_times.size();</p>
<p>long long cur_index = 0;</p>
<p>long long eat_number = 0;</p>
<p>map&lt;long long, int&gt; min_table;</p>
<p>for (int i = 0; i &lt; food_times.size(); i++) min_table[food_times[i]] += 1;</p>
<p>map&lt;long long, int&gt;::iterator iter = min_table.begin();</p>
<p>long long min_food = iter-&gt;first;</p>
<p>int min_food_size = iter-&gt;second;</p>
<p>long long accumulated_eat_number = 0;</p>
<p>//cout &lt;&lt; &quot;Begining&quot; &lt;&lt; endl;</p>
<p>//printTable(food_times);</p>
<p>while (true) {</p>
<p>if (k &gt;= rest_food) {</p>
<p>eat_number++;</p>
<p>k -= rest_food;</p>
<p>if (eat_number == min_food) {</p>
<p>accumulated_eat_number += eat_number;</p>
<p>food_times = ReduceNumber(food_times, eat_number);</p>
<p>//printTable(food_times);</p>
<p>rest_food -= min_food_size;</p>
<p>iter++;</p>
<p>eat_number = 0;</p>
<p>if (iter != min_table.end()) {</p>
<p>min_food = iter-&gt;first-accumulated_eat_number;</p>
<p>//cout &lt;&lt; &quot;next min_food : &quot; &lt;&lt; min_food &lt;&lt; endl;</p>
<p>min_food_size = iter-&gt;second;</p>
<p>}</p>
<p>else {</p>
<p>//cout &lt;&lt; &quot;여기 처리&quot; &lt;&lt; endl;</p>
<p>return -1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>long long i;</p>
<p>if(eat_number) food_times=ReduceNumber(food_times, eat_number);</p>
<p>//cout &lt;&lt; &quot;&lt;&lt;Last Traversal&gt;&gt;&quot;&lt;&lt; endl;</p>
<p>//cout &lt;&lt; &quot; - Remain k : &quot; &lt;&lt; k &lt;&lt; &quot; - Remain eat_number : &quot; &lt;&lt; eat_number &lt;&lt; endl;</p>
<p>//printTable(food_times);</p>
<p>for (i = 0; i &lt;food_times.size() &amp;&amp; k&gt;0; i++) {</p>
<p>if (food_times[i] == 0) continue;</p>
<p>else {</p>
<p>food_times[i]--;</p>
<p>k--;</p>
<p>}</p>
<p>}</p>
<p>//cout &lt;&lt; &quot;!!!Final!!!&quot; &lt;&lt; endl;</p>
<p>//printTable(food_times);</p>
<p>cur_index = i%food_times.size();</p>
<p>bool flag = true;</p>
<p>for (long i = cur_index; i &lt; food_times.size(); i++) if (food_times[i]) { cur_index = i; flag = false; break; }</p>
<p>if (flag) for (long i = 0; i &lt; food_times.size(); i++) if (food_times[i]) { cur_index = i; flag = false; break; }</p>
<p>if (flag &amp;&amp; i == food_times.size()) return -1;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>return cur_index+1;</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution({ 1,2,3},1);</p>
<p>return 0;</p>
<p>}</p>
<p>- Let’s find another algorithm to pass efficiency test!</p>
<p>- I refered to a site to pass the efficiency tests.</p>
<p>- there are so many geinous…. the point is I don’t need to reduce food’s count. just sort with indice and if Muji can eat a current minimum food, find next food, and so on…</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;bitset&gt;</p>
<p>using namespace std;</p>
<p>int solution(vector&lt;int&gt; foods, long long k) {</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; food_times;</p>
<p>for (int i = 0; i &lt; foods.size(); i++) food_times.push_back(make_pair(foods[i], i + 1));</p>
<p>int fs = foods.size();</p>
<p>sort(food_times.begin(), food_times.end());</p>
<p>long long accumulated_min_food=0;</p>
<p>for (vector&lt;pair&lt;int, int&gt;&gt;::iterator iter = food_times.begin(); iter != food_times.end(); iter++) {</p>
<p>long long min_food = (long long)(iter-&gt;first - accumulated_min_food) * fs;</p>
<p>if (min_food == 0) {</p>
<p>fs--;</p>
<p>continue;</p>
<p>}</p>
<p>else if (min_food &lt;= k) {</p>
<p>k -= min_food;</p>
<p>accumulated_min_food = iter-&gt;first;</p>
<p>fs--;</p>
<p>}</p>
<p>else {</p>
<p>k %= fs;</p>
<p>sort(iter, food_times.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {return a.second &lt; b.second; });</p>
<p>return (iter + k)-&gt;second;</p>
<p>}</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution({10,6,4,3,2,5,15,9,6,5,4,3,2},60);</p>
<p>return 0;</p>
<p>}</p>
<p>[130. <strong>[Programmers– KAKAO 2019 :Finding Path Game]]</strong></p>
<p>- this problem’s point was the way to make tree.</p>
<p>- I spent 3 hours or so to make tree.</p>
<p>- I have been stuck since I barely came up with a method to make tree. the given vector sholud be splited before making tree.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; preorder;</p>
<p>vector&lt;int&gt; postorder;</p>
<p>struct Node {</p>
<p>int x;</p>
<p>int y;</p>
<p>int index;</p>
<p>Node* left=nullptr;</p>
<p>Node* right=nullptr;</p>
<p>Node(int _x, int _y, int _index) {</p>
<p>x = _x; y = _y; index = _index;</p>
<p>};</p>
<p>~Node() {}</p>
<p>};</p>
<p>pair&lt;vector&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt;, vector&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt;&gt; LRSplit(vector&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt; table,int mid) {</p>
<p>vector &lt; pair&lt;vector&lt;int&gt;, int&gt;&gt; left;</p>
<p>vector &lt; pair&lt;vector&lt;int&gt;, int&gt;&gt; right;</p>
<p>for (int i = 0; i &lt; table.size(); i++) {</p>
<p>if (table[i].first[0] &lt; mid) left.push_back(table[i]);</p>
<p>else right.push_back(table[i]);</p>
<p>}</p>
<p>return make_pair(left, right);</p>
<p>}</p>
<p>void makeTree(Node* root,vector&lt;pair&lt;vector&lt;int&gt;,int&gt;&gt; table) {</p>
<p>table.erase(table.begin());</p>
<p>if (table.empty()) return;</p>
<p>pair&lt;vector&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt;, vector&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt;&gt; splited = LRSplit(table, root-&gt;x);</p>
<p>vector &lt; pair&lt;vector&lt;int&gt;, int&gt;&gt; left = splited.first;</p>
<p>vector &lt; pair&lt;vector&lt;int&gt;, int&gt;&gt; right = splited.second;</p>
<p>if(!left.empty())root-&gt;left = new Node(left[0].first[0], left[0].first[1], left[0].second);</p>
<p>if(!right.empty())root-&gt;right = new Node(right[0].first[0], right[0].first[1], right[0].second);</p>
<p>if(root-&gt;left) makeTree(root-&gt;left, left);</p>
<p>if(root-&gt;right) makeTree(root-&gt;right, right);</p>
<p>}</p>
<p>void printTree(vector &lt; pair&lt;vector&lt;int&gt;, int&gt;&gt; tree) {</p>
<p>for (int i = 0; i &lt; tree.size(); i++) {</p>
<p>cout &lt;&lt; tree[i].first[0] &lt;&lt; &quot;,&quot; &lt;&lt; tree[i].first[1] &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void PreOrderSearch(Node* root) {</p>
<p>if (!root) return;</p>
<p>preorder.push_back(root-&gt;index);</p>
<p>PreOrderSearch(root-&gt;left);</p>
<p>PreOrderSearch(root-&gt;right);</p>
<p>}</p>
<p>void PostOrderSearch(Node* root) {</p>
<p>if (!root) return;</p>
<p>PostOrderSearch(root-&gt;left);</p>
<p>PostOrderSearch(root-&gt;right);</p>
<p>postorder.push_back(root-&gt;index);</p>
<p>}</p>
<p>void printAnswer(vector&lt;vector&lt;int&gt;&gt;&amp; answer) {</p>
<p>for (vector&lt;int&gt; row : answer) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; solution(vector&lt;vector&lt;int&gt;&gt; nodeinfo) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; answer;</p>
<p>vector&lt;pair&lt;vector&lt;int&gt;, int&gt;&gt; table;</p>
<p>for (int i = 0; i &lt; nodeinfo.size(); i++) table.push_back(make_pair(nodeinfo[i], i + 1));</p>
<p>sort(table.begin(), table.end(), [](pair&lt;vector&lt;int&gt;, int&gt; a, pair&lt;vector&lt;int&gt;, int&gt; b) {return a.first[1] &gt; b.first[1];}); //y first sort</p>
<p>Node* root = new Node(table[0].first[0], table[0].first[1], table[0].second);</p>
<p>makeTree(root, table);</p>
<p>PreOrderSearch(root);</p>
<p>PostOrderSearch(root);</p>
<p>answer.push_back(preorder);</p>
<p>answer.push_back(postorder);</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>solution({{5, 3}, {11, 5}, {13, 3}, {3, 5}, {6, 1}, {1, 3}, {8, 6}, {7, 2}, {2, 2}} );</p>
<p>return 0;</p>
<p>}</p>
<p>[131. <strong>[Programmers– KAKAO 2019 :Matching Score]]</strong></p>
<p>- I hate fucking parsing string!!! there is too many condition to check.</p>
<p>- I spent almost 4 hour to parse this fucking problem.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;sstream&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>map&lt;string, pair&lt;unordered_set&lt;string&gt;,vector&lt;int&gt;&gt;&gt; links; // URL - &lt;{in links},{base,out links,index}&gt;</p>
<p>vector&lt;string&gt; URL_list;</p>
<p>vector&lt;string&gt; Lower(vector&lt;string&gt; pages) {</p>
<p>for (int i = 0; i &lt; pages.size(); i++) {</p>
<p>std::transform(pages[i].begin(), pages[i].end(), pages[i].begin(), ::tolower);</p>
<p>}</p>
<p>return pages;</p>
<p>}</p>
<p>string RemoveDelimeter(string s) {</p>
<p>for (int i = 0; i &lt; s.size(); i++) {</p>
<p>if ('a' &lt;= s[i] &amp;&amp; s[i] &lt;= 'z') continue;</p>
<p>else s[i] = ' ';</p>
<p>}</p>
<p>return s;</p>
<p>}</p>
<p>vector&lt;int&gt; FindWord(vector&lt;string&gt; pages,string word) {</p>
<p>vector&lt;int&gt; baseScore(pages.size(),0);</p>
<p>int i = 0;</p>
<p>for (string s : pages) {</p>
<p>s = RemoveDelimeter(s);</p>
<p>stringstream ss(s);</p>
<p>string token;</p>
<p>while (getline(ss, token,' ')){</p>
<p>if (token == word) baseScore[i]++;</p>
<p>}</p>
<p>i++;</p>
<p>}</p>
<p>return baseScore;</p>
<p>}</p>
<p>void printPage(string s) {</p>
<p>cout &lt;&lt; s &lt;&lt; endl;</p>
<p>}</p>
<p>void GetURL(vector&lt;string&gt; pages) {</p>
<p>for (int i = 0; i &lt; pages.size(); i++) {</p>
<p>string cur_URL = &quot;&quot;;</p>
<p>string now = pages[i];</p>
<p>while (cur_URL == &quot;&quot;) {</p>
<p>int start = now.find(&quot;&lt;meta&quot;) + 5;</p>
<p>now = now.substr(start);</p>
<p>int last = now.find(&quot;&gt;&quot;);</p>
<p>start = now.find(&quot;https://&quot;);</p>
<p>if (start &gt; last) continue;</p>
<p>now = now.substr(start);</p>
<p>stringstream ss(now);</p>
<p>string token;</p>
<p>getline(ss, token, '\&quot;');</p>
<p>cur_URL = token;</p>
<p>URL_list.push_back(cur_URL);</p>
<p>links[cur_URL] = make_pair(unordered_set&lt;string&gt;{}, vector&lt;int&gt;{0, 0, i});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void GetLinks(vector&lt;string&gt; pages) {</p>
<p>for (int i = 0; i &lt; pages.size(); i++) {</p>
<p>string now = pages[i];</p>
<p>string cur_URL = URL_list[i];</p>
<p>int start = now.find(&quot;&lt;body&gt;&quot;);</p>
<p>int last = now.find(&quot;&lt;/body&gt;&quot;);</p>
<p>now = now.substr(start, last - start + 7); //partition of body tag.</p>
<p>while(true) {</p>
<p>start = now.find(&quot;&lt;a href&quot;);</p>
<p>if (start == string::npos) break;</p>
<p>now = now.substr(start);</p>
<p>start = 0;</p>
<p>last = now.find(&quot;&gt;&quot;);</p>
<p>if (start &gt; last) break;</p>
<p>start = now.find(&quot;https://&quot;);</p>
<p>if (start != string::npos) links[cur_URL].second[1]++; //outer ++</p>
<p>now = now.substr(start);</p>
<p>stringstream ss(now);</p>
<p>string token;</p>
<p>getline(ss, token, '\&quot;');</p>
<p>if (links.find(token) != links.end()) links[token].first.insert(cur_URL);</p>
<p>};</p>
<p>}</p>
<p>}</p>
<p>double GetLinkScore(unordered_set&lt;string&gt; inLinks) {</p>
<p>unordered_set&lt;string&gt;::iterator iter = inLinks.begin();</p>
<p>double sum = 0;</p>
<p>for (; iter != inLinks.end(); iter++) {</p>
<p>//cout &lt;&lt; links[*iter].second[0] &lt;&lt; &quot;,&quot; &lt;&lt; links[*iter].second[1] &lt;&lt; endl;</p>
<p>//cout &lt;&lt; &quot;result : &quot; &lt;&lt; double(links[*iter].second[0]) / double(links[*iter].second[1]) &lt;&lt; endl;</p>
<p>sum+=double(links[*iter].second[0]) / double(links[*iter].second[1]);</p>
<p>}</p>
<p>//cout &lt;&lt; sum &lt;&lt; endl;</p>
<p>return sum;</p>
<p>}</p>
<p>void printLinks() {</p>
<p>for (auto iter = links.begin(); iter != links.end(); iter++) {</p>
<p>cout &lt;&lt; &quot;URL : &quot; &lt;&lt; iter-&gt;first &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot; base score : &quot; &lt;&lt; iter-&gt;second.second[0];</p>
<p>cout &lt;&lt; &quot; out links : &quot; &lt;&lt; iter-&gt;second.second[1];</p>
<p>cout &lt;&lt; &quot; in links : &quot;;</p>
<p>for (auto iter2 = iter-&gt;second.first.begin(); iter2 != iter-&gt;second.first.end(); iter2++) {</p>
<p>cout &lt;&lt; *iter2 &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl &lt;&lt; endl;;</p>
<p>}</p>
<p>}</p>
<p>int solution(string word, vector&lt;string&gt; pages) {</p>
<p>//for (string s : pages) printPage(s);</p>
<p>int answer = 0;</p>
<p>transform(word.begin(), word.end(), word.begin(), ::tolower);</p>
<p>pages = Lower(pages); // make it lowercase</p>
<p>vector&lt;int&gt; baseScore=FindWord(pages,word); // get base score</p>
<p>GetURL(pages);</p>
<p>GetLinks(pages);</p>
<p>map&lt;string, pair&lt;unordered_set&lt;string&gt;, vector&lt;int&gt;&gt;&gt;::iterator iter = links.begin();</p>
<p>for (; iter != links.end(); iter++) iter-&gt;second.second[0] = baseScore[iter-&gt;second.second[2]];</p>
<p>//printLinks();</p>
<p>vector&lt;pair&lt;int,double&gt;&gt; res(pages.size());//index, sum of score;</p>
<p>iter = links.begin();</p>
<p>for (int i = 0; iter != links.end();i++, iter++) {</p>
<p>res[i] = make_pair(iter-&gt;second.second[2], iter-&gt;second.second[0] + GetLinkScore(iter-&gt;second.first));</p>
<p>}</p>
<p>sort(res.begin(), res.end(), [](pair&lt;int, double&gt; a, pair&lt;int, double&gt; b) { return a.second &gt; b.second; });</p>
<p>double maximum = res[0].second;</p>
<p>int index=res[0].first;</p>
<p>for (int i = 0; i &lt; res.size(); i++) {</p>
<p>if (res[i].second != maximum) break;</p>
<p>index = min(index, res[i].first);</p>
<p>}</p>
<p>return index;</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution(&quot;blind&quot;,{ &quot;&lt;html lang=\&quot;ko\&quot; xml:lang=\&quot;ko\&quot; xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&lt;head&gt;\n &lt;meta charset=\&quot;utf-8\&quot;&gt;\n &lt;meta property=\&quot;og:url\&quot; content=\&quot;https://a.com\&quot;/&gt;\n&lt;/head&gt; \n&lt;body&gt;\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \n&lt;a href=\&quot;https://b.com\&quot;&gt; Link to b &lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot;, &quot;&lt;html lang=\&quot;ko\&quot; xml:lang=\&quot;ko\&quot; xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&lt;head&gt;\n &lt;meta charset=\&quot;utf-8\&quot;&gt;\n &lt;meta property=\&quot;og:url\&quot; content=\&quot;https://b.com\&quot;/&gt;\n&lt;/head&gt; \n&lt;body&gt;\nSuspendisse potenti. Vivamus venenatis tellus non turpis bibendum, \n&lt;a href=\&quot;https://a.com\&quot;&gt; Link to a &lt;/a&gt;\nblind sed congue urna varius. Suspendisse feugiat nisl ligula, quis malesuada felis hendrerit ut.\n&lt;a href=\&quot;https://c.com\&quot;&gt; Link to c &lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot;, &quot;&lt;html lang=\&quot;ko\&quot; xml:lang=\&quot;ko\&quot; xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&lt;head&gt;\n &lt;meta charset=\&quot;utf-8\&quot;&gt;\n &lt;meta property=\&quot;og:url\&quot; content=\&quot;https://c.com\&quot;/&gt;\n&lt;/head&gt; \n&lt;body&gt;\nUt condimentum urna at felis sodales rutrum. Sed dapibus cursus diam, non interdum nulla tempor nec. Phasellus rutrum enim at orci consectetu blind\n&lt;a href=\&quot;https://a.com\&quot;&gt; Link to a &lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot; })&lt;&lt;endl;</p>
<p>//cout &lt;&lt; solution(&quot;Muzi&quot;, { &quot;&lt;html lang=\&quot;ko\&quot; xml:lang=\&quot;ko\&quot; xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&lt;head&gt;\n &lt;meta charset=\&quot;utf-8\&quot;&gt;\n &lt;meta property=\&quot;og:url\&quot; content=\&quot;https://careers.kakao.com/interview/list\&quot;/&gt;\n&lt;/head&gt; \n&lt;body&gt;\n&lt;a href=\&quot;https://programmers.co.kr/learn/courses/4673\&quot;&gt;&lt;/a&gt;#!MuziMuzi!)jayg07con&amp;&amp;\n\n&lt;/body&gt;\n&lt;/html&gt;&quot;, &quot;&lt;html lang=\&quot;ko\&quot; xml:lang=\&quot;ko\&quot; xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\n&lt;head&gt;\n &lt;meta charset=\&quot;utf-8\&quot;&gt;\n &lt;meta property=\&quot;og:url\&quot; content=\&quot;https://www.kakaocorp.com\&quot;/&gt;\n&lt;/head&gt; \n&lt;body&gt;\ncon%\tmuzI92apeach&amp;2&lt;a href=\&quot;https://hashcode.co.kr/tos\&quot;&gt;&lt;/a&gt;\n\n\t^\n&lt;/body&gt;\n&lt;/html&gt;&quot; })&lt;&lt;endl;</p>
<p>return 0;</p>
<p>}</p>
<p>[132. <strong>[Programmers– KAKAO 2019 :Block Game]]</strong></p>
<p>- Even though it was level 4 problem, it was easy for me.</p>
<p>- I was happy it was not a fucking string parsing :)</p>
<p>- the reason why this problem was easy is there is no time limitation. so I can use some functions roughly and repeatedly.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>#define max(a,b) a&gt;b ? a:b</p>
<p>using namespace std;</p>
<p>int res = 0;</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>bool isRectangular(vector&lt;vector&lt;int&gt;&gt;&amp; table,int tx,int ty,int bx,int by,int block) {</p>
<p>if (bx == tx &amp;&amp; by == ty) return false;</p>
<p>//cout &lt;&lt; &quot;변환 전 : &quot; &lt;&lt; block &lt;&lt; endl;</p>
<p>//cout &lt;&lt; tx &lt;&lt; ty &lt;&lt; &quot; , &quot; &lt;&lt; bx &lt;&lt; by &lt;&lt; endl;</p>
<p>//printTable(table);</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp = table;</p>
<p>for (int i = tx; i &lt;= bx; i++) {</p>
<p>for (int j = ty; j &lt;= by; j++) {</p>
<p>if (block != temp[i][j]) {</p>
<p>//cout &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;,&quot;&lt;&lt;temp[i][j] &lt;&lt; endl;</p>
<p>return false;</p>
<p>}</p>
<p>temp[i][j] = 0;</p>
<p>}</p>
<p>}</p>
<p>//cout &lt;&lt; &quot;변환 후 : &quot;&lt;&lt;block &lt;&lt; endl;</p>
<p>//printTable(temp);</p>
<p>table = temp;</p>
<p>res++;</p>
<p>return true;</p>
<p>}</p>
<p>void SetInformation(vector&lt;vector&lt;int&gt;&gt; board, int bs, vector&lt;int&gt;&amp; top,vector&lt;int&gt;&amp; height,map&lt;int,int&gt;&amp; blocks_top) {</p>
<p>for (int i = bs - 1; i &gt;= 0; i--) {</p>
<p>for (int j = 0; j &lt; bs; j++) {</p>
<p>if (board[i][j] == 0) continue;</p>
<p>blocks_top[board[i][j]] = i;</p>
<p>top[j] = board[i][j];</p>
<p>height[j] = i;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void getLimit(int&amp; tx, int&amp; ty, int&amp; bx, int&amp; by, int block,vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>for (int i = 0; i &lt; table.size(); i++) {</p>
<p>for (int j = 0; j &lt; table[i].size(); j++) {</p>
<p>if (table[i][j] == block) {</p>
<p>tx = min(tx, i); ty = min(ty, j); bx = max(bx, i); by = max(by, j);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int solution(vector&lt;vector&lt;int&gt;&gt; board) {</p>
<p>int answer = 0;</p>
<p>int bs = board.size();</p>
<p>vector&lt;int&gt; top(bs, 0); //a columns top block</p>
<p>vector&lt;int&gt; height(bs, 0); // a columns top height</p>
<p>map&lt;int, int&gt; blocks_top; // block number - the block's top height;</p>
<p>SetInformation(board, bs, top, height,blocks_top);</p>
<p>for (map&lt;int, int&gt;::iterator iter = blocks_top.begin(); iter != blocks_top.end();) {</p>
<p>int tx=999, ty=999, bx=-1, by=-1;</p>
<p>int cur_block = iter-&gt;first;</p>
<p>vector&lt;vector&lt;int&gt;&gt; cur_table = board;</p>
<p>for (int j = 0; j &lt; bs; j++) {</p>
<p>if (top[j] == cur_block &amp;&amp; height[j] &gt; iter-&gt;second) {</p>
<p>for (int i = height[j] - 1; i &gt;= iter-&gt;second; i--) {</p>
<p>cur_table[i][j] = cur_block;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>getLimit(tx, ty, bx, by, cur_block, cur_table); // get the block's boundary</p>
<p>if (isRectangular(cur_table, tx, ty, bx, by, cur_block)) { //check if the block is rectangular</p>
<p>board = cur_table;</p>
<p>blocks_top.erase(cur_block); //if it is rectangular, remove that blcok from the board.</p>
<p>SetInformation(board, bs, top, height, blocks_top); //reset the information.</p>
<p>iter = blocks_top.begin();</p>
<p>}</p>
<p>else iter++;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; solution({</p>
<p>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</p>
<p>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</p>
<p>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</p>
<p>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</p>
<p>{0, 0, 0, 0, 0, 0, 4, 0, 0, 0},</p>
<p>{0, 0, 0, 0, 0, 4, 4, 0, 0, 0},</p>
<p>{0, 0, 0, 0, 3, 0, 4, 0, 0, 0},</p>
<p>{0, 0, 0, 2, 3, 0, 0, 0, 5, 5},</p>
<p>{1, 2, 2, 2, 3, 3, 0, 0, 0, 5},</p>
<p>{1, 1, 1, 0, 0, 0, 0, 0, 0, 5}} );</p>
<p>return 0;</p>
<p>}</p>
<p>[133. <strong>[Programmers– KAKAO 2018 :Harvest Fest Traffic]]</strong></p>
<p>- time handling is the key of this problem.</p>
<p>- finding an efficient algorithm for maximum number of traffic during one second was quite hard but not a terrible.</p>
<p>- but handling time was terrible. First, I handle hour, minute, sec respectively. but I didn’t need that complexity. so I convert all the thing to second. I mean, hour * 3600000, min * 60000, sec* 1000.</p>
<p>since, they gave second to 3 decimal places.</p>
<p>- the finding algorithm I mentioned avobe is below</p>
<p>&gt; 1. take a end time of traffic.</p>
<p>&gt; 2. add 1 sec.</p>
<p>&gt; 3. iterate all the traffic and check there is traffic between the duration.</p>
<p>- see the code. p.s) I didn’t use visual studio for this problem. so there is no color :)</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;sstream&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; Input(vector&lt;string&gt;&amp; lines){</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; date(lines.size());</p>
<p>for(int i=0;i&lt;lines.size();i++){</p>
<p>stringstream ss(lines[i]);</p>
<p>string hour; string min; string sec;string process;</p>
<p>getline(ss,hour,' ');//remove date</p>
<p>getline(ss,hour,':'); getline(ss,min,':'); getline(ss,sec,' '); getline(ss,process,'s');</p>
<p>date[i].second=stod(hour)*3600000 + stod(min)*60000 + stod(sec)*1000;</p>
<p>date[i].first=date[i].second-stod(process)*1000+1;</p>
<p>}</p>
<p>return date;</p>
<p>}</p>
<p>int findNumber(vector&lt;pair&lt;int,int&gt;&gt; res){</p>
<p>vector&lt;int&gt; table(res.size());</p>
<p>for(int i=0;i&lt;res.size();i++){</p>
<p>int start=res[i].second;</p>
<p>int end=res[i].second+999;</p>
<p>for(int j=i;j&lt;res.size();j++){</p>
<p>if(res[j].second&lt;start || end&lt;res[j].first) continue;</p>
<p>table[i]++;</p>
<p>}</p>
<p>}</p>
<p>return *max_element(table.begin(),table.end());</p>
<p>}</p>
<p>int solution(vector&lt;string&gt; lines) {</p>
<p>int answer = 0;</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; date;</p>
<p>date=Input(lines);</p>
<p>answer=findNumber(date);</p>
<p>return answer;</p>
<p>}</p>
<p>[134. <strong>[Programmers– KAKAO 2018 :News Clustering]]</strong></p>
<p>- it was just string parsing and make intersection and union set. so not that hard.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>#define max(a,b) a&gt;b? a:b</p>
<p>using namespace std;</p>
<p>bool isAlpha(char&amp; s){</p>
<p>if('a'&lt;= s &amp;&amp; s&lt;='z') return true;</p>
<p>return false;</p>
<p>}</p>
<p>unordered_set&lt;string&gt; SplitStr(string s,unordered_map&lt;string,int&gt;&amp; count){</p>
<p>unordered_set&lt;string&gt; res;</p>
<p>for(int i=1;i&lt;s.size();i++){</p>
<p>string temp;</p>
<p>if(isAlpha(s[i-1]) &amp;&amp; isAlpha(s[i])){</p>
<p>temp=s.substr(i-1,2);</p>
<p>res.insert(temp);</p>
<p>count[temp]++;</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int solution(string str1, string str2) {</p>
<p>int answer = 0;</p>
<p>unordered_map&lt;string,int&gt; s1; unordered_map&lt;string,int&gt; s2;</p>
<p>transform(str1.begin(),str1.end(),str1.begin(),::tolower);</p>
<p>transform(str2.begin(),str2.end(),str2.begin(),::tolower);</p>
<p>unordered_set&lt;string&gt; a=SplitStr(str1,s1); unordered_set&lt;string&gt; b=SplitStr(str2,s2);</p>
<p>//find intersection</p>
<p>vector&lt;string&gt; inter;</p>
<p>int minimum;</p>
<p>for(unordered_set&lt;string&gt;::iterator iter=a.begin();iter!=a.end();iter++){</p>
<p>if(s2.find(*iter)!=s2.end()){</p>
<p>minimum=min(s1[*iter],s2[*iter]);</p>
<p>for(int j=0;j&lt;minimum;j++) inter.push_back(*iter);</p>
<p>}</p>
<p>}</p>
<p>//find union</p>
<p>vector&lt;string&gt; uni;</p>
<p>unordered_set&lt;string&gt; temp_set;</p>
<p>temp_set.insert(a.begin(),a.end()); temp_set.insert(b.begin(),b.end());</p>
<p>int maximum;</p>
<p>for(unordered_set&lt;string&gt;::iterator iter=temp_set.begin();iter!=temp_set.end();iter++){</p>
<p>if(s1.find(*iter)!=s1.end() &amp;&amp; s2.find(*iter)!=s2.end()){</p>
<p>maximum=max(s1[*iter],s2[*iter]);</p>
<p>for(int j=0;j&lt;maximum;j++) uni.push_back(*iter);</p>
<p>}</p>
<p>else if(s1.find(*iter)!=s1.end()) for(int j=0;j&lt;s1[*iter];j++) uni.push_back(*iter);</p>
<p>else if(s2.find(*iter)!=s2.end()) for(int j=0;j&lt;s2[*iter];j++) uni.push_back(*iter);</p>
<p>}</p>
<p>if(inter.empty() &amp;&amp; uni.empty()) return 65536;</p>
<p>answer=((double)inter.size()/(double)uni.size())*65536;</p>
<p>return answer;</p>
<p>}</p>
<p>[135. <strong>[BaekJoon– 1697 : Hide and Seek]]</strong></p>
<p>- it was just BFS problem, we just sholud be careful of memory using visit hash.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>int BFS(int n, int k) {</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que;</p>
<p>que.push(make_pair(n, 0));</p>
<p>//vector&lt;bool&gt; visit(100001,false);</p>
<p>unordered_map&lt;int, bool&gt; visit;</p>
<p>while (!que.empty()) {</p>
<p>int cur_pos = que.front().first;</p>
<p>int cur_sec = que.front().second;</p>
<p>visit[cur_pos] = true;</p>
<p>que.pop();</p>
<p>if (cur_pos == k) return cur_sec;</p>
<p>if (cur_pos + 1 &lt;= 100000 &amp;&amp; !visit[cur_pos+1]) que.push(make_pair(cur_pos + 1, cur_sec + 1));</p>
<p>if (cur_pos - 1 &gt;= 0 &amp;&amp; !visit[cur_pos-1]) que.push(make_pair(cur_pos - 1, cur_sec + 1));</p>
<p>if (cur_pos * 2 &lt;= 100000 &amp;&amp; !visit[cur_pos*2]) que.push(make_pair(cur_pos * 2, cur_sec + 1));</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>int n; int k;</p>
<p>cin &gt;&gt; n; cin &gt;&gt; k;</p>
<p>cout&lt;&lt;BFS(n, k);</p>
<p>return 0;</p>
<p>}</p>
<p>[136. <strong>[Programmers– KAKAO 2018 :Shuttle Bus]]</strong></p>
<p>- handling time is always naughty for me lol :).</p>
<p>- I changed all the bus schedule to unit of minute. &lt;- is this english right? haha.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>#include &lt;map&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>string solution(int n, int t, int m, vector&lt;string&gt; timetable) {</p>
<p>string answer = &quot;&quot;;</p>
<p>int base = 9*60;</p>
<p>vector&lt;pair&lt;int,vector&lt;int&gt;&gt;&gt; possible_time;</p>
<p>for(int i=0;i&lt;n;i++) possible_time.push_back(make_pair(base+(t*i),vector&lt;int&gt;{0,999999,-1}));</p>
<p>vector&lt;bool&gt; full_bus(possible_time.size(),false);</p>
<p>vector&lt;int&gt; min_table(timetable.size());</p>
<p>for(int i=0; i&lt;timetable.size();i++) min_table[i]=stoi(timetable[i].substr(0,2))*60 + stoi(timetable[i].substr(3,2));</p>
<p>sort(min_table.begin(),min_table.end());</p>
<p>int start=0;</p>
<p>for(int i=0;i&lt;possible_time.size();i++){</p>
<p>int bus_time = possible_time[i].first;</p>
<p>for(int j=start;j&lt;min_table.size();j++){</p>
<p>if(min_table[j]&lt;=bus_time){</p>
<p>possible_time[i].second[0]++;</p>
<p>possible_time[i].second[1]=min(possible_time[i].second[1],min_table[j]);</p>
<p>possible_time[i].second[2]=max(possible_time[i].second[2],min_table[j]);</p>
<p>if(possible_time[i].second[0]&gt;=m){ full_bus[i]=true; start=j+1; break; }</p>
<p>}</p>
<p>else { start=j; break; }</p>
<p>}</p>
<p>}</p>
<p>int res_time;</p>
<p>if(full_bus[n-1]){</p>
<p>if(possible_time[n-1].second[2]==possible_time[n-1].second[1]) res_time=possible_time[n-1].second[1]-1;</p>
<p>else res_time=possible_time[n-1].second[2]-1;</p>
<p>}</p>
<p>else{</p>
<p>res_time=possible_time[n-1].first;</p>
<p>}</p>
<p>string hour; string minute;</p>
<p>hour=to_string(res_time/60); minute=to_string(res_time%60);</p>
<p>if(hour.size()==1) hour=&quot;0&quot;+hour; if(minute.size()==1) minute=&quot;0&quot;+minute;</p>
<p>answer=hour+&quot;:&quot;+minute;</p>
<p>return answer;</p>
<p>}</p>
<p>[137. <strong>[Programmers– KAKAO 2018 :Friends 4 Blocks]]</strong></p>
<p>- it was a slicing problem.</p>
<p>- but the fucking confusing between m and n, I spend quite much time shit!</p>
<p>- From now, I’m gonna use height and length for m and n to prevent such a confusing situation.</p>
<p>- p.s) unordered_set looks not able to handle pair&lt;int,int&gt;. so I changed it to set.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;set&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; makeTable(int m,int n, vector&lt;string&gt; board){</p>
<p>vector&lt;vector&lt;char&gt;&gt; table(m,vector&lt;char&gt;(n));</p>
<p>for(int i=0;i&lt;m;i++)</p>
<p>for(int j=0;j&lt;n;j++)</p>
<p>table[i][j]=board[i][j];</p>
<p>return table;</p>
<p>}</p>
<p>set&lt;pair&lt;int,int&gt;&gt; findBlock(int m,int n, vector&lt;vector&lt;char&gt;&gt;&amp; table){</p>
<p>set&lt;pair&lt;int,int&gt;&gt; remove;</p>
<p>for(int i=1;i&lt;m;i++){</p>
<p>for(int j=1;j&lt;n;j++){ //slice</p>
<p>char c=table[i][j];</p>
<p>if(c==0) continue;</p>
<p>bool flag=true;</p>
<p>for(int a=i-1;a&lt;=i;a++){</p>
<p>for(int b=j-1;b&lt;=j;b++){</p>
<p>if(table[a][b]!=c){</p>
<p>flag=false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if(!flag) break;</p>
<p>}</p>
<p>if(flag){</p>
<p>for(int a=i-1;a&lt;=i;a++){</p>
<p>for(int b=j-1;b&lt;=j;b++){</p>
<p>remove.insert(make_pair(a,b));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return remove;</p>
<p>}</p>
<p>vector&lt;vector&lt;char&gt;&gt; newTable(int m, int n,vector&lt;vector&lt;char&gt;&gt; table){</p>
<p>for(int j=0;j&lt;n;j++){</p>
<p>//bool flag=true;</p>
<p>for(int i =m-1;i&gt;=0;i--){</p>
<p>if(table[i][j]!=0) continue;</p>
<p>for(int a=i-1;a&gt;=0;a--){</p>
<p>//if(a==0) flag=false;</p>
<p>if(table[a][j]==0) continue;</p>
<p>else{</p>
<p>table[i][j]=table[a][j];</p>
<p>table[a][j]=0;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>//if(!flag) break;</p>
<p>}</p>
<p>}</p>
<p>return table;</p>
<p>}</p>
<p>int Game(int m,int n, vector&lt;vector&lt;char&gt;&gt; table){</p>
<p>set&lt;pair&lt;int,int&gt;&gt; remove_index;</p>
<p>int count=0;</p>
<p>while(true){</p>
<p>//find block</p>
<p>remove_index=findBlock(m,n,table);</p>
<p>if(remove_index.empty()) break;</p>
<p>count+=remove_index.size();</p>
<p>//remove block</p>
<p>for(set&lt;pair&lt;int,int&gt;&gt;::iterator iter=remove_index.begin();iter!=remove_index.end();iter++){</p>
<p>int x=iter-&gt;first; int y = iter-&gt;second;</p>
<p>table[x][y]=0;</p>
<p>}</p>
<p>//make new table;</p>
<p>table=newTable(m,n,table);</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>int solution(int m, int n, vector&lt;string&gt; board) {</p>
<p>int answer = 0;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table=makeTable(m,n,board);</p>
<p>answer=Game(m,n,table);</p>
<p>return answer;</p>
<p>}</p>
<p>[138. <strong>[Programmers– KAKAO 2018 :Cache]]</strong></p>
<p>- Honestly. it was shame I couldn’t solve this problem directly due to LRU.</p>
<p>- Making LRU is quite fresh in a bad way. so I spent 20~30 minutes.</p>
<p>- see the code.</p>
<p>#include &lt;cstring&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int solution(int cacheSize, vector&lt;string&gt; cities) {</p>
<p>if(cacheSize==0) return cities.size()*5;</p>
<p>int answer = 0;</p>
<p>//tolower</p>
<p>for(int i=0;i&lt;cities.size();i++) transform(cities[i].begin(),cities[i].end(),cities[i].begin(),::tolower);</p>
<p>//make cache</p>
<p>vector&lt;string&gt; res;</p>
<p>for(int i=0;i&lt;cities.size();i++){</p>
<p>vector&lt;string&gt;::iterator iter=find(res.begin(),res.end(),cities[i]);</p>
<p>//if cache doesn't have current city.</p>
<p>if(iter==res.end()){</p>
<p>answer+=5;</p>
<p>res.push_back(cities[i]);</p>
<p>if(res.size()&gt;cacheSize) res.erase(res.begin());</p>
<p>}</p>
<p>//when cache has the city.</p>
<p>else{</p>
<p>answer++;</p>
<p>res.erase(iter);</p>
<p>res.push_back(cities[i]);</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[139. <strong>[Programmers– KAKAO 2018 :Secret Map]]</strong></p>
<p>- Handling bitset is the main point of this problem.</p>
<p>- So It was easy for me :)</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;bitset&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;string&gt; solution(int n, vector&lt;int&gt; arr1, vector&lt;int&gt; arr2) {</p>
<p>vector&lt;string&gt; answer;</p>
<p>vector&lt;bitset&lt;16&gt;&gt; table;</p>
<p>for(int i=0;i&lt;n;i++){</p>
<p>bitset&lt;16&gt; a; bitset&lt;16&gt; b;</p>
<p>a=arr1[i]; b=arr2[i];</p>
<p>table.push_back(a|b);</p>
<p>}</p>
<p>for(int i=0;i&lt;table.size();i++){</p>
<p>string temp=&quot;&quot;;</p>
<p>for(int j=n-1;j&gt;=0;j--){</p>
<p>if(table[i][j]==1) temp+=&quot;#&quot;;</p>
<p>else temp+=&quot; &quot;;</p>
<p>}</p>
<p>answer.push_back(temp);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>[140. <strong>[Programmers– KAKAO 2018 :Dart Game]]</strong></p>
<p>- String parsing and caculate using given rule is the way to solve this problem.</p>
<p>- parsing part was pretty naughty. since I had to check all the index of the string. but given string was short. So I could follow where an index is and there was no time issue either.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int solution(string dartResult) {</p>
<p>vector&lt;string&gt; res;</p>
<p>string temp=&quot;&quot;;</p>
<p>//string parsing to make vector</p>
<p>for(int i=0;i&lt;dartResult.size();i++){</p>
<p>if('0'&lt;=dartResult[i] &amp;&amp; dartResult[i]&lt;='9'){</p>
<p>temp+=dartResult[i];</p>
<p>}</p>
<p>else{</p>
<p>temp+=dartResult[i];</p>
<p>if(dartResult[i+1]=='*' || dartResult[i+1]=='#'){</p>
<p>i++;</p>
<p>temp+=dartResult[i];</p>
<p>}</p>
<p>res.push_back(temp);</p>
<p>temp=&quot;&quot;;</p>
<p>}</p>
<p>}</p>
<p>//split the score record</p>
<p>vector&lt;pair&lt;int,vector&lt;char&gt;&gt;&gt; score(3);</p>
<p>for(int i=0;i&lt;res.size();i++){</p>
<p>string score_part=&quot;&quot;;</p>
<p>int j=0;</p>
<p>for(j=0;j&lt;res[i].size();j++){</p>
<p>if('0'&lt;=res[i][j] &amp;&amp; res[i][j]&lt;='9'){</p>
<p>score_part+=res[i][j];</p>
<p>}</p>
<p>else break;</p>
<p>}</p>
<p>score[i].first=stoi(score_part);</p>
<p>score[i].second.push_back(res[i][j]);</p>
<p>if(res[i].back()=='*' || res[i].back()=='#') score[i].second.push_back(res[i].back());</p>
<p>}</p>
<p>//let's caculate</p>
<p>vector&lt;int&gt; table(3);</p>
<p>for(int i=0;i&lt;score.size();i++){</p>
<p>if(score[i].second[0]=='S') table[i]=score[i].first;</p>
<p>else if(score[i].second[0]=='D') table[i]=pow(score[i].first,2);</p>
<p>else if(score[i].second[0]=='T') table[i]=pow(score[i].first,3);</p>
<p>}</p>
<p>//option</p>
<p>for(int i=0;i&lt;score.size();i++){</p>
<p>if(score[i].second.size()==1) continue;</p>
<p>if(score[i].second[1]=='#') table[i]*=-1;</p>
<p>else{</p>
<p>if(i==0) table[i]*=2;</p>
<p>else{</p>
<p>table[i-1]*=2;</p>
<p>table[i]*=2;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int answer = 0;</p>
<p>for(int i=0;i&lt;table.size();i++)</p>
<p>answer+=table[i];</p>
<p>return answer;</p>
<p>}</p>
<p><strong>[141. [SAMSUNG – SW : Population Movement]]</strong></p>
<p>- handling visit table and BFS is the point.</p>
<p>- To avoid time limit exceeded, i need to have a habit using call by reference.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>using namespace std;</p>
<p>int N; int L; int R;</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable() {</p>
<p>fstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_population_movement.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; L; in &gt;&gt; R;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; N; j++)</p>
<p>in &gt;&gt; table[i][j];</p>
<p>return table;</p>
<p>}</p>
<p>vector&lt;vector&lt;int&gt;&gt; makeTable2() {</p>
<p>cin &gt;&gt; N; cin &gt;&gt; L; cin &gt;&gt; R;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(N));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; N; j++)</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>return table;</p>
<p>}</p>
<p>inline bool isValid(int a, int b) {</p>
<p>if (abs(a - b) &gt;= L &amp;&amp; abs(a - b) &lt;= R) return true;</p>
<p>return false;</p>
<p>}</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; makeUnion(vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;vector&lt;bool&gt;&gt;&amp; visit, int x, int y,int&amp; sum) {</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; unions;</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que;</p>
<p>visit[x][y] = true;</p>
<p>que.push(make_pair(x, y));</p>
<p>while (!que.empty()) {</p>
<p>x = que.front().first; y = que.front().second;</p>
<p>unions.push_back(make_pair(x, y));</p>
<p>sum += table[x][y];</p>
<p>que.pop();</p>
<p>if (x - 1 &gt;= 0 &amp;&amp; !visit[x - 1][y] &amp;&amp; isValid(table[x - 1][y], table[x][y])) {</p>
<p>visit[x - 1][y] = true;</p>
<p>que.push(make_pair(x - 1, y));</p>
<p>}</p>
<p>if (y - 1 &gt;= 0 &amp;&amp; !visit[x][y - 1] &amp;&amp; isValid(table[x][y - 1], table[x][y])) {</p>
<p>visit[x][y - 1] = true;</p>
<p>que.push(make_pair(x, y - 1));</p>
<p>}</p>
<p>if (x + 1 &lt; N &amp;&amp; !visit[x + 1][y] &amp;&amp; isValid(table[x + 1][y], table[x][y])) {</p>
<p>visit[x + 1][y] = true;</p>
<p>que.push(make_pair(x + 1, y));</p>
<p>}</p>
<p>if (y + 1 &lt; N &amp;&amp; !visit[x][y + 1] &amp;&amp; isValid(table[x][y + 1], table[x][y])) {</p>
<p>visit[x][y + 1] = true;</p>
<p>que.push(make_pair(x, y + 1));</p>
<p>}</p>
<p>}</p>
<p>if (unions.size() == 1) unions.pop_back();</p>
<p>return unions;</p>
<p>}</p>
<p>void makeMove(vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;pair&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt;&gt;&amp; unions) {</p>
<p>for (pair&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; row : unions) {</p>
<p>int people = floor(row.first / row.second.size());</p>
<p>for (pair&lt;int, int&gt; a : row.second) table[a.first][a.second] = people;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt; table) {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int Move(vector&lt;vector&lt;int&gt;&gt;table) {</p>
<p>int population_movement = 0;</p>
<p>while (true) {</p>
<p>vector&lt;pair&lt;int,vector&lt;pair&lt;int, int&gt;&gt;&gt;&gt; unions;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(N, false));</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; temp;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>int x = i; int y = j;</p>
<p>int sum=0;</p>
<p>if (!visit[x][y]) {</p>
<p>temp = makeUnion(table, visit, x, y,sum);</p>
<p>if (!temp.empty()) unions.push_back(make_pair(sum,temp));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (unions.empty()) break;</p>
<p>else {</p>
<p>makeMove(table, unions);</p>
<p>population_movement++;</p>
<p>}</p>
<p>}</p>
<p>return population_movement;</p>
<p>}</p>
<p>int main() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; table = makeTable2();</p>
<p>cout &lt;&lt; Move(table);</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[142. [SAMSUNG – SW : Tree Jaetech]]</strong></p>
<p><strong>-</strong> I think, Samsung’s simulation problem is quite dirty.</p>
<p>- they present super rigid time limit.</p>
<p>- In this time also, I spent so much time to reduce running time.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>int n, m, k;</p>
<p>int dir[8][2] = { {-1 ,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1} }; // From top-left to bottom-right, 8 directions.</p>
<p>vector&lt;vector&lt;int&gt;&gt; energy;</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; trees;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; dead;</p>
<p>void makeInput() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_tree_jaetech.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; n; in &gt;&gt; m; in &gt;&gt; k;</p>
<p>table.assign(n, vector&lt;int&gt;(n, 5));</p>
<p>energy.assign(n, vector&lt;int&gt;(n));</p>
<p>trees.assign(n, vector&lt;vector&lt;int&gt;&gt;(n));</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>in &gt;&gt; energy[i][j];</p>
<p>}</p>
<p>}</p>
<p>int a, b, c;</p>
<p>for (int i = 0; i &lt; m; i++) {</p>
<p>in &gt;&gt; a; in &gt;&gt; b; in &gt;&gt; c;</p>
<p>trees[a - 1][b - 1].push_back(c);</p>
<p>}</p>
<p>}</p>
<p>void makeInput2() {</p>
<p>cin &gt;&gt; n; cin &gt;&gt; m; cin &gt;&gt; k;</p>
<p>table.assign(n, vector&lt;int&gt;(n, 5));</p>
<p>energy.assign(n, vector&lt;int&gt;(n));</p>
<p>trees.assign(n, vector&lt;vector&lt;int&gt;&gt;(n));</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>cin &gt;&gt; energy[i][j];</p>
<p>}</p>
<p>}</p>
<p>int a, b, c;</p>
<p>for (int i = 0; i &lt; m; i++) {</p>
<p>cin &gt;&gt; a; cin &gt;&gt; b; cin &gt;&gt; c;</p>
<p>trees[a - 1][b - 1].push_back(c);</p>
<p>}</p>
<p>}</p>
<p>inline bool isValid(int x, int y) {</p>
<p>if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) return true;</p>
<p>return false;</p>
<p>}</p>
<p>void spring_summer() {</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>int dead = 0;</p>
<p>vector&lt;int&gt; temp;</p>
<p>sort(trees[i][j].begin(), trees[i][j].end());</p>
<p>for (int k = 0; k &lt; trees[i][j].size(); k++) {</p>
<p>int age = trees[i][j][k];</p>
<p>if (table[i][j] &lt; age) { //if there is not enough energy to eat.</p>
<p>dead += age / 2;</p>
<p>continue;</p>
<p>}</p>
<p>else {</p>
<p>table[i][j] -= age;</p>
<p>temp.push_back(trees[i][j][k]+1); // age +1</p>
<p>}</p>
<p>}</p>
<p>table[i][j] += dead; //summer</p>
<p>trees[i][j].clear();</p>
<p>for (int qq : temp) trees[i][j].push_back(qq);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void autumn() {</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>for (int k = 0; k &lt; trees[i][j].size(); k++) {</p>
<p>int age = trees[i][j][k];</p>
<p>if (age % 5 != 0) continue;</p>
<p>else {</p>
<p>for (int t = 0; t &lt; 8; t++) {</p>
<p>int tx = i + dir[t][0]; int ty = j + dir[t][1];</p>
<p>if (isValid(tx, ty)) {</p>
<p>trees[tx][ty].push_back(1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void winter() {</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>table[i][j] += energy[i][j];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>makeInput2();</p>
<p>for (int year = 0; year &lt; k; year++) {</p>
<p>spring_summer();</p>
<p>autumn();</p>
<p>if (year == k - 1) break; // we don't care last winter</p>
<p>winter();</p>
<p>}</p>
<p>int answer = 0;</p>
<p>for (int i = 0; i &lt; n; i++)</p>
<p>for (int j = 0; j &lt; n; j++)</p>
<p>answer += trees[i][j].size();</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[143. [SAMSUNG – SW : Baby Shark]]</strong></p>
<p><strong>-</strong> BFS problem, there is an order of BFS. so I had to sort shells I will visit for each depth.</p>
<p>- and they gave quite a lot of condition, like time, shark size, eating condition, etc.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>int n; int sx; int sy;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{0,1},{1,0} };</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_baby_shark.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; n;</p>
<p>table.assign(n, vector&lt;int&gt;(n));</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 9) { table[i][j] = 0; sx = i; sy = j; }</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; n;</p>
<p>table.assign(n, vector&lt;int&gt;(n));</p>
<p>for (int i = 0; i &lt; n; i++) {</p>
<p>for (int j = 0; j &lt; n; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 9) { table[i][j] = 0; sx = i; sy = j; }</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int grownUp() {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>int total_time = 0;</p>
<p>int shark_size = 2; //initial shark_size</p>
<p>int eat_size = 0;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(n, vector&lt;bool&gt;(n, false));</p>
<p>que.push(vector&lt;int&gt;{sx, sy, 0});</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; int time = que.front()[2];</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; order;</p>
<p>while (!que.empty() &amp;&amp; que.front()[2] == time) {</p>
<p>order.push_back(make_pair(que.front()[0], que.front()[1]));</p>
<p>que.pop();</p>
<p>}</p>
<p>sort(order.begin(), order.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {return a.second &lt; b.second; });</p>
<p>sort(order.begin(), order.end());</p>
<p>for (int i = 0; i &lt; order.size(); i++) {</p>
<p>int x = order[i].first; int y = order[i].second;</p>
<p>if (table[x][y] != 0 &amp;&amp; table[x][y] &lt; shark_size) { //when it is possible to eat.</p>
<p>total_time += time;</p>
<p>eat_size++;</p>
<p>if (eat_size == shark_size) {</p>
<p>shark_size++;</p>
<p>eat_size = 0;</p>
<p>}</p>
<p>table[x][y] = 0;</p>
<p>visit = vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n, false)); //visit re-initialize.</p>
<p>queue&lt;vector&lt;int&gt;&gt; empty_que;</p>
<p>que.swap(empty_que); //make the queue empty.</p>
<p>que.push(vector&lt;int&gt;{x, y, 0});</p>
<p>visit[x][y] = true;</p>
<p>break;</p>
<p>}</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int tx = x + dir[i][0]; int ty = y + dir[i][1];</p>
<p>if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &lt; n &amp;&amp; table[tx][ty] &lt;= shark_size &amp;&amp; !visit[tx][ty]) {</p>
<p>visit[tx][ty] = true;</p>
<p>que.push(vector&lt;int&gt;{tx, ty, time + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return total_time;</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>cout &lt;&lt; grownUp();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[144. [SAMSUNG – SW : Goodbye Finedust!]]</strong></p>
<p><strong>-</strong> it was a simulation problem, but not DFS and BFS.</p>
<p>- following given rules not hard, but have to be careful of robot’s position whether robot is at leftside or middle or rightside.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; robot;</p>
<p>int rtx, rty, rbx, rby;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int r, c, t;</p>
<p>bool lf=false, rt=false;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_goodbye_finedust.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; r; in &gt;&gt; c; in &gt;&gt; t;</p>
<p>table.assign(r, vector&lt;int&gt;(c));</p>
<p>for (int i = 0; i &lt; r; i++) {</p>
<p>for (int j = 0; j &lt; c; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == -1) robot.push_back(make_pair(i, j));</p>
<p>}</p>
<p>}</p>
<p>rtx = robot[0].first; rty = robot[0].second;</p>
<p>rbx = robot[1].first; rby = robot[1].second;</p>
<p>if (rty == 0) lf = true;</p>
<p>else if (rty = c - 1) rt = true;</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; r; cin &gt;&gt; c; cin &gt;&gt; t;</p>
<p>table.assign(r, vector&lt;int&gt;(c));</p>
<p>for (int i = 0; i &lt; r; i++) {</p>
<p>for (int j = 0; j &lt; c; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == -1) robot.push_back(make_pair(i, j));</p>
<p>}</p>
<p>}</p>
<p>rtx = robot[0].first; rty = robot[0].second;</p>
<p>rbx = robot[1].first; rby = robot[1].second;</p>
<p>if (rty == 0) lf = true;</p>
<p>else if (rty = c - 1) rt = true;</p>
<p>}</p>
<p>void dustMove() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; new_dust;</p>
<p>for (int i = 0; i &lt; r; i++) {</p>
<p>for (int j = 0; j &lt; c; j++) {</p>
<p>int x = i; int y = j;</p>
<p>if (table[x][y] == -1) continue;</p>
<p>int count = 0;</p>
<p>if (table[x][y] &gt; 0) {</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int tx = x + dir[i][0]; int ty = y + dir[i][1];</p>
<p>if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; r &amp;&amp; ty &lt; c &amp;&amp; table[tx][ty] != -1) {</p>
<p>new_dust.push_back(vector&lt;int&gt;{tx, ty, table[x][y]/5});</p>
<p>count++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>table[x][y] -= (table[x][y] / 5) * count;</p>
<p>if (table[x][y] != 0) new_dust.push_back(vector&lt;int&gt;{x, y, table[x][y]});</p>
<p>}</p>
<p>}</p>
<p>table = vector&lt;vector&lt;int&gt;&gt;(r,vector&lt;int&gt;(c));</p>
<p>table[rtx][rty] = -1; table[rbx][rby] = -1;</p>
<p>for (vector&lt;int&gt; pos : new_dust) table[pos[0]][pos[1]] += pos[2];</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row)</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void cleanerAct() {</p>
<p>//top</p>
<p>for (int j = rty-1; j &gt;= 1; j--) table[rtx][j] = table[rtx][j-1];</p>
<p>if (lf) for (int i = rtx-1; i &gt;= 1; i--) table[i][0] = table[i - 1][0];</p>
<p>else for (int i = rtx; i &gt;= 1; i--) table[i][0] = table[i-1][0];</p>
<p>for (int j = 0; j &lt; c - 1; j++) table[0][j] = table[0][j + 1];</p>
<p>if(rt) for (int i = 0; i &lt; rtx-1; i++) table[i][c - 1] = table[i + 1][c - 1];</p>
<p>else for (int i = 0; i &lt; rtx; i++) table[i][c - 1] = table[i + 1][c - 1];</p>
<p>for (int j = c - 1; j &gt; rty; j--) table[rtx][j] = table[rtx][j - 1];</p>
<p>table[rtx][rty + 1] = 0;</p>
<p>//bottom</p>
<p>for (int j = rby - 1; j&gt;= 1; j--) table[rbx][j] = table[rbx][j - 1];</p>
<p>if(lf) for (int i = rbx+1; i &lt; r - 1; i++) table[i][0] = table[i + 1][0];</p>
<p>else for (int i = rbx; i &lt; r-1; i++) table[i][0] = table[i + 1][0];</p>
<p>for (int j = 0; j &lt; c-1; j++) table[r - 1][j] = table[r - 1][j + 1];</p>
<p>if(rt) for (int i = r - 1; i &gt; rbx+1; i--) table[i][c - 1] = table[i - 1][c - 1];</p>
<p>else for (int i = r - 1; i &gt; rbx; i--) table[i][c - 1] = table[i - 1][c - 1];</p>
<p>for (int j = c - 1; j &gt; rby; j--) table[rbx][j] = table[rbx][j - 1];</p>
<p>table[rbx][rby + 1] = 0;</p>
<p>}</p>
<p>int amountFineDust() {</p>
<p>for (int time = 0; time &lt; t; time++) {</p>
<p>dustMove();</p>
<p>cleanerAct();</p>
<p>}</p>
<p>int res = 0;</p>
<p>for (vector&lt;int&gt; row : table)</p>
<p>for (int j = 0; j &lt; c; j++) if(row[j]!=-1) res += row[j];</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>cout &lt;&lt; amountFineDust();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[145. [SAMSUNG – SW :2D Array Calculation]]</strong></p>
<p><strong>-</strong> this was weird. when I used unordered_map, abort occurred at 9% of submission.</p>
<p>- but after I changed the map to int array with same algorithm, it worked well.</p>
<p>- what’s wrong with my previous version??? Even, all the test case they gave or in disccusion session was passed with my unordered_map algorithm!</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>#define max_k 101</p>
<p>using namespace std;</p>
<p>int r, c, k;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(3,vector&lt;int&gt;(3));</p>
<p>int time = 0;</p>
<p>int row = 3, col = 3;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_2d_array_calculation.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; r; in &gt;&gt; c; in &gt;&gt; k;</p>
<p>for (int i = 0; i &lt; 3; i++)</p>
<p>for (int j = 0; j &lt; 3; j++)</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; r; cin &gt;&gt; c; cin &gt;&gt; k;</p>
<p>for (int i = 0; i &lt; 3; i++)</p>
<p>for (int j = 0; j &lt; 3; j++)</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>void operR() {</p>
<p>int max_col = 0;</p>
<p>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; temp(row);</p>
<p>for (int i = 0; i &lt; row; i++) {</p>
<p>int arr[max_k] = { 0, };</p>
<p>for (int j = 0; j &lt; col; j++) if (table[i][j] != 0) arr[table[i][j]]++;</p>
<p>for (int j = 1; j &lt; max_k; j++) if (arr[j] != 0) temp[i].push_back(make_pair(arr[j], j));</p>
<p>sort(temp[i].begin(), temp[i].end());</p>
<p>max_col = max(max_col, temp[i].size() * 2);</p>
<p>}</p>
<p>col = min(100,max_col);</p>
<p>table = vector&lt;vector&lt;int&gt;&gt;(row, vector&lt;int&gt;(col,0));</p>
<p>for (int i = 0; i &lt; row; i++) {</p>
<p>for (int j = 0; j &lt; temp[i].size() &amp;&amp;j&lt;50; j++) {</p>
<p>table[i][2*j] = temp[i][j].second;</p>
<p>table[i][(2*j) + 1] = temp[i][j].first;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void operC() {</p>
<p>int max_row = 0;</p>
<p>vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; temp(col);</p>
<p>for (int j = 0; j &lt; col; j++) {</p>
<p>int arr[max_k] = { 0, };</p>
<p>for (int i = 0; i &lt; row; i++) if(table[i][j]!=0) arr[table[i][j]]++;</p>
<p>for (int i = 1; i &lt; max_k; i++) if (arr[i] != 0) temp[j].push_back(make_pair(arr[i], i));</p>
<p>sort(temp[j].begin(), temp[j].end());</p>
<p>max_row = max(max_row, temp[j].size()*2);</p>
<p>}</p>
<p>row = min(100,max_row);</p>
<p>table = vector&lt;vector&lt;int&gt;&gt;(row, vector&lt;int&gt;(col,0));</p>
<p>for (int j = 0; j &lt; col; j ++) {</p>
<p>for (int i = 0; i &lt; temp[j].size()&amp;&amp; i&lt; 50; i++) {</p>
<p>table[2*i][j] = temp[j][i].second;</p>
<p>table[(2*i)+1][j] = temp[j][i].first;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (int i = 0; i &lt; row; i++) {</p>
<p>for (int j = 0; j &lt; col; j++)</p>
<p>cout &lt;&lt; table[i][j] &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int calculation() {</p>
<p>while (time&lt;=100) {</p>
<p>if (r-1&gt;=0 &amp;&amp; c-1&gt;=0 &amp;&amp; r-1&lt;row &amp;&amp; c-1&lt;col&amp;&amp;table[r - 1][c - 1] == k) return time;</p>
<p>if (row &gt;= col) operR();</p>
<p>else operC();</p>
<p>time++;</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>cout&lt;&lt;calculation();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[146. [SAMSUNG – SW :Fishing King]]</strong></p>
<p><strong>-</strong> I have a so much curiousity of SAMSUNG’s simulation algorithm test cases.</p>
<p>- this problem also has some weird things.</p>
<p>- At first, I solved correctly but time limit exceeded occurred. so I change my code with same algorithm but faster, but it didn’t work. what the heck? how come? algorithm was perfectly same and I just chagned container to reduce traversal time.</p>
<p>- I don’t understand still now.</p>
<p>- Finally, I used my first submission with more efficient shark move.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;map&gt;</p>
<p>using namespace std;</p>
<p>int dir[4][2] = { {-1,0},{1,0},{0,1},{0,-1} }; // up, down, right, left</p>
<p>int r, c, m;</p>
<p>int get_size = 0;</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; table; //speed, direction, size</p>
<p>map&lt;pair&lt;int, int&gt;, vector&lt;vector&lt;int&gt;&gt;&gt; shark_pos;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_fishing_king.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; r; in &gt;&gt; c; in &gt;&gt; m;</p>
<p>table.assign(r, vector&lt;vector&lt;int&gt;&gt;(c));</p>
<p>int a, b, c, d, e;</p>
<p>for (int i = 0; i &lt; m; i++) {</p>
<p>in &gt;&gt; a; in &gt;&gt; b; in &gt;&gt; c; in &gt;&gt; d; in &gt;&gt; e;</p>
<p>table[a - 1][b - 1] = vector&lt;int&gt;{ c,d - 1,e };</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; r; cin &gt;&gt; c; cin &gt;&gt; m;</p>
<p>table.assign(r, vector&lt;vector&lt;int&gt;&gt;(c));</p>
<p>int a, b, c, d, e;</p>
<p>for (int i = 0; i &lt; m; i++) {</p>
<p>cin &gt;&gt; a; cin &gt;&gt; b; cin &gt;&gt; c; cin &gt;&gt; d; cin &gt;&gt; e;</p>
<p>table[a - 1][b - 1] = vector&lt;int&gt;{ c,d - 1,e };</p>
<p>}</p>
<p>}</p>
<p>void GetShark(int col) {</p>
<p>for (int i = 0; i &lt; r; i++) {</p>
<p>if (!table[i][col].empty()) {</p>
<p>get_size += table[i][col][2];</p>
<p>table[i][col].clear();</p>
<p>return;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Moving(int x, int y, int shark_size) {</p>
<p>int speed = table[x][y][0];</p>
<p>int cur_dir = table[x][y][1];</p>
<p>// up, down, right, left ==&gt; 0,1,2,3</p>
<p>int temp_speed;</p>
<p>if (cur_dir == 0) temp_speed = speed % ((r - 1) * 2);</p>
<p>else if (cur_dir == 1) temp_speed = speed % ((r - 1) * 2);</p>
<p>else if (cur_dir == 2) temp_speed = speed % ((c - 1) * 2);</p>
<p>else temp_speed = speed % ((c - 1) * 2);</p>
<p>for (int i = 0; i &lt; temp_speed; i++) {</p>
<p>int tx = x + dir[cur_dir][0]; int ty = y + dir[cur_dir][1];</p>
<p>if (tx &lt; 0) {</p>
<p>cur_dir = 1;</p>
<p>x = 1;</p>
<p>}</p>
<p>else if (ty &lt; 0) {</p>
<p>cur_dir = 2;</p>
<p>y = 1;</p>
<p>}</p>
<p>else if (tx &gt;= r) {</p>
<p>cur_dir = 0;</p>
<p>x = r - 2;</p>
<p>}</p>
<p>else if (ty &gt;= c) {</p>
<p>cur_dir = 3;</p>
<p>y = c - 2;</p>
<p>}</p>
<p>else {</p>
<p>x = tx; y = ty;</p>
<p>}</p>
<p>}</p>
<p>shark_pos[make_pair(x, y)].push_back(vector&lt;int&gt;{speed, cur_dir, shark_size});</p>
<p>}</p>
<p>void MoveShark() {</p>
<p>shark_pos.clear();</p>
<p>for (int i = 0; i &lt; r; i++) {</p>
<p>for (int j = 0; j &lt; c; j++) {</p>
<p>if (!table[i][j].empty()) {</p>
<p>Moving(i, j, table[i][j][2]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>table = vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(r, vector&lt;vector&lt;int&gt;&gt;(c));</p>
<p>for (map&lt;pair&lt;int, int&gt;, vector&lt;vector&lt;int&gt;&gt;&gt;::iterator iter = shark_pos.begin(); iter != shark_pos.end(); iter++) {</p>
<p>sort(iter-&gt;second.begin(), iter-&gt;second.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) {return a[2] &gt; b[2]; });</p>
<p>table[iter-&gt;first.first][iter-&gt;first.second] = vector&lt;int&gt;{ iter-&gt;second[0][0],iter-&gt;second[0][1],iter-&gt;second[0][2] };</p>
<p>}</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (vector&lt;vector&lt;int&gt;&gt; row : table) {</p>
<p>for (vector&lt;int&gt; srk : row) {</p>
<p>if (srk.empty()) cout &lt;&lt; &quot;(0 0 0)&quot; &lt;&lt; &quot; &quot;;</p>
<p>else cout &lt;&lt; &quot;(&quot; &lt;&lt; srk[0] &lt;&lt; &quot; &quot; &lt;&lt; srk[1] &lt;&lt; &quot; &quot; &lt;&lt; srk[2] &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void Fishing() {</p>
<p>//printTable();</p>
<p>for (int i = 0; i &lt; c; i++) {</p>
<p>GetShark(i);</p>
<p>//cout &lt;&lt; &quot;&lt;&lt;get&gt;&gt;&quot; &lt;&lt; endl;</p>
<p>//printTable();</p>
<p>MoveShark();</p>
<p>//cout &lt;&lt; &quot;&lt;&lt;move&gt;&gt;&quot; &lt;&lt; endl;</p>
<p>//printTable();</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>Fishing();</p>
<p>cout &lt;&lt; get_size;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[147. [SAMSUNG – SW : Laboratory 3 ]]</strong></p>
<p>- huh… so much edge case!</p>
<p>- I used DFS for permutation of viruses and BFS for contagion.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;set&gt;</p>
<p>using namespace std;</p>
<p>int lab_size, number_of_virus;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} }; // up left down right</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; virus;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; chosen_virus;</p>
<p>set&lt;int&gt; min_time;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_laboratory3.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; lab_size; in &gt;&gt; number_of_virus;</p>
<p>table.assign(lab_size, vector&lt;int&gt;(lab_size, 0));</p>
<p>visit.assign(lab_size, vector&lt;bool&gt;(lab_size, 0));</p>
<p>int temp_input;</p>
<p>for (int i = 0; i &lt; lab_size; i++) {</p>
<p>for (int j = 0; j &lt; lab_size; j++) {</p>
<p>in &gt;&gt; temp_input;</p>
<p>table[i][j]=temp_input;</p>
<p>visit[i][j] = temp_input;</p>
<p>if (temp_input == 2) {</p>
<p>virus.push_back(make_pair(i, j));</p>
<p>visit[i][j] = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; lab_size; cin &gt;&gt; number_of_virus;</p>
<p>table.assign(lab_size, vector&lt;int&gt;(lab_size, 0));</p>
<p>visit.assign(lab_size, vector&lt;bool&gt;(lab_size, 0));</p>
<p>int temp_input;</p>
<p>for (int i = 0; i &lt; lab_size; i++) {</p>
<p>for (int j = 0; j &lt; lab_size; j++) {</p>
<p>cin &gt;&gt; temp_input;</p>
<p>table[i][j] = temp_input;</p>
<p>visit[i][j] = temp_input;</p>
<p>if (temp_input == 2) {</p>
<p>virus.push_back(make_pair(i, j));</p>
<p>visit[i][j] = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; temp) {</p>
<p>for (vector&lt;int&gt; row : temp) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>bool isContagious(vector&lt;vector&lt;int&gt;&gt;&amp; temp) {</p>
<p>for (int i = 0; i &lt; lab_size; i++)</p>
<p>for (int j = 0; j &lt; lab_size; j++) if (temp[i][j] == 0) return false;</p>
<p>//printTable(temp);</p>
<p>return true;</p>
<p>}</p>
<p>int BFS() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp = table;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; temp_visit=visit;</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que;</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; new_que;</p>
<p>for (pair&lt;int, int&gt; a : chosen_virus) new_que.push(a);</p>
<p>//for (pair&lt;int, int&gt; a : chosen_virus) cout &lt;&lt; a.first &lt;&lt; &quot;,&quot; &lt;&lt; a.second &lt;&lt; endl; cout &lt;&lt; endl;</p>
<p>int time = 0;</p>
<p>while (!new_que.empty()) {</p>
<p>bool flag = false;</p>
<p>que = new_que;</p>
<p>new_que = queue&lt;pair&lt;int, int&gt;&gt;(); // make new_que empty;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front().first; int y = que.front().second;</p>
<p>que.pop();</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int tx = x + dir[i][0]; int ty = y + dir[i][1];</p>
<p>if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; lab_size &amp;&amp; ty &lt; lab_size &amp;&amp; !temp_visit[tx][ty]) {</p>
<p>if (temp[tx][ty] != 2) flag = true;</p>
<p>temp_visit[tx][ty] = true; //make visit</p>
<p>temp[tx][ty] = time+10;</p>
<p>new_que.push(make_pair(tx, ty));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (flag) time++;</p>
<p>else if (!isContagious(temp)) time++;</p>
<p>}</p>
<p>if(isContagious(temp)) return time;</p>
<p>return 999;//max lab_size is 50 so 999 is enough</p>
<p>}</p>
<p>void Contagion(int count,int start) {</p>
<p>if (count == number_of_virus) {</p>
<p>int res = BFS();</p>
<p>//cout &lt;&lt;&quot;res : &quot;&lt;&lt; res &lt;&lt; endl&lt;&lt;endl;</p>
<p>min_time.insert(res);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = start; i &lt; virus.size(); i++) {</p>
<p>int x = virus[i].first; int y = virus[i].second;</p>
<p>chosen_virus.push_back(make_pair(x, y));</p>
<p>visit[x][y] = true;</p>
<p>Contagion(count + 1, i + 1);</p>
<p>visit[x][y] = false;</p>
<p>chosen_virus.pop_back();</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>Contagion(0,0);</p>
<p>int answer= *min_time.begin();</p>
<p>answer == 999 ? cout&lt;&lt;-1 : cout&lt;&lt;answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[148. [SAMSUNG – SW : Gerrymandering 2]] </strong></p>
<p><strong>-</strong> I can’t understand why SAMSUNG likes r and c representing row and columns, why don’t they use just x and y? Because of it, there always exist a confusion.</p>
<p>- this time as well, I spent a lot of time by index</p>
<p>-see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int N;</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_gerrymandering.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N;</p>
<p>table.assign(N+1, vector&lt;int&gt;(N+1));</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>for (int j = 1; j &lt;= N; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N+1, vector&lt;int&gt;(N+1));</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>for (int j = 1; j &lt;= N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; temp_table) {</p>
<p>for (vector&lt;int&gt; row : temp_table) {</p>
<p>for (int i : row) {</p>
<p>cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void makeDistrict(vector&lt;vector&lt;int&gt;&gt;&amp; temp, int x, int y, int d1, int d2) {</p>
<p>// 1</p>
<p>for (int i = 0; i &lt; x + d1; i++) {</p>
<p>for (int j = 0; j &lt;= y; j++) {</p>
<p>if (temp[i][j] == 10) { temp[i][j] = 5; break; }</p>
<p>temp[i][j] = 1;</p>
<p>}</p>
<p>}</p>
<p>// 2</p>
<p>for (int i = 0; i &lt; x + d2+1; i++) {</p>
<p>for (int j = N; j &gt; y; j--) {</p>
<p>if (temp[i][j] == 10) { temp[i][j] = 5; break; }</p>
<p>temp[i][j] = 2;</p>
<p>}</p>
<p>}</p>
<p>//3</p>
<p>for (int i = x + d1; i &lt;= N; i++) {</p>
<p>for (int j = 0; j &lt; y - d1 + d2; j++) {</p>
<p>if (temp[i][j] == 10) { temp[i][j] = 5; break; }</p>
<p>temp[i][j] = 3;</p>
<p>}</p>
<p>}</p>
<p>//4</p>
<p>for (int i = x + d2+1; i &lt;= N; i++) {</p>
<p>for (int j = N; j &gt;= y - d1 + d2; j--) {</p>
<p>if (temp[i][j] == 10) { temp[i][j] = 5; break; }</p>
<p>temp[i][j] = 4;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int drawLine(int x,int y,int d1,int d2) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp(N+1, vector&lt;int&gt;(N+1, 5));</p>
<p>vector&lt;int&gt; exist(5, false);</p>
<p>//top left</p>
<p>for (int i = 0; i &lt;= d1; i++) temp[x+i][y-i] = 10;</p>
<p>//top right</p>
<p>for (int i = 0; i &lt;= d2; i++) temp[x + i][y + i] = 10;</p>
<p>//bottom left</p>
<p>for (int i = 0; i &lt;= d2; i++) temp[x + d1 + i][y - d1 + i] = 10;</p>
<p>//bottom right</p>
<p>for (int i = 0; i &lt;= d1; i++) temp[x + d2 + i][y + d2 - i] = 10;</p>
<p>makeDistrict(temp, x, y, d1, d2);</p>
<p>/*//count</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>for (int j = 1; j &lt;= N; j++) {</p>
<p>exist[temp[i][j] - 1]++;</p>
<p>}</p>
<p>}</p>
<p>for (int i : exist) if (i == 0) return 999999;</p>
<p>//isConnected?</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>for (int j = 1; j &lt;= N; j++) {</p>
<p>int cx = i; int cy = j;</p>
<p>if (exist[temp[cx][cy] - 1] == 1) continue;</p>
<p>bool connected = false;</p>
<p>for (int k = 0; k &lt; 4; k++) {</p>
<p>int tx = cx + dir[k][0]; int ty = cy + dir[k][1];</p>
<p>if (tx &gt;= 1 &amp;&amp; ty &gt;= 1 &amp;&amp; tx &lt;= N &amp;&amp; ty &lt;= N &amp;&amp; temp[tx][ty] == temp[cx][cy]) connected = true;</p>
<p>}</p>
<p>if (!connected) return 999999;</p>
<p>}</p>
<p>}*/</p>
<p>vector&lt;int&gt; people = { 0,0,0,0,0 };</p>
<p>//cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot; : &quot; &lt;&lt; d1 &lt;&lt; &quot;,&quot; &lt;&lt; d2 &lt;&lt; endl;</p>
<p>//printTable(temp);</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>for (int j = 1; j &lt;= N; j++) {</p>
<p>people[temp[i][j] - 1]+=table[i][j];</p>
<p>}</p>
<p>}</p>
<p>return (*max_element(people.begin(), people.end())) - (*min_element(people.begin(), people.end()));</p>
<p>}</p>
<p>bool isValidToMakeLine(int x,int y,int d1,int d2) {</p>
<p>if (x + d1 &gt; N || y - d1 &lt; 1) return false;</p>
<p>if (x + d2 &gt; N || y + d2 &gt; N) return false;</p>
<p>if (x + d1 + d2 &gt; N || y - d1 + d2 &gt; N) return false;</p>
<p>if (x + d2 + d1 &gt; N || y + d2 - d1 &lt; 1) return false;</p>
<p>return true;</p>
<p>}</p>
<p>int Gerrymandering() {</p>
<p>//(i&lt; i+d1+d2 &amp;&amp; i+d1+d2&lt;N) &amp;&amp; (j-d1&gt;=0 &amp;&amp; j+d2&lt;N)</p>
<p>int answer = 9999999;</p>
<p>for (int i = 1; i &lt; N; i++) { //x</p>
<p>for (int j = 2; j &lt; N ; j++) { //y</p>
<p>int d1 = 1, d2 = 1;</p>
<p>for (d1=1; d1&lt;=j; d1++) { //d1</p>
<p>for (d2 = 1; d2&lt;=N-j; d2++) {</p>
<p>if(isValidToMakeLine(i,j,d1,d2)) answer = min(answer, drawLine(i, j, d1, d2));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>cout &lt;&lt; Gerrymandering();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[149. [SAMSUNG – SW : New Game 2]] </strong></p>
<p>- it was a stack handling problem. each shell of 2d array has stack for recoding pieces.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; stacks;</p>
<p>vector&lt;vector&lt;int&gt;&gt; pieces;</p>
<p>int N, K;</p>
<p>int dir[4][2] = { {0,1},{0,-1},{-1,0},{1,0} }; //right left up down</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_new_game2.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; K;</p>
<p>table.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>stacks.assign(N, vector&lt;vector&lt;int&gt;&gt;(N, vector&lt;int&gt;(0)));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>int a, b, c;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>in &gt;&gt; a; in &gt;&gt; b; in &gt;&gt; c;</p>
<p>pieces.push_back(vector&lt;int&gt;{a-1, b-1, c-1,i});</p>
<p>stacks[a - 1][b - 1].push_back(i);</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; N; cin &gt;&gt; K;</p>
<p>table.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>stacks.assign(N, vector&lt;vector&lt;int&gt;&gt;(N, vector&lt;int&gt;(0)));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>int a, b, c;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>cin &gt;&gt; a; cin &gt;&gt; b; cin &gt;&gt; c;</p>
<p>pieces.push_back(vector&lt;int&gt;{a - 1, b - 1, c - 1, i});</p>
<p>stacks[a - 1][b - 1].push_back(i);</p>
<p>}</p>
<p>}</p>
<p>bool isStackedOver4(int x, int y) {</p>
<p>if (stacks[x][y].size() &gt;= 4) return true;</p>
<p>return false;</p>
<p>}</p>
<p>int Game2() {</p>
<p>int turn = 0;</p>
<p>while (turn&lt;=1000) {</p>
<p>turn++;</p>
<p>bool flag = false;</p>
<p>//move</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>int cur_dir = pieces[i][2]; int x = pieces[i][0]; int y = pieces[i][1];</p>
<p>//cout &lt;&lt; &quot;piece : &quot; &lt;&lt; i &lt;&lt; &quot; x : &quot; &lt;&lt; x &lt;&lt; &quot; y : &quot; &lt;&lt; y &lt;&lt; &quot; dir : &quot;&lt;&lt;cur_dir&lt;&lt;endl;</p>
<p>int tx = x + dir[cur_dir][0]; int ty = y + dir[cur_dir][1];</p>
<p>//cout &lt;&lt; &quot; tx : &quot; &lt;&lt; tx &lt;&lt; &quot; ty : &quot; &lt;&lt; ty &lt;&lt; endl;</p>
<p>//blue</p>
<p>if (tx &lt; 0 || ty &lt; 0 || tx &gt;= N || ty &gt;= N || table[tx][ty] == 2) {</p>
<p>//cout &lt;&lt; &quot;blue&quot; &lt;&lt; endl;</p>
<p>if (cur_dir == 0) cur_dir = 1;</p>
<p>else if (cur_dir == 1) cur_dir = 0;</p>
<p>else if (cur_dir == 2) cur_dir = 3;</p>
<p>else cur_dir = 2;</p>
<p>int nx = x + dir[cur_dir][0]; int ny = y + dir[cur_dir][1];</p>
<p>pieces[i][2] = cur_dir;</p>
<p>//double blue</p>
<p>if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N || table[nx][ny] == 2) continue;</p>
<p>else { i--; continue; }</p>
<p>}</p>
<p>//get index of current stacks;</p>
<p>int bottom;</p>
<p>for (bottom = 0; bottom &lt; stacks[x][y].size(); bottom++) if (stacks[x][y][bottom] == i) break;</p>
<p>// when red</p>
<p>if (table[tx][ty] == 1) {</p>
<p>//cout &lt;&lt; &quot;red&quot; &lt;&lt; endl;</p>
<p>for (int j = stacks[x][y].size() - 1; j &gt;= bottom; j--) {</p>
<p>stacks[tx][ty].push_back(stacks[x][y].back());</p>
<p>pieces[stacks[x][y].back()][0] = tx; pieces[stacks[x][y].back()][1] = ty;</p>
<p>stacks[x][y].pop_back();</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>//cout &lt;&lt; &quot;white&quot; &lt;&lt; endl;</p>
<p>for (int j = bottom; j &lt; stacks[x][y].size(); j++) {</p>
<p>stacks[tx][ty].push_back(stacks[x][y][j]);</p>
<p>pieces[stacks[x][y][j]][0] = tx; pieces[stacks[x][y][j]][1] = ty;</p>
<p>}</p>
<p>int size = stacks[x][y].size();</p>
<p>for (int j = bottom; j &lt; size; j++) stacks[x][y].pop_back();</p>
<p>}</p>
<p>if (isStackedOver4(tx,ty)) { flag = true; break; }</p>
<p>}</p>
<p>if (flag) break;</p>
<p>}</p>
<p>if (turn &gt; 1000) return -1;</p>
<p>return turn;</p>
<p>}</p>
<p>int main() {</p>
<p>Input();</p>
<p>cout &lt;&lt; Game2();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[150. [SAMSUNG – SW : Circle Rotation]] </strong></p>
<p><strong>-</strong> the trick this problem has is a circle they gave is logically same with 2D array without columns act like circle.</p>
<p>- so it was just a simulation problem. but like always, SAMSUNG’s problem is not kind to user.</p>
<p>- there are pretty many ambiguous restrictions.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;fstream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>int N, M, T;</p>
<p>vector&lt;vector&lt;int&gt;&gt; order;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>void Input() {</p>
<p>ifstream in(&quot;C:\\Users\\gjsgu\\Desktop\\Algorithm\\test_case\\test_case_for_circle_rotation.txt&quot;);</p>
<p>if (in.is_open()) cout &lt;&lt; &quot;file is opened.&quot; &lt;&lt; endl;</p>
<p>in &gt;&gt; N; in &gt;&gt; M; in &gt;&gt; T;</p>
<p>table.assign(N, vector&lt;int&gt;(M));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>in &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>int a, b, c;</p>
<p>for (int i = 0; i &lt; T; i++) {</p>
<p>in &gt;&gt; a; in &gt;&gt; b; in &gt;&gt; c;</p>
<p>order.push_back(vector&lt;int&gt;{a,b,c});</p>
<p>}</p>
<p>}</p>
<p>void Input2() {</p>
<p>cin &gt;&gt; N; cin &gt;&gt; M; cin &gt;&gt; T;</p>
<p>table.assign(N, vector&lt;int&gt;(M));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>int a, b, c;</p>
<p>for (int i = 0; i &lt; T; i++) {</p>
<p>cin &gt;&gt; a; cin &gt;&gt; b; cin &gt;&gt; c;</p>
<p>order.push_back(vector&lt;int&gt;{a, b, c});</p>
<p>}</p>
<p>}</p>
<p>void Move(int dir,int round,vector&lt;int&gt;&amp; row) {</p>
<p>int temp;</p>
<p>round %= row.size();</p>
<p>if (dir == 0) {</p>
<p>for (int r = 0; r &lt; round; r++) {</p>
<p>temp = row.back();</p>
<p>for (int i = row.size()-1; i &gt;=1; i--) row[i] = row[i - 1];</p>
<p>row[0] = temp;</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>for (int r = 0; r &lt; round; r++) {</p>
<p>temp = row[0];</p>
<p>for (int i = 0; i &lt; row.size() - 1;i++)</p>
<p>row[i] = row[i + 1];</p>
<p>row[row.size() - 1] = temp;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>bool isEmpty(vector&lt;pair&lt;int, int&gt;&gt;&amp; left_pos) {</p>
<p>int count = 0;</p>
<p>for (int i = 0; i &lt; N;i++) {</p>
<p>for (int j = 0; j &lt; M; j++) if (table[i][j] != 0) left_pos.push_back(make_pair(i, j));</p>
<p>}</p>
<p>if (left_pos.empty()) return true;</p>
<p>return false;</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int Rotate() {</p>
<p>//cout &lt;&lt; &quot;START&quot; &lt;&lt; endl;</p>
<p>//printTable();</p>
<p>for (vector&lt;int&gt; ord : order) {</p>
<p>int x = ord[0]; int d = ord[1]; int k = ord[2];</p>
<p>vector&lt;int&gt; row_index;</p>
<p>//cout &lt;&lt; &quot;order : &quot;&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;d&lt;&lt;&quot;,&quot;&lt;&lt;k &lt;&lt; endl;</p>
<p>for (int i = 1; i * x &lt;= N; i++) { //rotate</p>
<p>int circle = (i * x)-1;</p>
<p>row_index.push_back(circle);</p>
<p>Move(d, k,table[circle]);</p>
<p>}</p>
<p>//cout &lt;&lt; &quot;After Move&quot; &lt;&lt; endl;</p>
<p>//printTable();</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; left_pos;</p>
<p>if (!isEmpty(left_pos)) {</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(M, false));</p>
<p>bool flag = true;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>visit[i][j] = true;</p>
<p>if (table[i][j] == 0) continue;</p>
<p>int cur = table[i][j];</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que; que.push(make_pair(i, j));</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front().first; int y = que.front().second; que.pop();</p>
<p>for (int u = 0; u &lt; 4; u++) {</p>
<p>int tx = x + dir[u][0]; int ty = y + dir[u][1];</p>
<p>if (ty == M) ty = 0; if (ty == -1) ty = M - 1; //they are in shape of circle.</p>
<p>if (tx &gt;= 0 &amp;&amp; tx &lt; N&amp;&amp; table[tx][ty] == cur &amp;&amp; !visit[tx][ty]) {</p>
<p>visit[tx][ty] = true; que.push(make_pair(tx, ty));</p>
<p>table[tx][ty] = 0; table[x][y] = 0;</p>
<p>flag = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (flag) {</p>
<p>//cout &lt;&lt; &quot;&lt;&lt;flag happend&gt;&gt;&quot; &lt;&lt; endl;</p>
<p>int sum = 0;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) sum += i;</p>
<p>}</p>
<p>double average = (double)sum / (double)left_pos.size();</p>
<p>//cout &lt;&lt; &quot;sum : &quot; &lt;&lt; sum &lt;&lt; &quot; average : &quot; &lt;&lt; average &lt;&lt; endl;</p>
<p>for (pair&lt;int, int&gt; a : left_pos) {</p>
<p>if (table[a.first][a.second] &gt; average) table[a.first][a.second]--;</p>
<p>else if(table[a.first][a.second] &lt; average)table[a.first][a.second]++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//cout &lt;&lt; &quot;BFS resulst&quot; &lt;&lt; endl;</p>
<p>//printTable();</p>
<p>}</p>
<p>int res = 0;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) res += i;</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>Input2();</p>
<p>cout &lt;&lt; Rotate();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[151. [SAMSUNG – SW : Dice Yut Play]] </strong></p>
<p><strong>-</strong> this was the last problem of SAMSUNG SW in Baekjoon. But sadly, my algorithm didn’t work well. so I refered to below URL.</p>
<p><a href="https://eine.tistory.com/entry/%EB%B0%B1%EC%A4%80-17825%EB%B2%88-%EC%A3%BC%EC%82%AC%EC%9C%84-%EC%9C%B7%EB%86%80%EC%9D%B4-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4"><span class="underline">https://eine.tistory.com/entry/%EB%B0%B1%EC%A4%80-17825%EB%B2%88-%EC%A3%BC%EC%82%AC%EC%9C%84-%EC%9C%B7%EB%86%80%EC%9D%B4-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4</span></a></p>
<p>- In my case, I made all the node of the board and did brute force, but answer was wrong.</p>
<p>- so I took the above URL’s code. he used bit mask for permutation that made using DFS in my case. so genius…</p>
<p>- Futhermore, he made lookup table. I’ve never thought that I could make it as a look up table! I learned a lot from the URL.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>#define endl '\n'</p>
<p>typedef long long ll;</p>
<p>typedef pair&lt;int, int&gt; pii;</p>
<p>int dice[10];</p>
<p>#define END 32</p>
<p>//이동 규칙이 복잡할 수 있으므로 Look-up 테이블을 만들어서 사용한다.</p>
<p>//jump[index][0] = 해당 판 점수</p>
<p>//jump[index][1~5] =&gt; 주사위 해당 수가 나오면 이동하는 양</p>
<p>int jump[33][6] = {</p>
<p>{0,1,2,3,4,5}, //0번자리</p>
<p>{2,2,3,4,5,9}, //1번자리</p>
<p>{4,3,4,5,9,10}, //2번자리</p>
<p>{6,4,5,9,10,11}, //3번자리</p>
<p>{8,5,9,10,11,12},//4번자리</p>
<p>{10,6,7,8,20,29},//5번자리</p>
<p>{13,7,8,20,29,30}, //6번자리</p>
<p>{16,8,20,29,30,31}, //7번자리</p>
<p>{19,20,29,30,31,32}, //8번자리</p>
<p>{12,10,11,12,13,14}, //9번자리</p>
<p>{14,11,12,13,14,15}, //10번자리</p>
<p>{16,12,13,14,15,16}, //11번자리</p>
<p>{18,13,14,15,16,17}, //12번자리</p>
<p>{20,18,19,20,29,30}, //13번자리</p>
<p>{22,15,16,17,24,25}, //14번자리</p>
<p>{24,16,17,24,25,26}, //15번자리</p>
<p>{26,17,24,25,26,27}, //16번자리</p>
<p>{28,24,25,26,27,28}, //17번자리</p>
<p>{22,19,20,29,30,31}, //18번자리</p>
<p>{24,20,29,30,31,32}, //19번자리</p>
<p>{25,29,30,31,32,32}, //20번자리</p>
<p>{26,20,29,30,31,32}, //21번자리</p>
<p>{27,21,20,29,30,31}, //22번자리</p>
<p>{28,22,21,20,29,30}, //23번자리</p>
<p>{30,23,22,21,20,29}, //24번자리</p>
<p>{32,26,27,28,31,32}, //25번자리</p>
<p>{34,27,28,31,32,32}, //26번자리</p>
<p>{36,28,31,32,32,32}, //27번자리</p>
<p>{38,31,32,32,32,32}, //28번자리</p>
<p>{30,30,31,32,32,32}, //29번자리</p>
<p>{35,31,32,32,32,32}, //30번자리</p>
<p>{40,32,32,32,32,32}, //31번자리</p>
<p>{0,32,32,32,32,32} //32번자리</p>
<p>};</p>
<p>int ans=0;</p>
<p>void check(int bit) {</p>
<p>int score = 0;</p>
<p>vector&lt;int&gt;occupation(35);</p>
<p>vector&lt;int&gt; pos(4);</p>
<p>occupation[0] = 4;</p>
<p>for (int turn = 0; turn &lt; 10; turn++) {</p>
<p>//이번에 옮길 말</p>
<p>int horse = (bit &gt;&gt; (turn * 2)) &amp; 0x3;</p>
<p>//cout &lt;&lt; horse &lt;&lt; endl;</p>
<p>//이동하는 거리</p>
<p>int move = dice[turn];</p>
<p>//현재 위치</p>
<p>int&amp; current_pos = pos[horse];</p>
<p>//이동할 위치</p>
<p>int next_pos = jump[current_pos][move];</p>
<p>//이번 이동으로 얻을 점수</p>
<p>int get_score = jump[next_pos][0];</p>
<p>//처음이나 끝 위치가 아닌데 말이 겹치는 경우</p>
<p>if (occupation[next_pos] &gt; 0 &amp;&amp; next_pos &amp;&amp; next_pos != END) {</p>
<p>//불가능한 이동</p>
<p>return;</p>
<p>}</p>
<p>else {</p>
<p>score += get_score;</p>
<p>occupation[next_pos]++;</p>
<p>occupation[current_pos]--;</p>
<p>current_pos = next_pos;</p>
<p>}</p>
<p>}</p>
<p>ans = max(ans, score);</p>
<p>}</p>
<p>int main() {</p>
<p>for (int i = 0; i &lt; 10; i++)</p>
<p>cin &gt;&gt; dice[i];</p>
<p>for (int bit = 0; bit &lt; (1 &lt;&lt; 20); bit++) {</p>
<p>check(bit);</p>
<p>}</p>
<p>cout &lt;&lt; ans &lt;&lt; endl;</p>
<p>}</p>
<p><strong>[152. [KAKAO – 2018 : The Song Just Before]] </strong></p>
<p><strong>-</strong> WOW! I have barely solved this problem. At first, I used vector to record notes of a song, but in that case, it would be harder to check whether my song is in there than using string.</p>
<p>- so I changed algorithm. I spent 2 hours or so, I think.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;sstream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>using namespace std;</p>
<p>string songToInt(string song) {</p>
<p>//cout&lt;&lt;song&lt;&lt;endl;</p>
<p>string res;</p>
<p>bool sharp = false;</p>
<p>for (int i = song.size() - 1; i &gt;= 0; i--) {</p>
<p>if (song[i] == '#') sharp = true;</p>
<p>else {</p>
<p>switch (song[i]) {</p>
<p>case 'C':</p>
<p>if (sharp) res += 'C';</p>
<p>else res += 'c';</p>
<p>break;</p>
<p>case 'D':</p>
<p>if (sharp) res += 'D';</p>
<p>else res += 'd';</p>
<p>break;</p>
<p>case 'E':</p>
<p>res += 'e';</p>
<p>break;</p>
<p>case 'F':</p>
<p>if (sharp) res += 'F';</p>
<p>else res += 'f';</p>
<p>break;</p>
<p>case 'G':</p>
<p>if (sharp) res += 'G';</p>
<p>else res += 'g';</p>
<p>break;</p>
<p>case 'A':</p>
<p>if (sharp) res += 'A';</p>
<p>else res += 'a';</p>
<p>break;</p>
<p>case 'B':</p>
<p>res += 'b';</p>
<p>break;</p>
<p>}</p>
<p>sharp = false;</p>
<p>}</p>
<p>}</p>
<p>//for (int i : res) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>//cout &lt;&lt; endl;</p>
<p>reverse(res.begin(), res.end());</p>
<p>//for (int i : res) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>//cout &lt;&lt; endl;</p>
<p>return res;</p>
<p>}</p>
<p>bool hasMySong(string a, string b) {</p>
<p>int i = 0, j = 0;</p>
<p>bool flag = false;</p>
<p>int start = 0;</p>
<p>while (i&lt;a.size()) {</p>
<p>if (j &gt;= b.size()) {</p>
<p>flag = true;</p>
<p>break;</p>
<p>}</p>
<p>if (a[i] == b[j]) {</p>
<p>i++; j++;</p>
<p>}</p>
<p>else {</p>
<p>start++;</p>
<p>i = start; j = 0;</p>
<p>}</p>
<p>}</p>
<p>return flag;</p>
<p>}</p>
<p>string solution(string m, vector&lt;string&gt; musicinfos) {</p>
<p>string answer = &quot;&quot;;</p>
<p>// make list</p>
<p>vector&lt;pair&lt;vector&lt;int&gt;, pair&lt;string, string&gt;&gt;&gt; list; //pair&lt;vector{start,end,length},pair&lt;name,{song : 1,2,12,3...}}&gt;&gt;</p>
<p>for (int i = 0; i &lt; musicinfos.size(); i++) {</p>
<p>stringstream ss(musicinfos[i]);</p>
<p>string start; string end; string name; string song;</p>
<p>getline(ss, start, ','); getline(ss, end, ','); getline(ss, name, ','); getline(ss, song, '\n');</p>
<p>string s_time = &quot;&quot;; s_time += start[0]; s_time += start[1];</p>
<p>string s_temp = &quot;&quot;; s_temp += start[3]; s_temp += start[4];</p>
<p>int s_input = stoi(s_time) * 60 + stoi(s_temp);</p>
<p>string e_time = &quot;&quot;; e_time += end[0]; e_time += end[1];</p>
<p>string e_temp = &quot;&quot;; e_temp += end[3]; e_temp += end[4];</p>
<p>int e_input = stoi(e_time) * 60 + stoi(e_temp);</p>
<p>string temp = songToInt(song);</p>
<p>int play_time = e_input - s_input;</p>
<p>int temp_size = temp.size();</p>
<p>if (play_time &gt; temp_size) for (int i = temp_size; i &lt; play_time; i++) temp+=temp[i % temp_size];</p>
<p>else if (play_time &lt; temp_size) temp = { temp.begin(),next(temp.begin(),play_time) };</p>
<p>list.push_back(make_pair(vector&lt;int&gt;{s_input, e_input, e_input - s_input - 1, i},</p>
<p>make_pair(name, temp)));</p>
<p>}</p>
<p>string my_song = songToInt(m);</p>
<p>vector&lt;pair&lt;string, vector&lt;int&gt;&gt;&gt; find_list;</p>
<p>for (int i = 0; i &lt; list.size(); i++) {</p>
<p>if (list[i].second.second.find(my_song)!=string::npos) {</p>
<p>find_list.push_back(make_pair(list[i].second.first, vector&lt;int&gt;{list[i].first[3], list[i].first[2]}));</p>
<p>}</p>
<p>}</p>
<p>if (find_list.empty()) answer = &quot;(None)&quot;;</p>
<p>else {</p>
<p>sort(find_list.begin(), find_list.end(), [](pair&lt;string, vector&lt;int&gt;&gt; a, pair&lt;string, vector&lt;int&gt;&gt; b) { return a.second[1] &gt; b.second[1]; });</p>
<p>vector&lt;pair&lt;string, vector&lt;int&gt;&gt;&gt; temp;</p>
<p>int cur = find_list[0].second[1];</p>
<p>for (int i = 0; i &lt; find_list.size(); i++) {</p>
<p>if (find_list[i].second[1] == cur) temp.push_back(find_list[i]);</p>
<p>else break;</p>
<p>}</p>
<p>sort(temp.begin(), temp.end(), [](pair&lt;string, vector&lt;int&gt;&gt; a, pair&lt;string, vector&lt;int&gt;&gt; b) { return a.second[0] &lt; b.second[0]; });</p>
<p>answer = temp[0].first;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution(&quot;ABC&quot;, { &quot;12:00,12:14,HELLO,C#DEFGAB&quot;,&quot;13:00,13:05,WORLD,ABCDEF&quot;});</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[153. [KAKAO – 2018 : Compression]] </strong></p>
<p><strong>-</strong> For two days from last problem, I had no time to solve algorithm until today.</p>
<p>- And this problem was quite confusing. Making dictionary was the hardest thing.</p>
<p>- I made a dictionary for each length of word. After that, from max_length to 1, compare input substring with the dictionary of the substring’s length.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; solution(string msg) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>map&lt;int, vector&lt;pair&lt;string, int&gt;&gt;&gt; dict;</p>
<p>//dict initialized</p>
<p>dict[1].assign(26, make_pair(&quot;&quot;, 0));</p>
<p>for (int i = 0; i &lt; 26; i++) dict[1][i] = make_pair('A' + i, i + 1);</p>
<p>int max_length = 1;</p>
<p>int start = 0;</p>
<p>int cur_index = 27;</p>
<p>bool flag = true;</p>
<p>while (flag) {</p>
<p>bool next = true;</p>
<p>for (int len = max_length; len &gt;= 1 &amp;&amp; flag &amp;&amp; next; len--) {</p>
<p>string temp = msg.substr(start, len);</p>
<p>for (int i = 0; i &lt; dict[len].size(); i++) {</p>
<p>if (temp == dict[len][i].first) {</p>
<p>answer.push_back(dict[len][i].second);</p>
<p>if (start + len &lt; msg.size()) {</p>
<p>start += len;</p>
<p>dict[len + 1].push_back(make_pair(temp + msg.substr(start, 1), cur_index));</p>
<p>max_length = max(max_length, len + 1);</p>
<p>cur_index++;</p>
<p>next = false;</p>
<p>break;</p>
<p>}</p>
<p>else {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>vector&lt;int&gt; answer;</p>
<p>answer = solution(&quot;TOBEORNOTTOBEORTOBEORNOT&quot;);</p>
<p>//answer = solution(&quot;KAKAO&quot;);</p>
<p>for (int i : answer) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[154. [KAKAO – 2018 : Automatic Completion]] </strong></p>
<p><strong>-</strong> it was a string parisng problem. so I used Trie tree to make dictionary.</p>
<p>- when I insert a string into the dictionary, I recorded how many word can be parsed from the node with a name has_word.</p>
<p>- the concept was easy, but making Trie tree was quite naughty :).</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>class Trie {</p>
<p>public:</p>
<p>vector&lt;Trie*&gt; dict; // a : 0 - z : 25</p>
<p>bool terminal = false;</p>
<p>int has_word = 0;</p>
<p>Trie() {</p>
<p>dict.assign(26, nullptr);</p>
<p>}</p>
<p>~Trie() {</p>
<p>for (Trie* remove : dict) if (remove != nullptr) remove = nullptr;</p>
<p>}</p>
<p>void insert(const char* c) {</p>
<p>if (*c == '\0') {</p>
<p>//has_word++;</p>
<p>terminal = true;</p>
<p>return;</p>
<p>}</p>
<p>int index = *c - 'a';</p>
<p>if (dict[index] == nullptr) dict[index] = new Trie();</p>
<p>dict[index]-&gt;has_word++;</p>
<p>dict[index]-&gt;insert(c + 1);</p>
<p>}</p>
<p>bool find(const char* c) {</p>
<p>if (terminal &amp;&amp; *c == '\0') return true;</p>
<p>else if (*c == '\0') return false;</p>
<p>int index = *c - 'a';</p>
<p>if (dict[index] != nullptr) {</p>
<p>return dict[index]-&gt;find(c + 1);</p>
<p>}</p>
<p>else return false;</p>
<p>}</p>
<p>int length(const char* c,int count) {</p>
<p>if (has_word == 1) return count;</p>
<p>else if (has_word &gt; 1 &amp;&amp; *c == '\0') return count;</p>
<p>int index = *c - 'a';</p>
<p>return dict[index]-&gt;length(c + 1, count + 1);</p>
<p>}</p>
<p>};</p>
<p>int solution(vector&lt;string&gt; words) {</p>
<p>int answer = 0;</p>
<p>Trie* dict = new Trie();</p>
<p>//make dictionary</p>
<p>for (string s : words) {</p>
<p>const char* c = s.c_str(); // to make string to const char*, we can use string::str.c_str();</p>
<p>dict-&gt;insert(c);</p>
<p>}</p>
<p>for (string s : words) {</p>
<p>const char* c = s.c_str();</p>
<p>int temp = dict-&gt;length(c, 0);</p>
<p>//cout &lt;&lt; &quot;length : &quot;&lt;&lt;temp &lt;&lt; endl;</p>
<p>answer += temp;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution(vector&lt;string&gt;{ &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jklm&quot; });</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[155. [KAKAO – 2018 : Sort Filename]] </strong></p>
<p>- it was an easy problem, but setting a range of For syntax made a small error. To solve the error, I spent 30 minutes.</p>
<p>- during revise my algorithm, I made my algorithm worse about time complexity, actually I didn’t need to change set to vector, but I have no idea what’s wrong at the time.</p>
<p>- after passing all the test case, it’s quite tiresome returning my alogirhtm to originnal one.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;set&gt;</p>
<p>using namespace std;</p>
<p>pair&lt;string,int&gt; getNumber(string s) {</p>
<p>string head;</p>
<p>string temp;</p>
<p>bool flag = true;</p>
<p>for (int i = 0; i &lt; s.size() &amp;&amp; flag; i++) {</p>
<p>if ('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') {</p>
<p>for (int j = i; j &lt;= s.size(); j++) {</p>
<p>if (j == s.size()) {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>else if ('0' &lt;= s[j] &amp;&amp; s[j] &lt;= '9') {</p>
<p>temp += s[j];</p>
<p>}</p>
<p>else {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else head += s[i];</p>
<p>}</p>
<p>int res = stoi(temp);</p>
<p>return make_pair(head,res);</p>
<p>}</p>
<p>vector&lt;string&gt; solution(vector&lt;string&gt; files) {</p>
<p>vector&lt;string&gt; answer;</p>
<p>vector&lt;string&gt; temp = files;</p>
<p>vector&lt;string&gt; name_sort;</p>
<p>map&lt;string, vector&lt;pair&lt;string,vector&lt;int&gt;&gt;&gt;&gt; map_list;</p>
<p>//to make lowercase</p>
<p>for (int i = 0; i &lt; files.size(); i++) {</p>
<p>transform(temp[i].begin(), temp[i].end(), temp[i].begin(), ::tolower);</p>
<p>pair&lt;string,int&gt; head_number = getNumber(temp[i]);</p>
<p>name_sort.push_back(head_number.first);</p>
<p>//cout &lt;&lt; &quot;got name : &quot;&lt;&lt;head_number.first &lt;&lt; endl;</p>
<p>//cout &lt;&lt; &quot;got number : &quot; &lt;&lt; head_number.second &lt;&lt; endl;</p>
<p>map_list[head_number.first].push_back(make_pair(files[i], vector&lt;int&gt;{i,head_number.second}));</p>
<p>}</p>
<p>for (map&lt;string, vector&lt;pair&lt;string, vector&lt;int&gt;&gt;&gt;&gt;::iterator iter = map_list.begin(); iter != map_list.end(); iter++) {</p>
<p>stable_sort(iter-&gt;second.begin(), iter-&gt;second.end(), [](pair&lt;string, vector&lt;int&gt;&gt; a, pair&lt;string, vector&lt;int&gt;&gt; b) {return a.second[1] &lt; b.second[1]; });</p>
<p>}</p>
<p>stable_sort(name_sort.begin(), name_sort.end());</p>
<p>for (int i = 0; i &lt; name_sort.size(); i++) {</p>
<p>answer.push_back(map_list[name_sort[i]][0].first);</p>
<p>map_list[name_sort[i]].erase(map_list[name_sort[i]].begin());</p>
<p>}</p>
<p>//for (string s : answer)</p>
<p>//cout &lt;&lt; s &lt;&lt; &quot; &quot;;</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>solution({ &quot;F-5 Freedom Fighter&quot;,&quot;fa-36&quot;, &quot;B-50 Superfortress&quot;, &quot;A-10 Thunderbolt II&quot;, &quot;F-14 Tomcat&quot; });</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[156. [KAKAO – 2018 : Notation Game]]</strong></p>
<p><strong>-</strong> this was final problem of KAKAO. By solving this problem, I’ve solved all the KAKAO coding test problem and part of SAMSUNG SW :)</p>
<p>- the way to make string for given notation is the key point of this problem.</p>
<p>- I made whole string first, actually the string was over calculated, but time limit was okay.</p>
<p>- After that, just finding Muzi’s turn, that was all.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>string solution(int n, int t, int m, int p) {</p>
<p>string answer = &quot;&quot;;</p>
<p>string alpha=&quot;0123456789ABCDEF&quot;;</p>
<p>string total_string=&quot;0&quot;;</p>
<p>for(int i=1;i&lt;t*m;i++){</p>
<p>string temp=&quot;&quot;;</p>
<p>int number=i;</p>
<p>while(number&gt;0){</p>
<p>int res=number%n;</p>
<p>number=number/n;</p>
<p>temp+=alpha[res];</p>
<p>}</p>
<p>reverse(temp.begin(),temp.end());</p>
<p>total_string+=temp;</p>
<p>}</p>
<p>int count=0;</p>
<p>for(int i=p-1;i&lt;total_string.size();i+=m){</p>
<p>if(count&gt;=t) break;</p>
<p>answer+=total_string[i];</p>
<p>count++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p><strong>[157. [SAMSUNG</strong> - <strong>SW : Chocolate and Raisin]</strong></p>
<p>- it was D4 problem. I mean it was quite hard to solve.</p>
<p>- time was the most difficult one to reach the given condition.</p>
<p>- I used memorization named visit, DFS, and prefix_sum.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; prefix_sum;</p>
<p>int n, m;</p>
<p>int visit[51][51][51][51] = { 0, };</p>
<p>void prefixSum() {</p>
<p>prefix_sum[0][0] = table[0][0];</p>
<p>for (int i = 1; i &lt; n; i++) prefix_sum[i][0] = prefix_sum[i - 1][0] + table[i][0];</p>
<p>for (int j = 1; j &lt; m; j++) prefix_sum[0][j] = prefix_sum[0][j - 1] + table[0][j];</p>
<p>for (int i = 1; i &lt; n; i++) {</p>
<p>for (int j = 1; j &lt; m; j++) {</p>
<p>prefix_sum[i][j] = prefix_sum[i][j - 1] + prefix_sum[i - 1][j] - prefix_sum[i - 1][j - 1] + table[i][j];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int helper(int tx,int ty,int bx,int by) {</p>
<p>if (tx == bx &amp;&amp; ty == by) return 0;</p>
<p>else if (visit[tx][ty][bx][by] != -1) return visit[tx][ty][bx][by];</p>
<p>int sum = 0;</p>
<p>if (tx == 0 &amp;&amp; ty == 0) sum = prefix_sum[bx][by];</p>
<p>else if (tx == 0) sum = prefix_sum[bx][by] - prefix_sum[bx][ty - 1];</p>
<p>else if (ty == 0) sum = prefix_sum[bx][by] - prefix_sum[tx - 1][by];</p>
<p>else sum = prefix_sum[bx][by] - prefix_sum[tx - 1][by] - prefix_sum[bx][ty - 1] + prefix_sum[tx - 1][ty - 1];</p>
<p>int res = 987654321;</p>
<p>for (int i = tx ; i &lt; bx; i++) {</p>
<p>res=min(res,sum+helper(tx, ty, i, by)+ helper(i + 1, ty, bx, by));</p>
<p>}</p>
<p>for (int j = ty; j &lt; by; j++) {</p>
<p>res=min(res,sum+helper(tx, ty, bx, j) + helper(tx, j+1, bx, by));</p>
<p>}</p>
<p>visit[tx][ty][bx][by] = res;</p>
<p>return res;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case) {</p>
<p>cin &gt;&gt; n; cin &gt;&gt; m;</p>
<p>memset(visit, -1, sizeof(visit));</p>
<p>table.assign(n, vector&lt;int&gt;(m));</p>
<p>prefix_sum.assign(n, vector&lt;int&gt;(m));</p>
<p>for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) cin &gt;&gt; table[i][j]; //make table</p>
<p>prefixSum();</p>
<p>//for (vector&lt;int&gt; row : prefix_sum) {</p>
<p>// for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>// cout &lt;&lt; endl;</p>
<p>//}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; helper(0, 0, n - 1, m - 1) &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;//정상종료시 반드시 0을 리턴해야합니다.</p>
<p>}</p>
<p><strong>[158. [SAMSUNG</strong> - <strong>SW : Diamond]</strong></p>
<p>‑ I’ve misunderstood. but it wasn’t only me. so it’s SAMSUNG’s problem haha.</p>
<p>- using set and map, I made an algorithm easily. there was no DFS, DP, etc, but just caculation.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#define Min(a,b) a&gt;b?b:a</p>
<p>#define Max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int N, K;</p>
<p>unordered_map&lt;int, int&gt; diamond;</p>
<p>set&lt;int&gt; diamond_size;</p>
<p>int maximum = 0;</p>
<p>// K=3</p>
<p>// 1 2 3 5 5 5 5 8 9 9 9 10 15</p>
<p>void helper(set&lt;int&gt;::iterator start) {</p>
<p>int cur_size = *start;</p>
<p>maximum = Max(maximum, diamond[cur_size]);</p>
<p>int res = diamond[cur_size];</p>
<p>for (set&lt;int&gt;::iterator size_iter = next(start,1); size_iter != diamond_size.end(); size_iter++) {</p>
<p>int carry = 987654321;</p>
<p>int key_size = *size_iter;</p>
<p>if (cur_size + K &lt;key_size) break;</p>
<p>res += diamond[key_size];</p>
<p>}</p>
<p>maximum = Max(maximum, res);</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>int input;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; K;</p>
<p>diamond.clear();</p>
<p>diamond_size.clear();</p>
<p>maximum = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input; diamond[input]++;</p>
<p>diamond_size.insert(input);</p>
<p>}</p>
<p>//print out</p>
<p>for (set&lt;int&gt;::iterator size_iter = diamond_size.begin(); size_iter != diamond_size.end(); size_iter++) {</p>
<p>//cout &lt;&lt; *size_iter &lt;&lt; &quot; &quot;;</p>
<p>helper(size_iter);</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; maximum &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[159. [SAMSUNG</strong> - <strong>SW : Polynomial Calculation]</strong></p>
<p><strong>-</strong> why is this prolbem’s level D4? it was so easy.</p>
<p>- I just had to be careful data type and vector iterator.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;long long&gt; getFn(vector&lt;vector&lt;int&gt;&gt; operand, vector&lt;long long&gt; Xs) {</p>
<p>vector&lt;long long&gt; res;</p>
<p>for (const int x : Xs) {</p>
<p>vector&lt;long long&gt; Fn = { 1,x };</p>
<p>for (vector&lt;int&gt; row : operand) {</p>
<p>int t = row[0]; int a = row[1]; int b = row[2];</p>
<p>if (t == 1) {</p>
<p>Fn.emplace_back((Fn[a]+Fn[b])% 998244353);</p>
<p>}</p>
<p>else if (t == 2) {</p>
<p>Fn.emplace_back((a * Fn[b])% 998244353);</p>
<p>}</p>
<p>else if(t==3){</p>
<p>Fn.emplace_back((Fn[a] * Fn[b])% 998244353);</p>
<p>}</p>
<p>}</p>
<p>res.emplace_back(Fn.back());</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int main(int argc, char** argv)</p>
<p>{</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case)</p>
<p>{</p>
<p>vector&lt;vector&lt;int&gt;&gt; operand;</p>
<p>vector&lt;long long&gt; Xs;</p>
<p>vector&lt;long long&gt; res;</p>
<p>//get input</p>
<p>int N; cin &gt;&gt; N;</p>
<p>int t, a, b;</p>
<p>for (int i = 2; i &lt;= N; i++) {</p>
<p>cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;</p>
<p>operand.emplace_back(vector&lt;int&gt;{t, a, b});</p>
<p>}</p>
<p>int M; cin &gt;&gt; M;</p>
<p>int k;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>cin &gt;&gt; k;</p>
<p>Xs.emplace_back(k);</p>
<p>}</p>
<p>res=getFn(operand,Xs);</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case;</p>
<p>for (int i=0;i&lt;res.size();i++)</p>
<p>cout &lt;&lt; &quot; &quot; &lt;&lt; res[i];</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[160. [SAMSUNG</strong> - <strong>SW : The Longest Sequence]</strong></p>
<p><strong>-</strong>At first, I used next_permutation for brute force. but time limit exceeded occurred.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#define max(a,b) a&gt;b ? a : b</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>// 1 3 5 2 4</p>
<p>int getLongestSequenceLength(vector&lt;int&gt;&amp; numbers) {</p>
<p>int res = 0;</p>
<p>int n_size = numbers.size();</p>
<p>do {</p>
<p>for (int i = n_size - 1; i &gt;= 1 &amp;&amp; i&gt;res; i--) {</p>
<p>if (numbers[i] &gt; numbers[i - 1] &amp;&amp; numbers[i] % numbers[i - 1] == 0) {</p>
<p>int temp = 1;</p>
<p>int j;</p>
<p>for ( j = i; j &gt;= 1; j--) {</p>
<p>if (numbers[j] &gt; numbers[j - 1] &amp;&amp; numbers[j] % numbers[j - 1] == 0) {</p>
<p>temp++;</p>
<p>}</p>
<p>else break;</p>
<p>}</p>
<p>res = max(res, temp);</p>
<p>i = j+1;</p>
<p>}</p>
<p>}</p>
<p>} while (next_permutation(numbers.begin(), numbers.end()));</p>
<p>return res;</p>
<p>}</p>
<p>int main(int argc, char** argv)</p>
<p>{</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;int&gt; numbers(N);</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; numbers[i];</p>
<p>}</p>
<p>sort(numbers.begin(), numbers.end());</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; getLongestSequenceLength(numbers) &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- so I change my algorithm to DP.</p>
<p>- Dp[i] has a number of factor i has in the given vector.</p>
<p>- the point is that c style array and memset are fatser than STL array and memset. since when I used STL array and vector, time limit exceeded occurred.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#define max(a,b) a&gt;b ? a : b</p>
<p>using namespace std;</p>
<p>int dp[1000001];</p>
<p>int numbers[100001];</p>
<p>int N;</p>
<p>int main(int argc, char** argv)</p>
<p>{</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>//get input</p>
<p>memset(dp, 0, sizeof(dp));</p>
<p>memset(numbers, 0, sizeof(numbers));</p>
<p>cin &gt;&gt; N;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; numbers[i];</p>
<p>dp[numbers[i]] = 1;</p>
<p>}</p>
<p>sort(numbers,numbers+N);</p>
<p>int res = 1;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = numbers[i] * 2; j &lt;= numbers[N-1]; j += numbers[i]) {</p>
<p>if (dp[j] &gt; 0) {</p>
<p>dp[j] = max(dp[j], dp[numbers[i]] + 1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>res = max(res, dp[numbers[i]]);</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; res &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[161. [SAMSUNG</strong> - <strong>SW : Sewoon will do tomorrow]</strong></p>
<p><strong>-</strong> I used DP to check whether there is ovelapped day, but runtime error occurred. I couldn’t find the reason, so I changed my algorithm to easier way.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int getLastDay(vector&lt;pair&lt;int, int&gt;&gt;&amp; table) {</p>
<p>unordered_map&lt;int, bool&gt; dp;</p>
<p>int min_day = INT_MAX;</p>
<p>int t,d;</p>
<p>for (pair&lt;int, int&gt; row : table) {</p>
<p>t = row.first; d = row.second;</p>
<p>int start = (d - t) + 1;</p>
<p>min_day = min(min_day, start);</p>
<p>int rest_day = 0;</p>
<p>for (int i = start; i &lt;= d; i++) {</p>
<p>if (dp.count(i)) rest_day++;</p>
<p>dp[i]=true;</p>
<p>}</p>
<p>int j = start;</p>
<p>while (rest_day &gt; 0) {</p>
<p>if (!dp.count(j)) {</p>
<p>dp[j] = true;</p>
<p>rest_day--;</p>
<p>}</p>
<p>j--;</p>
<p>}</p>
<p>min_day = min(min_day, j+1);</p>
<p>}</p>
<p>return min_day - 1;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>ios_base::sync_with_stdio(0);</p>
<p>std::cin.tie(NULL);</p>
<p>std::cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T,N;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; table(N, make_pair(0, 0));</p>
<p>int t,d;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; t &gt;&gt; d;</p>
<p>table[i] = make_pair(t, d);</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; getLastDay(table) &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;//정상종료시 반드시 0을 리턴해야합니다.</p>
<p>}</p>
<p>- the revised algorithm is based on sorting alogirhtm. after sorting, if there is overlapped day, just moving current homework forward.</p>
<p>- since we took sort, we don’t need to care a case that several days are overlapped.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;cstring&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int getLastDay(vector&lt;pair&lt;int, int&gt;&gt;&amp; table) {</p>
<p>int t,d;</p>
<p>int start_day = table.back().second - table.back().first + 1;</p>
<p>table.pop_back();</p>
<p>while(!table.empty()) {</p>
<p>int te = table.back().second; int ts = te- table.back().first+1;</p>
<p>table.pop_back();</p>
<p>if (te &gt;= start_day) {</p>
<p>start_day = ts - (te - start_day+1);</p>
<p>}</p>
<p>else start_day = ts;</p>
<p>}</p>
<p>return start_day - 1;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>ios_base::sync_with_stdio(0);</p>
<p>std::cin.tie(NULL);</p>
<p>std::cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T,N;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; N;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; table(N, make_pair(0, 0));</p>
<p>int t,d;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; t &gt;&gt; d;</p>
<p>table[i] = make_pair(t, d);</p>
<p>}</p>
<p>sort(table.begin(), table.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {return a.second &lt; b.second; });</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; getLastDay(table) &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;//정상종료시 반드시 0을 리턴해야합니다.</p>
<p>}</p>
<p><strong>[162. [SAMSUNG</strong> - <strong>SW : Haji Prediction]</strong></p>
<p><strong>-</strong> they gave an algorithm and I should dertermine whethere the algorithm would end or not.</p>
<p>- so I recorded numbers appeared during algorithm and if recorded number appear again, break the while syntax and return false.</p>
<p>- but a problem was data type, N could be given up to 10^14. so I used data type LONG LONG, but I needed unsigned long long actually.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>using namespace std;</p>
<p>int main(int argc, char** argv){</p>
<p>//what is haji in here by the way?</p>
<p>ios_base::sync_with_stdio(0);</p>
<p>std::cin.tie(NULL);</p>
<p>std::cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>unsigned long long N;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; N;</p>
<p>bool flag=true;</p>
<p>unordered_map&lt;unsigned long long, bool&gt; stop;</p>
<p>while (N &gt; 1) {</p>
<p>if (stop.count(N)) {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>else stop[N] = true;</p>
<p>if (N % 2 == 0) N = N / 2;</p>
<p>else N = 3 * N + 3;</p>
<p>cout &lt;&lt; N &lt;&lt; endl;</p>
<p>}</p>
<p>if (flag) cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; YES&quot; &lt;&lt; endl;</p>
<p>else cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; NO&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[163. [SAMSUNG</strong> - <strong>SW : Palindrome Phobia]</strong></p>
<p><strong>-</strong> At first, I checked all the possible substings of all the possible strings that can be created during permutation. but time limit exceeded occurred.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>bool isPalindrome(string&amp; s) {</p>
<p>int i = 0, j = s.size() - 1;</p>
<p>while (i &lt; j) {</p>
<p>if (s[i] != s[j]) return false;</p>
<p>i++; j--;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>bool hasPalindrome(string&amp; s) {</p>
<p>int cur_size = 2;</p>
<p>int s_size = s.size();</p>
<p>string temp;</p>
<p>while (cur_size &lt;= s_size) {</p>
<p>for (int i = 0; i + cur_size &lt;= s_size; i++) {</p>
<p>temp = s.substr(i, cur_size);</p>
<p>if (isPalindrome(temp)) return true;</p>
<p>}</p>
<p>cur_size++;</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>int test_case;</p>
<p>int T;</p>
<p>ios_base::sync_with_stdio(0);</p>
<p>std::cin.tie(NULL);</p>
<p>std::cout.tie(NULL);</p>
<p>cin &gt;&gt; T;</p>
<p>string s;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; s;</p>
<p>sort(s.begin(), s.end());</p>
<p>bool flag=false;</p>
<p>do {</p>
<p>if (!hasPalindrome(s)) {</p>
<p>flag = true;</p>
<p>break;</p>
<p>}</p>
<p>} while (next_permutation(s.begin(), s.end()));</p>
<p>if (flag) cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; YES&quot; &lt;&lt; endl;</p>
<p>else cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; NO&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- so I changed my algorithm. the algorithm is that we just have character a,b or c. so to make palindrome, the most number of a character has to be 2 more than the least character.</p>
<p>- e.x) if a=4, b=3, c=2, abc abc aba. but if a=4, b=3, c=3, abc abc abc a.</p>
<p>- with the latter example, we can’t make palindrom. but with the former one we can.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>using namespace std;</p>
<p>bool isPalindrome(string&amp; s) {</p>
<p>int i = 0, j = s.size() - 1;</p>
<p>while (i &lt; j) {</p>
<p>if (s[i] != s[j]) return false;</p>
<p>i++; j--;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>bool hasPalindrome(string&amp; s) {</p>
<p>int cur_size = 2;</p>
<p>int s_size = s.size();</p>
<p>string temp;</p>
<p>while (cur_size &lt;= s_size) {</p>
<p>for (int i = 0; i + cur_size &lt;= s_size; i++) {</p>
<p>temp = s.substr(i, cur_size);</p>
<p>if (isPalindrome(temp)) return true;</p>
<p>}</p>
<p>cur_size++;</p>
<p>}</p>
<p>return false;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>int test_case;</p>
<p>int T;</p>
<p>ios_base::sync_with_stdio(0);</p>
<p>std::cin.tie(NULL);</p>
<p>std::cout.tie(NULL);</p>
<p>cin &gt;&gt; T;</p>
<p>string s;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; s;</p>
<p>int a=0, b=0, c=0;</p>
<p>int minimum = INT_MAX, maximum = INT_MIN;</p>
<p>for (char cha : s) {</p>
<p>if (cha == 'a') a++;</p>
<p>else if (cha == 'b') b++;</p>
<p>else c++;</p>
<p>}</p>
<p>minimum = min(a, min(b, c)); maximum = max(a, max(b, c));</p>
<p>if (maximum - minimum &gt; 1) cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; NO&quot; &lt;&lt; endl;</p>
<p>else cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; YES&quot; &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[164. [SAMSUNG</strong> - <strong>SW : 3 Dimentional Farmer]</strong></p>
<p><strong>-</strong> I did brute force at first, but time was problem, so I made binary search tree, but same problem</p>
<p>occurred. I think I should’ve balanced binary search tree.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>class Node {</p>
<p>public:</p>
<p>int value;</p>
<p>Node* left = nullptr;</p>
<p>Node* right = nullptr;</p>
<p>Node(int val) :value(val) {}</p>
<p>void insert(int val) {</p>
<p>if (val &lt;= value) {</p>
<p>if (left) left-&gt;insert(val);</p>
<p>else left = new Node(val);</p>
<p>}</p>
<p>else {</p>
<p>if (right) right-&gt;insert(val);</p>
<p>else right = new Node(val);</p>
<p>}</p>
<p>}</p>
<p>int find(int val,int min_dis) {</p>
<p>min_dis = min(min_dis, abs(val - value));</p>
<p>if(val==value) return 0;</p>
<p>else if (val &lt; value) {</p>
<p>if (left) return left-&gt;find(val, min_dis);</p>
<p>else return min_dis;</p>
<p>}</p>
<p>else {</p>
<p>if (right) return right-&gt;find(val, min_dis);</p>
<p>else return min_dis;</p>
<p>}</p>
<p>}</p>
<p>};</p>
<p>int main(int argc, char** argv){</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL);</p>
<p>cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>int N, M,c1,c2;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>cin &gt;&gt;c1 &gt;&gt; c2;</p>
<p>int x_distance = abs(c1 - c2);</p>
<p>int rt; cin &gt;&gt; rt;</p>
<p>Node* root = new Node(rt);</p>
<p>int input;</p>
<p>for (int i = 1; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>root-&gt;insert(input);</p>
<p>}</p>
<p>int res;</p>
<p>int cnt = 0;</p>
<p>int minimum = 987654321;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>res = root-&gt;find(input,987654321);</p>
<p>if (x_distance + res &lt; minimum) {</p>
<p>cnt = 1;</p>
<p>minimum = x_distance + res;</p>
<p>}</p>
<p>else if (x_distance + res == minimum) cnt++;</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; minimum &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- instead of it, I sorted cows’ coordinates and took binary search to get nearest distance</p>
<p>- but it corrected just 22 test case, but there are 5 more test case. I don’t know why it was wrong!</p>
<p>- see the second code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int N, M, c1, c2;</p>
<p>int bin_search(const int val,vector&lt;int&gt;&amp; cows){</p>
<p>long long left = 0, right = (long long)N - 1, mid=(left + right) / 2;</p>
<p>if (cows.front() &gt; val) return abs(cows.front() - val);</p>
<p>else if (cows.back() &lt; val) return abs(val-cows.back());</p>
<p>while (left &lt;= right) {</p>
<p>mid = (left + right) / 2;</p>
<p>if (cows[mid] == val) return 0;</p>
<p>else if (cows[mid] &gt; val) right = mid - 1;</p>
<p>else left = mid + 1;</p>
<p>}</p>
<p>if (cows[mid] &lt; val) return min(abs(cows[mid] - val), abs(cows[mid + 1] - val));</p>
<p>else return min(abs(cows[mid] - val), abs(cows[mid - 1] - val));</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL);</p>
<p>cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>cin &gt;&gt;c1 &gt;&gt; c2;</p>
<p>unordered_map&lt;long long, int&gt; cnt;</p>
<p>long long x_distance = abs(c1 - c2);</p>
<p>vector&lt;int&gt; cows(N);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; cows[i];</p>
<p>sort(cows.begin(), cows.end());</p>
<p>long long input;</p>
<p>long long minimum = INT_MAX;</p>
<p>long long res;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>res=bin_search(input,cows);</p>
<p>int distance = x_distance + res;</p>
<p>minimum = min(minimum, distance);</p>
<p>cnt[distance]++;</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; minimum &lt;&lt; &quot; &quot; &lt;&lt; cnt[minimum] &lt;&lt; endl;</p>
<p>cnt.clear();</p>
<p>cows.clear();</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- so I changed the return value of binary search to index from distance.</p>
<p>- but 3 test case weren’t solved. fuck!</p>
<p>- see the third code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int N, M, c1, c2;</p>
<p>int bin_search(const int val,vector&lt;int&gt;&amp; cows){</p>
<p>int left = 0, right = N - 1, mid=(left + right) / 2;</p>
<p>if (cows.front() &gt; val) return 0;</p>
<p>else if (cows.back() &lt; val) return N - 1;</p>
<p>while (left &lt;= right) {</p>
<p>mid = (left + right) / 2;</p>
<p>if (cows[mid] == val) return mid;</p>
<p>else if (cows[mid] &gt; val) right = mid - 1;</p>
<p>else left = mid + 1;</p>
<p>}</p>
<p>if (cows[mid] &lt; val) mid++;</p>
<p>return mid;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL);</p>
<p>cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>cin &gt;&gt;c1 &gt;&gt; c2;</p>
<p>int x_distance = abs(c1 - c2);</p>
<p>vector&lt;int&gt; cows(N);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; cows[i];</p>
<p>sort(cows.begin(), cows.end());</p>
<p>int horse;</p>
<p>int minimum = INT_MAX;</p>
<p>int idx;</p>
<p>int cnt = 0;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>cin &gt;&gt; horse;</p>
<p>idx =bin_search(horse,cows);</p>
<p>if (0 &lt;= idx &amp;&amp; idx &lt; N) {</p>
<p>int cow = cows[idx];</p>
<p>int distance = abs(cow - horse);</p>
<p>if (minimum &gt; distance) {</p>
<p>cnt = 1;</p>
<p>minimum = distance;</p>
<p>}</p>
<p>else if (minimum == distance) cnt++;</p>
<p>}</p>
<p>if (0 &lt;= idx &amp;&amp; idx &lt; N &amp;&amp; cows[idx] != horse) {</p>
<p>int cow = cows[idx - 1];</p>
<p>int distance =abs(cow - horse);</p>
<p>if (minimum &gt; distance) {</p>
<p>cnt = 1;</p>
<p>minimum = distance;</p>
<p>}</p>
<p>else if (minimum == distance) cnt++;</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; minimum+x_distance &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- I gave up.. I refer to a discussion.</p>
<p>- I think it is almost same and there is no different of time complexity. why it works but my one doesn’t?</p>
<p>- the below code is from there.</p>
<p>#include &lt;iostream&gt;</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>#include &lt;cmath&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>using namespace std;</p>
<p>int TC = 1;</p>
<p>int N, M, C1, C2, H;</p>
<p>int C[500000];</p>
<p>int bSearch(int s, int e) {</p>
<p>if (s &gt; e) return e;</p>
<p>int m = (s + e) / 2;</p>
<p>if (C[m] &lt; H) return bSearch(m + 1, e);</p>
<p>else if (C[m] == H) return m;</p>
<p>else return bSearch(s, m - 1);</p>
<p>}</p>
<p>int main() {</p>
<p>scanf(&quot;%d&quot;, &amp;TC);</p>
<p>for (int tc = 1; tc &lt;= TC; tc++) {</p>
<p>scanf(&quot;%d %d %d %d&quot;, &amp;N, &amp;M, &amp;C1, &amp;C2);</p>
<p>int DX = C1 &gt; C2 ? C1 - C2 : C2 - C1;</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>scanf(&quot;%d&quot;, &amp;C[i]);</p>
<p>sort(C, C + N);</p>
<p>int idx = 0, d, mind = 0x7fffffff;</p>
<p>int cnt = 0;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>scanf(&quot;%d&quot;, &amp;H);</p>
<p>idx = bSearch(0, N - 1);</p>
<p>for (int j = idx; j &gt;= 0; j--) {</p>
<p>d = C[j] - H;</p>
<p>if (d &lt; 0) d = -d;</p>
<p>if (d &lt; mind) {</p>
<p>mind = d;</p>
<p>cnt = 1;</p>
<p>}</p>
<p>else if (d == mind)</p>
<p>cnt++;</p>
<p>else break;</p>
<p>}</p>
<p>for (int j = idx + 1; j &lt; N; j++) {</p>
<p>d = C[j] - H;</p>
<p>if (d &lt; 0) d = -d;</p>
<p>if (d &lt; mind) {</p>
<p>mind = d;</p>
<p>cnt = 1;</p>
<p>}</p>
<p>else if (d == mind)</p>
<p>cnt++;</p>
<p>else break;</p>
<p>}</p>
<p>}</p>
<p>printf(&quot;#%d %d %d\n&quot;, tc, DX + mind, cnt);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- temp record</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int input;</p>
<p>int N, M, c1, c2;</p>
<p>vector&lt;int&gt; cows;</p>
<p>int bSearch(int s, int e) {</p>
<p>if (s &gt; e) return e;</p>
<p>int m = (s + e) / 2;</p>
<p>if (cows[m] &lt; input) return bSearch(m + 1, e);</p>
<p>else if (cows[m] == input) return m;</p>
<p>else return bSearch(s, m - 1);</p>
<p>}</p>
<p>int main(int argc, char** argv) {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL);</p>
<p>cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case) {</p>
<p>cin &gt;&gt; N; cin&gt;&gt; M;</p>
<p>cin &gt;&gt; c1; cin&gt;&gt; c2;</p>
<p>int x_distance = abs(c1 - c2);</p>
<p>cows.assign(N,0);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; cows[i];</p>
<p>sort(cows.begin(), cows.end());</p>
<p>int idx = 0, d, mind = 0x7fffffff;</p>
<p>int cnt = 0;</p>
<p>for (int i = 0; i &lt; M; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>idx = bSearch(0,N-1);</p>
<p>for (int j = idx; j &gt;= 0; j--) {</p>
<p>d = cows[j] - input;</p>
<p>if (d &lt; 0) d = -d;</p>
<p>if (d &lt; mind) {</p>
<p>mind = d;</p>
<p>cnt = 1;</p>
<p>}</p>
<p>else if (d == mind)</p>
<p>cnt++;</p>
<p>else break;</p>
<p>}</p>
<p>for (int j = idx + 1; j &lt; N; j++) {</p>
<p>d = cows[j] - input;</p>
<p>if (d &lt; 0) d = -d;</p>
<p>if (d &lt; mind) {</p>
<p>mind = d;</p>
<p>cnt = 1;</p>
<p>}</p>
<p>else if (d == mind)</p>
<p>cnt++;</p>
<p>else break;</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; mind+x_distance &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[165. [SAMSUNG</strong> - <strong>SW : Palindrome per Word]</strong></p>
<p><strong>-</strong> I used DFS and memorization, but time limit exceeded occurred.</p>
<p>- For each k, I count how many valid palindrome per word string appear.</p>
<p>- see the firse code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>string str;</p>
<p>int s_size;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit;</p>
<p>int DFS(const int k,const int s,const int e,int count) {</p>
<p>if (visit[k][s] != -1) {</p>
<p>return visit[k][s];</p>
<p>}</p>
<p>int answer = 0;</p>
<p>if (k &lt;= 1) {</p>
<p>visit[k][s] = 1;</p>
<p>return 1;</p>
<p>}</p>
<p>else if (k == 2) {</p>
<p>if (str.substr(s, (e - s) / 2 + 1) == str.substr(e - (e - s) / 2 + 1, (e - s) / 2)) {</p>
<p>visit[k][s] = 1;</p>
<p>return 1;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>for (int i = 1; (s_size - count) - k + 2 - (2 * i) &gt;= 0; i++) {</p>
<p>if (str.substr(s, i) == str.substr(e - i+1, i)) {</p>
<p>answer+=DFS(k-2, s + i,e-i,count+(2*i));</p>
<p>}</p>
<p>else continue;</p>
<p>}</p>
<p>visit[k][s] = answer;</p>
<p>return answer;</p>
<p>}</p>
<p>int splitString() {</p>
<p>int k = 1;</p>
<p>int answer = 0;</p>
<p>bool odd=false; if (s_size % 2) odd = true;</p>
<p>while (k &lt;= s_size) {</p>
<p>if (k % 2 == 0 &amp;&amp; odd) {</p>
<p>k++;</p>
<p>continue;</p>
<p>}</p>
<p>answer+=DFS(k,0,s_size-1,0);</p>
<p>k++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main(int argc, char** argv){</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL);</p>
<p>cout.tie(NULL);</p>
<p>int test_case;</p>
<p>int T;</p>
<p>cin &gt;&gt; T;</p>
<p>for (test_case = 1; test_case &lt;= T; ++test_case){</p>
<p>cin &gt;&gt; str;</p>
<p>s_size = str.size();</p>
<p>visit.assign(s_size+1, vector&lt;int&gt;(s_size/2+1, -1));</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; test_case &lt;&lt; &quot; &quot; &lt;&lt; splitString() &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- I refered to discussions to revise my algorithm.</p>
<p>- Honestly, I didn’t understand the below code well.</p>
<p>#include &lt;iostream&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>using namespace std;</p>
<p>#define SMAX 10001</p>
<p>#define MOD 1000000007</p>
<p>int TC;</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL);</p>
<p>cout.tie(NULL);</p>
<p>cin &gt;&gt; TC;</p>
<p>for (int tt = 0; tt &lt; TC; tt++) {</p>
<p>char input[SMAX];</p>
<p>cin &gt;&gt; input;</p>
<p>int cnt = 0;</p>
<p>while (input[cnt])</p>
<p>{</p>
<p>cnt++;</p>
<p>}</p>
<p>int count[SMAX] = { 1, };</p>
<p>for (int i = 0; i &lt; cnt / 2; i++) {</p>
<p>// case 0 one character is center</p>
<p>int ls = i;</p>
<p>int le = i;</p>
<p>int rs = cnt - le - 1;</p>
<p>int re = cnt - ls - 1;</p>
<p>while (ls &gt;= 0 &amp;&amp; le &lt;= (cnt - 1) / 2 &amp;&amp; input[ls] == input[rs] &amp;&amp; input[le] == input[re]) {</p>
<p>count[le + 1] = (count[le + 1] + count[ls]) % MOD;</p>
<p>ls--;</p>
<p>le++;</p>
<p>rs--;</p>
<p>re++;</p>
<p>}</p>
<p>// case 1 two characters are center</p>
<p>ls = i;</p>
<p>le = i + 1;</p>
<p>rs = cnt - le - 1;</p>
<p>re = cnt - ls - 1;</p>
<p>while (ls &gt;= 0 &amp;&amp; le &lt;= (cnt - 1) / 2 &amp;&amp; input[ls] == input[rs] &amp;&amp; input[le] == input[re]) {</p>
<p>count[le + 1] = (count[le + 1] + count[ls]) % MOD;</p>
<p>ls--;</p>
<p>le++;</p>
<p>rs--;</p>
<p>re++;</p>
<p>}</p>
<p>}</p>
<p>int all = 0;</p>
<p>for (int i = 0; i &lt; cnt / 2 + 1; i++) {</p>
<p>all = (all + count[i]) % MOD;</p>
<p>}</p>
<p>cout &lt;&lt; &quot;#&quot; &lt;&lt; tt + 1 &lt;&lt; &quot; &quot; &lt;&lt; all &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[166. [SAMSUNG</strong> - <strong>SW : Odd Medium Pyramid]</strong></p>
<p>- run time error occurred. I think there is a trick. it’s not a brute force.</p>
<p>- see the first code.</p>
<p>#include&lt;stdio.h&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>int Mid(int a, int b, int c) {</p>
<p>if ((a &gt; b&amp;&amp; b &gt; c)||(c&gt;b &amp;&amp; b&gt;a)) return b;</p>
<p>else if ((b &gt; a&amp;&amp; a &gt; c)||(c&gt;a &amp;&amp; a&gt;b)) return a;</p>
<p>else return c;</p>
<p>}</p>
<p>int main() {</p>
<p>int T;</p>
<p>scanf_s(&quot;%d&quot;, &amp;T);</p>
<p>int N, X;</p>
<p>for (int test_case = 1; test_case &lt;= T; test_case++) {</p>
<p>scanf_s(&quot;%d %d&quot;, &amp;N,&amp;X);</p>
<p>bool flag = false;</p>
<p>vector&lt;int&gt; base(2 * N - 1);</p>
<p>for (int i = 0; i &lt; base.size(); i++) base[i] = i + 1;</p>
<p>vector&lt;vector&lt;int&gt;&gt; pyramid(N, vector&lt;int&gt;(2 * N - 1, 0));</p>
<p>do {</p>
<p>int _size = base.size();</p>
<p>for (int i = 0; i &lt; base.size(); i++) pyramid[0][i] = base[i];</p>
<p>for (int level = 1; level &lt; N; level++) {</p>
<p>for (int i = 2; i &lt; _size; i++) {</p>
<p>int mid = Mid(pyramid[level-1][i - 2], pyramid[level - 1][i - 1], pyramid[level - 1][i]);</p>
<p>pyramid[level][i - 2] = mid;</p>
<p>}</p>
<p>_size -= 2;</p>
<p>}</p>
<p>if (pyramid[N - 1][0] == X) flag = true;</p>
<p>} while (next_permutation(base.begin(), base.end())&amp;&amp; !flag);</p>
<p>if (flag) printf(&quot;#%d 1\n&quot;, test_case);</p>
<p>else printf(&quot;#%d 0\n&quot;, test_case);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>- so then, what would a trick be?</p>
<p>- I found the trick! I searched results of when N is 2~5, and I found 1 and 2n-1 value didn’t appear.</p>
<p>- see the below code.</p>
<p>#include&lt;stdio.h&gt;</p>
<p>int main() {</p>
<p>int T;</p>
<p>scanf_s(&quot;%d&quot;, &amp;T);</p>
<p>int N, X;</p>
<p>for (int test_case = 1; test_case &lt;= T; test_case++) {</p>
<p>scanf_s(&quot;%d %d&quot;, &amp;N,&amp;X);</p>
<p>if (X != 1 &amp;&amp; X != (2 * N - 1)) printf(&quot;#%d 1\n&quot;, test_case);</p>
<p>else printf(&quot;#%d 0\n&quot;, test_case);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[167. [SAMSUNG</strong> - <strong>SW : Addition Problem]</strong></p>
<p><strong>-</strong> I felt like level 4 problem’s in SAMSUNG SW expert don’t ask brute force. there is always a tricked rule.</p>
<p>- this problem has trick as well. the key calculation was (b-a) * (n-2) +1.</p>
<p>- and I had to be careful of data type.</p>
<p>- see the code.</p>
<p>#include&lt;stdio.h&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>int T; scanf_s(&quot;%d&quot;, &amp;T);</p>
<p>long long n, a, b;</p>
<p>for (int tc = 1; tc &lt;= T; tc++) {</p>
<p>scanf_s(&quot;%lld %lld %lld&quot;, &amp;n, &amp;a, &amp;b);</p>
<p>if((n==1 &amp;&amp; a!=b)||a&gt;b) printf(&quot;#%d 0\n&quot;, tc);</p>
<p>else if((n==1 &amp;&amp; a==b)||n==2 ) printf(&quot;#%d 1\n&quot;, tc);</p>
<p>else {</p>
<p>printf(&quot;#%d %lld\n&quot;, tc, (b - a) * (n-2)+1);</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[168. [SAMSUNG</strong> - <strong>SW : KyeonJae and DaeHwan’s Stone Game]</strong></p>
<p><strong>-</strong> we can’t use DFS for this problem due to time complexity.</p>
<p>- so we must find a rule, the rule was if abs(r-b)&lt;2 then, DH win, otherwise KyeongJae win.</p>
<p>- I drew multiple example to find why the logic works well, but honeslty, I wasn’t able to undertand mathmatically.</p>
<p>- see the code.</p>
<p>#include&lt;stdio.h&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>int T; scanf_s(&quot;%d&quot;, &amp;T);</p>
<p>long long r, b;</p>
<p>for (int tc = 1; tc &lt;= T; tc++) {</p>
<p>scanf_s(&quot;%lld %lld&quot;, &amp;r, &amp;b);</p>
<p>if (abs(r-b) &lt; 2) printf(&quot;#%d DH\n&quot;, tc);</p>
<p>else printf(&quot;#%d KJ\n&quot;, tc);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[169. [SAMSUNG</strong> - <strong>SW : Add Parenthesis]</strong></p>
<p><strong>-</strong> wow… I spent 4 hours and half…</p>
<p>- I misunderstood the problem. I thought I had to consider all the possible pair of parenthesis without limitation of operator a parenthesis can have.</p>
<p>- but each parenthesis can has only one operator.</p>
<p>- From there, I started to revise my algorithm. but wow… I think since I don’t solve this kind of brute force or DFS problem nowdays, it took so much time.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;string&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>string s;</p>
<p>int s_size;</p>
<p>int N;</p>
<p>int answer=-987654321;</p>
<p>inline int calcul(const int a, const int b, const char c) {</p>
<p>if (c == '+') return a + b;</p>
<p>else if (c == '-') return a - b;</p>
<p>else return a * b;</p>
<p>}</p>
<p>void DFS(const int idx,int sum) {</p>
<p>if (idx &gt;= N) {</p>
<p>answer = max(answer, sum);</p>
<p>return;</p>
<p>}</p>
<p>//choose current operator</p>
<p>int cur_choose = calcul(s[idx - 1]-'0', s[idx + 1] - '0', s[idx]);</p>
<p>if (idx &gt; 1) cur_choose = calcul(sum,cur_choose , s[idx - 2]);</p>
<p>if (idx + 4 &lt; N - 1) {</p>
<p>DFS(idx + 4, cur_choose);</p>
<p>}</p>
<p>else if (idx + 2 &lt; N - 1) {</p>
<p>DFS(idx + 4, calcul(cur_choose, s[idx + 3] - '0', s[idx + 2]));</p>
<p>}</p>
<p>else DFS(idx + 4, cur_choose);</p>
<p>//otherwise</p>
<p>int not_choose = 0;</p>
<p>if(idx&gt;1) not_choose = calcul(sum, s[idx - 1] - '0', s[idx - 2]);</p>
<p>if (idx &gt; 1 &amp;&amp; idx+2&lt;N-1) DFS(idx + 2, not_choose);</p>
<p>else if (idx &gt; 1) DFS(idx+2,calcul(not_choose, s[idx + 1] - '0', s[idx]));</p>
<p>else if (idx &lt;= 1 &amp;&amp; N&gt;3) DFS(idx + 2, s[0] - '0');</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>cin &gt;&gt; N;</p>
<p>cin &gt;&gt; s;</p>
<p>if (N == 1) cout &lt;&lt; s[0] - '0';</p>
<p>else {</p>
<p>DFS(1, 0);</p>
<p>cout &lt;&lt; answer;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[170. [SAMSUNG</strong> - <strong>SW : Move Pipe 1]</strong></p>
<p><strong>-</strong> it was a simulation problem. given possible directions to move, I had to move the pipe to (N,N).</p>
<p>- I used DFS and memorization using visit vector.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(17,vector&lt;int&gt;(17,0));</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; visit(17,vector&lt;vector&lt;int&gt;&gt;(17, vector&lt;int&gt;(3,-1)));</p>
<p>/*</p>
<p>void printTable(int lx,int ly,int rx,int ry) {</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp = table;</p>
<p>temp[lx][ly] = 2; temp[rx][ry] = 2;</p>
<p>for (vector&lt;int&gt; row : temp) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>*/</p>
<p>int MovePipe(int lx, int ly, int rx, int ry,bool hori, bool verti) {</p>
<p>int answer = 0;</p>
<p>if (rx==N-1 &amp;&amp; ry==N-1) {</p>
<p>return 1;</p>
<p>}</p>
<p>int temp;</p>
<p>if (hori) {</p>
<p>if (visit[lx][ly][0] == -1) {</p>
<p>//to horizon</p>
<p>visit[lx][ly][0] = 0;</p>
<p>if (ry+1&lt;N &amp;&amp; table[rx][ry + 1] != 1) {</p>
<p>temp = MovePipe(lx, ly + 1, rx, ry + 1, true, false);</p>
<p>visit[lx][ly][0] += temp;</p>
<p>answer += temp;</p>
<p>}</p>
<p>//to diagonal</p>
<p>if (rx+1&lt;N &amp;&amp; ry+1&lt; N&amp;&amp;table[rx][ry + 1] != 1 &amp;&amp; table[rx + 1][ry] != 1 &amp;&amp; table[rx + 1][ry + 1] != 1) {</p>
<p>temp = MovePipe(lx, ly + 1, rx + 1, ry + 1, false, false);</p>
<p>visit[lx][ly][0] += temp;</p>
<p>answer += temp;</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>answer += visit[lx][ly][0];</p>
<p>}</p>
<p>}</p>
<p>else if (verti) {</p>
<p>if (visit[lx][ly][1] == -1) {</p>
<p>visit[lx][ly][1] = 0;</p>
<p>//to vertical</p>
<p>if (rx+1&lt;N &amp;&amp; table[rx + 1][ry] != 1) {</p>
<p>temp = MovePipe(lx + 1, ly, rx + 1, ry, false, true);</p>
<p>visit[lx][ly][1] += temp;</p>
<p>answer += temp;</p>
<p>}</p>
<p>//to diagonal</p>
<p>if (rx+1&lt;N &amp;&amp; ry+1&lt; N &amp;&amp;table[rx + 1][ry] != 1 &amp;&amp; table[rx + 1][ry + 1] != 1 &amp;&amp; table[rx][ry + 1] != 1) {</p>
<p>temp = MovePipe(lx + 1, ly, rx + 1, ry + 1, false, false);</p>
<p>visit[lx][ly][1] += temp;</p>
<p>answer += temp;</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>answer += visit[lx][ly][1];</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>if (visit[lx][ly][2] == -1) {</p>
<p>visit[lx][ly][2] = 0;</p>
<p>//to horizon</p>
<p>if (ry+1&lt;N &amp;&amp;table[rx][ry + 1] != 1) {</p>
<p>temp = MovePipe(lx + 1, ly + 1, rx, ry + 1, true, false);</p>
<p>visit[lx][ly][2] += temp;</p>
<p>answer += temp;</p>
<p>}</p>
<p>//to diagonal</p>
<p>if (rx+1&lt;N &amp;&amp; ry+1&lt;N &amp;&amp; table[rx + 1][ry] != 1 &amp;&amp; table[rx + 1][ry + 1] != 1 &amp;&amp; table[rx][ry + 1] != 1) {</p>
<p>temp = MovePipe(lx + 1, ly + 1, rx + 1, ry + 1, false, false);</p>
<p>visit[lx][ly][2] += temp;</p>
<p>answer += temp;</p>
<p>}</p>
<p>//to vertical</p>
<p>if (rx+1&lt;N &amp;&amp; table[rx + 1][ry] != 1) {</p>
<p>temp = MovePipe(lx + 1, ly + 1, rx + 1, ry, false, true);</p>
<p>visit[lx][ly][2] += temp;</p>
<p>answer+=temp;</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>answer += visit[lx][ly][2];</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; N; j++) cin &gt;&gt; table[i][j];</p>
<p>bool hori, verti; //if both are false, then dir is diagonal.</p>
<p>//algorithm part</p>
<p>if (table[N - 1][N - 1] == 1) cout &lt;&lt; 0;</p>
<p>else cout&lt;&lt;MovePipe(0,0,0,1,true, false);</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[171. [SAMSUNG</strong> - <strong>SW : Castle Defence]</strong></p>
<p><strong>-</strong> it was also a simulation problem.</p>
<p>- there was a limitation of way to kill an enemy by an archer. because of that, it was quite confused.</p>
<p>- the limitation was that an archer can kill a leftmost enemy with the shortest distance from oneself. the leftmost was the key of this problem.</p>
<p>- without above issue, there was nothing to consider hard.</p>
<p>- I used DFS to choose archers’ position</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#define MAX_VALUE 987654321</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int N, M, D;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;int&gt; archers;</p>
<p>int answer = 0;</p>
<p>int max_enemy;</p>
<p>bool isEmpty(vector&lt;vector&lt;int&gt;&gt;&amp; temp) {</p>
<p>for (vector&lt;int&gt; row : temp)</p>
<p>for (int i : row) if (i == 1) return false;</p>
<p>return true;</p>
<p>}</p>
<p>void printTable(vector&lt;vector&lt;int&gt;&gt;&amp; temp) {</p>
<p>for (vector&lt;int&gt; row : temp) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void moveEnemy(vector&lt;vector&lt;int&gt;&gt;&amp; temp) {</p>
<p>//Enemies come down to the castles.</p>
<p>for (int i = N - 1; i &gt;= 1; i--) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>temp[i][j] = temp[i - 1][j];</p>
<p>}</p>
<p>}</p>
<p>for (int j = 0; j &lt; M; j++) temp[0][j] = 0;</p>
<p>}</p>
<p>int PlayGame() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp = table;</p>
<p>int archer_x = N;</p>
<p>int res = 0;</p>
<p>while (!isEmpty(temp)) {</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; temp_remove(3, make_pair(MAX_VALUE, MAX_VALUE));</p>
<p>set&lt;pair&lt;int, int&gt;&gt; remove;</p>
<p>int fst_dis = MAX_VALUE; int sec_dis = MAX_VALUE; int thr_dis = MAX_VALUE;</p>
<p>for (int i = N - 1; i &gt;= 0 &amp;&amp; (abs(i-archer_x)&lt;=D); i--) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (temp[i][j] == 1) {</p>
<p>int a = (abs(i - archer_x) + abs(j - archers[0]));</p>
<p>int b = (abs(i - archer_x) + abs(j - archers[1]));</p>
<p>int c = (abs(i - archer_x) + abs(j - archers[2]));</p>
<p>//cout&lt;&lt;&quot;f,s,t : &quot; &lt;&lt; fst_dis &lt;&lt; &quot;,&quot; &lt;&lt; sec_dis &lt;&lt; &quot;,&quot; &lt;&lt; thr_dis &lt;&lt; endl;</p>
<p>//cout &lt;&lt; &quot;a,b,c :&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;,&quot; &lt;&lt; c &lt;&lt; endl;</p>
<p>if ( a &lt;= D &amp;&amp; fst_dis&gt;=a) {</p>
<p>if (fst_dis == a) {</p>
<p>if (temp_remove[0].second &gt; j) temp_remove[0] = make_pair(i, j);</p>
<p>}</p>
<p>else {</p>
<p>fst_dis = a;</p>
<p>temp_remove[0] = make_pair(i, j);</p>
<p>}</p>
<p>}</p>
<p>if ( b &lt;= D &amp;&amp; sec_dis &gt;= b) {</p>
<p>if (sec_dis == b) {</p>
<p>if (temp_remove[1].second &gt; j) temp_remove[1] = make_pair(i, j);</p>
<p>}</p>
<p>else {</p>
<p>sec_dis = b;</p>
<p>temp_remove[1] = make_pair(i, j);</p>
<p>}</p>
<p>}</p>
<p>if ( c &lt;= D &amp;&amp; thr_dis &gt;= c) {</p>
<p>if (thr_dis == c) {</p>
<p>if (temp_remove[2].second &gt; j) temp_remove[2] = make_pair(i, j);</p>
<p>}</p>
<p>else {</p>
<p>thr_dis = c;</p>
<p>temp_remove[2] = make_pair(i, j);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (pair&lt;int, int&gt; temp_re : temp_remove) if(temp_re.first!=MAX_VALUE) remove.insert(temp_re);</p>
<p>res += remove.size();</p>
<p>//cout &lt;&lt; &quot;before killing&quot; &lt;&lt; endl;</p>
<p>//printTable(temp);</p>
<p>for (pair&lt;int, int&gt; removed_enemy : remove) {</p>
<p>temp[removed_enemy.first][removed_enemy.second] = 0;</p>
<p>}</p>
<p>//cout &lt;&lt; &quot;after killing&quot; &lt;&lt; endl;</p>
<p>//printTable(temp);</p>
<p>moveEnemy(temp);</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>void DFS(int start, int count) {</p>
<p>if (count == 3) {</p>
<p>answer=max(answer,PlayGame());</p>
<p>return;</p>
<p>}</p>
<p>// if we got all the enemy by an archers' position, we don't need to do further.</p>
<p>for (int i = start; i &lt; M &amp;&amp; max_enemy!=answer; i++) {</p>
<p>archers.emplace_back(i);</p>
<p>DFS(i + 1, count + 1);</p>
<p>archers.pop_back();</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N&gt;&gt; M&gt;&gt; D;</p>
<p>table.assign(N, vector&lt;int&gt;(M));</p>
<p>int input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; input;</p>
<p>table[i][j] = input;</p>
<p>if (input == 1) max_enemy++;</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>if (isEmpty(table)) cout &lt;&lt; 0;</p>
<p>else {</p>
<p>DFS(0, 0);</p>
<p>cout &lt;&lt; answer;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[172. [SAMSUNG</strong> - <strong>SW : Attach Sugar Paper]</strong></p>
<p>- below code is my wrong algorithm. I used BFS to find maximu size of block we can attach with current connected block. but it consider just first max block. so it’s wrong.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;array&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>int dir[4][2] = { {-1,0}, {0,-1},{1,0},{0,1} }; // top left bottom right</p>
<p>vector&lt;int&gt; rest = { 5,5,5,5,5,5 };</p>
<p>int answer = 0;</p>
<p>int blockSize(array&lt;array&lt;int, 10&gt;, 10&gt;&amp; table, int x, int y) {</p>
<p>int k=0;</p>
<p>for (k = 1; k &lt; 5 ; k++) {</p>
<p>if (x + k &gt;= 10 || y + k &gt;= 10) return k - 1;</p>
<p>for (int i = x; i &lt;= x + k ; i++) if (table[i][y + k] != 1) return k-1;</p>
<p>for (int j = y; j &lt; y + k ; j++) if (table[x + k][j] != 1) return k-1;</p>
<p>}</p>
<p>if (k == 5) return k - 1;</p>
<p>return k;</p>
<p>}</p>
<p>void attach(array&lt;array&lt;int, 10&gt;, 10&gt;&amp; table, int x, int y, int m) {</p>
<p>table[x][y] = 0;</p>
<p>for (int k = 1; k &lt;= m; k++) {</p>
<p>for (int i = x; i &lt;= x + k &amp;&amp; x + k &lt; 10 &amp;&amp; y + k &lt; 10; i++) table[i][y + k] = 0;</p>
<p>for (int j = y; j &lt; y + k &amp;&amp; y + k &lt; 10 &amp;&amp; x + k &lt; 10; j++) table[x + k][j] = 0;</p>
<p>}</p>
<p>}</p>
<p>void findBlock(array&lt;array&lt;int,10&gt;,10&gt;&amp; table, int&amp; number_of_one) {</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que;</p>
<p>int sx, sy;</p>
<p>bool flag = true;</p>
<p>for (int i = 0; i &lt; 10 &amp;&amp; flag; i++) {</p>
<p>for (int j = 0; j &lt; 10; j++) {</p>
<p>if (table[i][j] == 1) {</p>
<p>sx = i; sy = j;</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>que.push(make_pair(sx,sy));</p>
<p>//BFS</p>
<p>int max_block_size = 0; int mx=sx; int my=sy;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit(10, vector&lt;int&gt;(10, 0));</p>
<p>int temp_size = 0;</p>
<p>while (!que.empty() &amp;&amp; max_block_size&lt;5) {</p>
<p>int x = que.front().first; int y = que.front().second; que.pop();</p>
<p>if (visit[x][y] == 0) {</p>
<p>visit[x][y] = 1;</p>
<p>temp_size = blockSize(table, x, y);</p>
<p>if (max_block_size &lt; temp_size &amp;&amp; rest[temp_size]!=0) {</p>
<p>max_block_size = temp_size;</p>
<p>mx = x; my = y;</p>
<p>}</p>
<p>}</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int dx = x+dir[i][0]; int dy = y+dir[i][1];</p>
<p>if ( dx &gt;= 0 &amp;&amp; dy &gt;= 0 &amp;&amp; dx &lt; 10 &amp;&amp; dy &lt; 10&amp;&amp;visit[dx][dy] == 0 &amp;&amp; table[dx][dy] == 1 )</p>
<p>que.push(make_pair(dx,dy));</p>
<p>}</p>
<p>}</p>
<p>if (rest[max_block_size] != 0) {</p>
<p>cout &lt;&lt; &quot;mx, my, size : &quot; &lt;&lt; mx &lt;&lt; &quot;,&quot; &lt;&lt; my &lt;&lt; &quot;,&quot; &lt;&lt; max_block_size + 1 &lt;&lt; endl;</p>
<p>attach(table, mx, my, max_block_size);</p>
<p>number_of_one -= (max_block_size + 1) * (max_block_size + 1);</p>
<p>answer++;</p>
<p>rest[max_block_size]--;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>array&lt;array&lt;int, 10&gt;, 10&gt; table;</p>
<p>// get input</p>
<p>int number_of_one = 0;</p>
<p>for (int i = 0; i &lt; 10; i++)</p>
<p>for (int j = 0; j &lt; 10; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 1) number_of_one++;</p>
<p>}</p>
<p>int loof_count = 0;</p>
<p>//algorithm part</p>
<p>while (number_of_one &gt; 0) {</p>
<p>if (loof_count &gt;= 50) {</p>
<p>answer = -1;</p>
<p>break;</p>
<p>}</p>
<p>findBlock(table, number_of_one);</p>
<p>loof_count++;</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>- this is revised code. I used DFS to check all the possible block I can take with current coordinates.</p>
<p>- by recording one’s position, I can have terminated DFS loof.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;array&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>array&lt;int, 5 &gt; rest_paper= {5, 5, 5, 5, 5};</p>
<p>int answer = 987654321;</p>
<p>int number_of_one = 0;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; one_pos;</p>
<p>bool attachPaper(array&lt;array&lt;int, 10&gt;, 10&gt;&amp; temp,int x,int y, int k) {</p>
<p>bool flag = true;</p>
<p>for (int i = x; i &lt;= k+x&amp;&amp;flag; i++) {</p>
<p>for (int j = y; j &lt;= k + y; j++) {</p>
<p>if (temp[i][j] == 0) {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>temp[i][j] = 0;</p>
<p>}</p>
<p>}</p>
<p>return flag;</p>
<p>}</p>
<p>void DFS(array&lt;array&lt;int, 10&gt;, 10&gt; temp,int used_paper,int start,int used_one) {</p>
<p>if (used_one == number_of_one) {</p>
<p>answer = min(answer, used_paper);</p>
<p>return;</p>
<p>}</p>
<p>else if (used_one &gt; number_of_one) return;</p>
<p>if (start &gt;= one_pos.size()) {</p>
<p>return;</p>
<p>}</p>
<p>int x = one_pos[start].first; int y = one_pos[start].second;</p>
<p>if (temp[x][y] == 0) {</p>
<p>DFS(temp, used_paper, start + 1, used_one);</p>
<p>}</p>
<p>for (int j = 0; j &lt; 5; j++) {</p>
<p>if (rest_paper[j] == 0) continue;</p>
<p>if (x + j &gt;= 10 || y + j &gt;= 10) break;</p>
<p>rest_paper[j]--;</p>
<p>array&lt;array&lt;int, 10&gt;, 10&gt; next_table=temp;</p>
<p>bool flag=attachPaper(next_table, x, y, j);</p>
<p>used_one += (j + 1) * (j + 1);</p>
<p>if(flag) DFS(next_table, used_paper+1,start+1,used_one);</p>
<p>used_one -= (j + 1) * (j + 1);</p>
<p>rest_paper[j]++;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>array&lt;array&lt;int, 10&gt;, 10&gt; table;</p>
<p>// get input</p>
<p>for (int i = 0; i &lt; 10; i++)</p>
<p>for (int j = 0; j &lt; 10; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>if (table[i][j] == 1) {</p>
<p>number_of_one++;</p>
<p>one_pos.emplace_back(make_pair(i, j));</p>
<p>}</p>
<p>}</p>
<p>// algorithm part</p>
<p>DFS(table, 0, 0, 0);</p>
<p>if (answer == 987654321) cout &lt;&lt; -1;</p>
<p>else cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[173. [SAMSUNG</strong> - <strong>SW : Baseball]</strong></p>
<p><strong>-</strong> What the heck? I spent 4 hours…</p>
<p>- I first misunderstood the problem. since they gave me a rule that once I decide an order of players, I can’t change it even if inning is changed. but I thought I have to find optimum score we can get using find all the path we can reach. so I did brute force for every inning.</p>
<p>- because of that, I spend quite much time.</p>
<p>- second problem was scoring, I tried to make score function iteratively, but it didn’t work well. actually I don’t make sense why it was wrong until now!.</p>
<p>- so I changed that part a hard code.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;array&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;int&gt; order;</p>
<p>int answer = 0;</p>
<p>void printInning(vector&lt;int&gt;&amp; inning) {</p>
<p>for (int i : inning) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void Game() {</p>
<p>int cur_player = 0;</p>
<p>int res = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>array&lt;bool, 4&gt; base = { false,false,false,false };</p>
<p>int outs = 0;</p>
<p>vector&lt;int&gt; temp;</p>
<p>for (int j = 0; j &lt; 8; j++) temp.emplace_back(table[i][order[j]]);</p>
<p>temp.insert(next(temp.begin(), 3), table[i][0]);</p>
<p>while (outs &lt; 3) {</p>
<p>int cur_hit = temp[cur_player];</p>
<p>if (cur_hit == 0) {</p>
<p>outs++;</p>
<p>cur_player = (cur_player + 1) % 9;</p>
<p>continue;</p>
<p>}</p>
<p>else if (cur_hit == 4) {</p>
<p>for (int c = 3; c &gt;= 1; c--) {</p>
<p>if (base[c]) res++;</p>
<p>base[c] = false;</p>
<p>}</p>
<p>res++;</p>
<p>}</p>
<p>else if (cur_hit == 1) {</p>
<p>if (base[3]) {</p>
<p>res++;</p>
<p>base[3] = false;</p>
<p>}</p>
<p>if (base[2]) {</p>
<p>base[3] = true; base[2] = false;</p>
<p>}</p>
<p>if (base[1]) {</p>
<p>base[2] = true; base[1] = false;</p>
<p>}</p>
<p>base[1] = true;</p>
<p>}</p>
<p>else if (cur_hit == 2) {</p>
<p>if (base[3]) {</p>
<p>res++; base[3] = false;</p>
<p>}</p>
<p>if (base[2]) {</p>
<p>res++; base[2] = false;</p>
<p>}</p>
<p>if (base[1]) {</p>
<p>base[3] = true; base[1] = false;</p>
<p>}</p>
<p>base[2] = true;</p>
<p>}</p>
<p>else {</p>
<p>if (base[3]) {</p>
<p>res++; base[3] = false;</p>
<p>}</p>
<p>if (base[2]) {</p>
<p>res++; base[2] = false;</p>
<p>}</p>
<p>if (base[1]) {</p>
<p>res++; base[1] = false;</p>
<p>}</p>
<p>base[3] = true;</p>
<p>}</p>
<p>cur_player = (cur_player + 1) % 9;</p>
<p>}</p>
<p>}</p>
<p>answer = max(answer, res);</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N,vector&lt;int&gt;(9));</p>
<p>int input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; 9; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>for (int i = 1; i &lt; 9; i++) order.emplace_back(i);</p>
<p>//algorithm part</p>
<p>do {</p>
<p>Game();</p>
<p>} while (next_permutation(order.begin(), order.end()));</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[174. [SAMSUNG</strong> - <strong>SW : Brainfuck Interpreter]</strong></p>
<p><strong>-</strong> like the name, it was a fucking interpreter.</p>
<p>- they gave an ambiguous rule about infinite loop. because of that, I struggled to solve it hard.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#define MAX_VALUE 256</p>
<p>using namespace std;</p>
<p>map&lt;int, int&gt; parenthesis_left;</p>
<p>map&lt;int, int&gt; parenthesis_right;</p>
<p>pair&lt;int,int&gt; loop;</p>
<p>bool flag = false;</p>
<p>void getPair(string brainfuck) {</p>
<p>vector&lt;int&gt; temp;</p>
<p>for (int i = 0; i &lt; brainfuck.size(); i++) {</p>
<p>if (brainfuck[i] == '[') {</p>
<p>temp.emplace_back(i);</p>
<p>}</p>
<p>else if (brainfuck[i] == ']') {</p>
<p>parenthesis_left[temp.back()] = i;</p>
<p>parenthesis_right[i] = temp.back();</p>
<p>temp.pop_back();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void operate(vector&lt;int&gt;&amp; memory,string&amp; brainfuck,int&amp; order_index,int&amp; pointer,string&amp; input,int&amp; input_index) {</p>
<p>char order = brainfuck[order_index];</p>
<p>switch (order) {</p>
<p>case '-':</p>
<p>memory[pointer] -= 1;</p>
<p>if (memory[pointer] &lt; 0) memory[pointer] = 255;</p>
<p>order_index++;</p>
<p>break;</p>
<p>case '+':</p>
<p>memory[pointer] = (memory[pointer] + 1) % 256;</p>
<p>order_index++;</p>
<p>break;</p>
<p>case '&lt;':</p>
<p>pointer--;</p>
<p>if (pointer &lt; 0) pointer = memory.size() - 1;</p>
<p>order_index++;</p>
<p>break;</p>
<p>case '&gt;':</p>
<p>pointer = (pointer + 1) % memory.size();</p>
<p>order_index++;</p>
<p>break;</p>
<p>case '[':</p>
<p>if (memory[pointer] == 0) {</p>
<p>order_index = parenthesis_left[order_index];</p>
<p>break;</p>
<p>}</p>
<p>order_index++;</p>
<p>break;</p>
<p>case ']':</p>
<p>loop.first = parenthesis_right[order_index];</p>
<p>loop.second = order_index;</p>
<p>if (memory[pointer] != 0) {</p>
<p>order_index = parenthesis_right[order_index];</p>
<p>break;</p>
<p>}</p>
<p>order_index++;</p>
<p>break;</p>
<p>case '.':</p>
<p>order_index++;</p>
<p>break;</p>
<p>case ',':</p>
<p>int temp_input;</p>
<p>if (input_index &lt; input.size()) {</p>
<p>temp_input = (int)input[input_index];</p>
<p>memory[pointer] = temp_input;</p>
<p>}</p>
<p>else memory[pointer] = 255;</p>
<p>input_index++;</p>
<p>order_index++;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>int t; cin &gt;&gt; t;</p>
<p>//for each test case</p>
<p>int m, c, i;</p>
<p>string brainfuck;</p>
<p>string input;</p>
<p>vector&lt;int&gt; memory;</p>
<p>for (int qq = 0; qq &lt; t; qq++) {</p>
<p>//get input</p>
<p>cin &gt;&gt; m &gt;&gt; c &gt;&gt; i&gt;&gt; brainfuck&gt;&gt; input;</p>
<p>memory.assign(m, 0);</p>
<p>//algoirhtm part</p>
<p>getPair(brainfuck); //get parenthesis pair</p>
<p>int order_index = 0;</p>
<p>int pointer = 0;</p>
<p>int cnt = 0;</p>
<p>int input_index = 0;</p>
<p>flag = true;</p>
<p>loop = make_pair(-1, -1);</p>
<p>int max_order_index = 0;</p>
<p>while (cnt&lt; 50000000) {</p>
<p>if (order_index&gt;=c) {</p>
<p>cout &lt;&lt; &quot;Terminates&quot; &lt;&lt; endl;</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>operate(memory,brainfuck, order_index,pointer, input,input_index);</p>
<p>cnt++;</p>
<p>max_order_index = order_index &gt; max_order_index ? order_index : max_order_index;</p>
<p>}</p>
<p>if (flag) {</p>
<p>cout &lt;&lt; &quot;Loops &quot; &lt;&lt; parenthesis_right[max_order_index] &lt;&lt; &quot; &quot; &lt;&lt; max_order_index &lt;&lt; endl;</p>
<p>}</p>
<p>//map clear</p>
<p>parenthesis_left.clear();</p>
<p>parenthesis_right.clear();</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[175. [KAKAO 2019</strong> – <strong>Winter Internship : Claw Crane Game]</strong></p>
<p><strong>-</strong> this was so easy. I think I don’t need comment for this problem.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int solution(vector&lt;vector&lt;int&gt;&gt; board, vector&lt;int&gt; moves) {</p>
<p>int answer = 0;</p>
<p>//find top</p>
<p>vector&lt;int&gt; tops(board[0].size(), 0);</p>
<p>for (int j = 0; j &lt; board[0].size(); j++) {</p>
<p>for (int i = 0; i &lt; board.size(); i++) {</p>
<p>if (board[i][j] != 0) {</p>
<p>tops[j] = i;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>vector&lt;int&gt; stk;</p>
<p>for (int index : moves) {</p>
<p>if (tops[index - 1] &gt;= board.size()) continue;</p>
<p>int cur_char = board[tops[index - 1]][index - 1];</p>
<p>tops[index - 1]++;</p>
<p>if (!stk.empty() &amp;&amp; stk.back() == cur_char) {</p>
<p>answer += 2;</p>
<p>stk.pop_back();</p>
<p>}</p>
<p>else {</p>
<p>stk.push_back(cur_char);</p>
<p>}</p>
<p>//[1,5,3,5,1,2,1,4]</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout&lt;&lt;solution({ {0, 0, 0, 0, 0},{0, 0, 1, 0, 3},{0, 2, 5, 0, 1},{4, 2, 4, 4, 2},{3, 5, 1, 3, 1} }, { 1, 5, 3, 5, 1, 2, 1, 4 });</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[176. [KAKAO 2019</strong> – <strong>Winter Internship : Tuple]</strong></p>
<p>- just testing that I know the use of vector and find algorithm.</p>
<p>- string parsing was the key point.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#include &lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; solution(string s) {</p>
<p>vector&lt;int&gt; answer;</p>
<p>vector&lt;vector&lt;int&gt;&gt; res(501);</p>
<p>int max_size = 0;</p>
<p>//solution(&quot;{{2},{2,1},{2,1,3},{2,1,3,4}}&quot;);</p>
<p>for (int i = 2; i &lt; s.size() - 1; i++) {</p>
<p>if (s[i] == '{' || s[i] == ',') continue;</p>
<p>string temp = &quot;&quot;;</p>
<p>int input;</p>
<p>vector&lt;int&gt; temp_res;</p>
<p>int j;</p>
<p>for (j = i; j &lt; s.size() - 1 ; j++) {</p>
<p>if (s[j] == ',' || s[j]=='}') {</p>
<p>input = stoi(temp);</p>
<p>temp_res.emplace_back(input);</p>
<p>temp = &quot;&quot;;</p>
<p>if (s[j] == '}') break;</p>
<p>}</p>
<p>else {</p>
<p>temp += s[j];</p>
<p>}</p>
<p>}</p>
<p>max_size = temp_res.size() &gt; max_size ? temp_res.size() : max_size;</p>
<p>res[temp_res.size()] = temp_res;</p>
<p>i = j;</p>
<p>}</p>
<p>vector&lt;int&gt; make_tuple;</p>
<p>make_tuple.emplace_back(res[1][0]);</p>
<p>for (int i = 2; i &lt;= max_size; i++) {</p>
<p>for (int j = 0; j &lt; res[i].size(); j++) {</p>
<p>if (find(make_tuple.begin(), make_tuple.end(), res[i][j]) == make_tuple.end()) {</p>
<p>make_tuple.emplace_back(res[i][j]);</p>
<p>break;</p>
<p>}</p>
<p>else continue;</p>
<p>}</p>
<p>}</p>
<p>return make_tuple;</p>
<p>}</p>
<p>int main() {</p>
<p>solution(&quot;{{20,111},{111}}&quot;);</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[177. [KAKAO 2019</strong> – <strong>Winter Internship : Banned User]</strong></p>
<p><strong>-</strong> doing permutation was the key point.</p>
<p>- thanks to time limit was not that restric. I’ve solved easily using DFS – permutation.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;set&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int answer = 0;</p>
<p>vector&lt;vector&lt;string&gt;&gt; possible;</p>
<p>vector&lt;vector&lt;string&gt;&gt; temp_answer;</p>
<p>set&lt;set&lt;string&gt;&gt; res_answer;</p>
<p>int ban_size;</p>
<p>void DFS(vector&lt;string&gt; current_set, int index) {</p>
<p>if (index &gt;= ban_size) {</p>
<p>set&lt;string&gt; res;</p>
<p>for (string tt : current_set) {</p>
<p>res.insert(tt);</p>
<p>}</p>
<p>if (res.size() == ban_size) res_answer.insert(res);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = 0; i &lt; possible[index].size(); i++) {</p>
<p>current_set.emplace_back(possible[index][i]);</p>
<p>DFS(current_set, index + 1);</p>
<p>current_set.pop_back();</p>
<p>}</p>
<p>}</p>
<p>int solution(vector&lt;string&gt; user_id, vector&lt;string&gt; banned_id) {</p>
<p>possible.assign(banned_id.size(), vector&lt;string&gt;{});</p>
<p>for (int j = 0; j &lt; banned_id.size(); j++) {</p>
<p>string ban = banned_id[j];</p>
<p>for (string user : user_id) {</p>
<p>if (ban.size() != user.size()) continue;</p>
<p>bool flag = true;</p>
<p>for (int i = 0; i &lt; ban.size(); i++) {</p>
<p>if (ban[i] == '*' || ban[i] == user[i]) continue;</p>
<p>if (ban[i] != user[i]) {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if (flag) possible[j].emplace_back(user);</p>
<p>}</p>
<p>}</p>
<p>ban_size = possible.size();</p>
<p>DFS(vector&lt;string&gt;{}, 0);</p>
<p>for (set&lt;string&gt; ress : res_answer) {</p>
<p>if (ress.size() != ban_size) continue;</p>
<p>answer++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p><strong>[178. [KAKAO 2019</strong> – <strong>Winter Internship : Allocate Hotel Room]</strong></p>
<p><strong>-</strong> this problem has efficiency test. the key was the union-find structure.</p>
<p>- but without knowing union-find structure, we colud solve it. I’ve solved this problem using recursion with unorderd_map.</p>
<p>- the map has pair as a value, the first of the pair is prev, the second is next. but I think now, I just need the second. so we just have to make unordered_map&lt;int,int&gt; structure.</p>
<p>- if map[input_room] is empty, then we just push the room number into answer vector.</p>
<p>- if the map is not empty, then give the map[input_room].second to next recursion until we find empty room. after that, we revise each key’s second to new next room.</p>
<p>- it’s hard to describe in written language. just see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include &lt;unordered_map&gt;</p>
<p>using namespace std;</p>
<p>unordered_map&lt;long long, pair&lt;long long, long long&gt;&gt; next_room;</p>
<p>vector&lt;long long&gt; answer;</p>
<p>void recursion(long long wanted_room) {</p>
<p>if (next_room.find(wanted_room) == next_room.end()) {</p>
<p>answer.emplace_back(wanted_room);</p>
<p>next_room[wanted_room].first = 0;</p>
<p>next_room[wanted_room].second = wanted_room + 1;</p>
<p>return;</p>
<p>}</p>
<p>else {</p>
<p>recursion(next_room[wanted_room].second);</p>
<p>long long next = next_room[next_room[wanted_room].second].second;</p>
<p>next_room[wanted_room].second = next;</p>
<p>return;</p>
<p>}</p>
<p>}</p>
<p>vector&lt;long long&gt; solution(long long k, vector&lt;long long&gt; room_number) {</p>
<p>for (long long wanted_room : room_number) {</p>
<p>recursion(wanted_room);</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p><strong>[179. [KAKAO 2019</strong> – <strong>Winter Internship : Stepping Stones]</strong></p>
<p>- this problem also has efficiency test. my first try pass all the accuracy test, but not efficiency test.</p>
<p>- see my first code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int solution(vector&lt;int&gt; input_stones, int max_interval) {</p>
<p>int answer = 0;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; stones; // pair&lt;value,next_stone&gt;</p>
<p>stones.emplace_back(make_pair(200000001, 1)); //start position</p>
<p>for (int i = 0; i &lt; input_stones.size(); i++) stones.emplace_back(make_pair(input_stones[i], i + 2));</p>
<p>//algorithm part</p>
<p>while (true) {</p>
<p>bool stop_flag = false;</p>
<p>for (int i = 1; i &lt; stones.size(); i++) {</p>
<p>//when the stone's value is greater than 1</p>
<p>if (stones[i].first != 0) {</p>
<p>stones[i].first--;</p>
<p>if (stones[i].first == 0) {</p>
<p>int next = stones[i].second;</p>
<p>for (int j = i - 1; j &gt;= 0; j--) {</p>
<p>if (stones[j].first != 0) {</p>
<p>stones[j].second = next;</p>
<p>break;</p>
<p>}</p>
<p>else stones[j].second = next;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//when the stone's value is 0</p>
<p>else {</p>
<p>if (stones[i - 1].second - (i-1) &gt; max_interval) {</p>
<p>stop_flag = true;</p>
<p>break;</p>
<p>}</p>
<p>i = stones[i - 1].second - 1; // -1 is to make up for 'for' syntax's i++</p>
<p>}</p>
<p>}</p>
<p>if (stop_flag) break;</p>
<p>else answer++;</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; solution({2, 4, 5, 3, 2, 1, 4, 2, 5, 1},3);</p>
<p>return 0;</p>
<p>}</p>
<p>- let’s figure out to pass the efficiency test.</p>
<p>- I think we don’t need to travel all the stone, since for each person, all the stone’s value is subtracted by 1.</p>
<p>- if we use binary search, we can solve this problem easily. mid is the value we check for each iteration whether the mid number of people can pass the stepping stones or not.</p>
<p>- so if mid number of people can pass, take right half, or take left half.</p>
<p>- see the code.</p>
<p>#include &lt;string&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#define MAX_VALUE 200000000</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int answer = 0;</p>
<p>bool isPossibleToJump(vector&lt;int&gt;&amp; stones,int mid,int max_interval) {</p>
<p>int cnt = 0;</p>
<p>for (int i = 0; i &lt; stones.size(); i++) {</p>
<p>if (stones[i] - (mid-1) &lt;= 0) {</p>
<p>cnt++;</p>
<p>if (cnt &gt;= max_interval) return false;</p>
<p>}</p>
<p>else cnt = 0;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>void binarySearch(vector&lt;int&gt;&amp; stones,int left, int right,int max_interval) {</p>
<p>if (left &gt; right) return;</p>
<p>int mid = (right + left) / 2;</p>
<p>bool flag = isPossibleToJump(stones, mid, max_interval);</p>
<p>if (flag) {</p>
<p>answer = max(answer, mid);</p>
<p>binarySearch(stones, mid + 1, right, max_interval);</p>
<p>}</p>
<p>else {</p>
<p>binarySearch(stones, left, mid - 1, max_interval);</p>
<p>}</p>
<p>}</p>
<p>int solution(vector&lt;int&gt; stones, int max_interval) {</p>
<p>binarySearch(stones, 0, MAX_VALUE, max_interval);</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>cout &lt;&lt; solution({2, 4, 5, 3, 2, 1, 4, 2, 5, 1},3);</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[180. [KAKAO 2017 : Coloring Book]</strong></p>
<p><strong>-</strong> this was a simulation problem. I solved using BFS.</p>
<p>- it’s quite long time since I used BFS lastly. so It took much more time.</p>
<p>- see the code.</p>
<p>#include &lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;iostream&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} }; // north west south east</p>
<p>int BFS(int _x, int _y, vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;vector&lt;bool&gt;&gt;&amp; visit) {</p>
<p>int cur_size = 0;</p>
<p>int color = table[_x][_y];</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que;</p>
<p>que.push(make_pair(_x, _y));</p>
<p>visit[_x][_y] = true;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front().first; int y = que.front().second;</p>
<p>que.pop();</p>
<p>cur_size++;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; visit[nx][ny] == false &amp;&amp; table[nx][ny] == color) {</p>
<p>que.push(make_pair(nx, ny));</p>
<p>visit[nx][ny] = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return cur_size;</p>
<p>}</p>
<p>vector&lt;int&gt; solution(int row_size, int col_size, vector&lt;vector&lt;int&gt;&gt; picture) {</p>
<p>N = row_size; M = col_size;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(M, false));</p>
<p>int area = 0;</p>
<p>int max_size = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (visit[i][j] == false &amp;&amp; picture[i][j] != 0) {</p>
<p>area++;</p>
<p>int cur_size=BFS(i, j, picture,visit);</p>
<p>max_size = max(max_size, cur_size);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>vector&lt;int&gt; answer(2);</p>
<p>answer[0] = area;</p>
<p>answer[1] = max_size;</p>
<p>cout &lt;&lt; answer[0] &lt;&lt; &quot;,&quot; &lt;&lt; answer[1] &lt;&lt; endl;</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>solution(6, 4, { {1, 1, 1, 0},{1, 2, 2, 0},{1, 0, 0, 1},{0, 0, 0, 1},{0, 0, 0, 3},{0, 0, 0, 3} });</p>
<p>//solution(6, 4, { {1, 1, 1, 0},{1, 1, 1, 0},{0, 0, 0, 1},{0, 0, 0, 1},{0, 0, 0, 1},{0, 0, 0, 1} });</p>
<p>//solution(4, 6, {{1,1,1,1,0,0}, {1,1,1,0,0,0},{2,2,0,0,3,3}, {2,0,1,0,3,3} });</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[181. [SAMSUNG SW – Rotate Array 4]</strong></p>
<p>- this was a simulation problem.</p>
<p>- I had to rotate part of given 2D array clock-wisely, and caclutate minimum value among each row.</p>
<p>- I was able to choose rotating order to minimize the answer value. I implemented a permutation using DFS.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int N, M, K;</p>
<p>int answer = 987654321;</p>
<p>vector&lt;vector&lt;int&gt;&gt; rotates;</p>
<p>vector&lt;bool&gt; visit;</p>
<p>vector&lt;vector&lt;int&gt;&gt; rotateTable(vector&lt;vector&lt;int&gt;&gt; temp_table,vector&lt;int&gt; temp_rotate) {</p>
<p>int r = temp_rotate[0] - 1; int c = temp_rotate[1] - 1; int s = temp_rotate[2];</p>
<p>int tx = r - s; int ty = c - s; int bx = r + s; int by = c + s;</p>
<p>//rotating part</p>
<p>while (tx&lt;bx &amp;&amp; ty&lt;by) {</p>
<p>int start_val = temp_table[tx][ty];</p>
<p>for (int i = tx; i &lt; bx; i++) temp_table[i][ty] = temp_table[i + 1][ty];</p>
<p>for (int j = ty; j &lt; by; j++) temp_table[bx][j] = temp_table[bx][j + 1];</p>
<p>for (int i = bx; i &gt; tx; i--) temp_table[i][by] = temp_table[i - 1][by];</p>
<p>for (int j = by; j &gt; ty + 1; j--) temp_table[tx][j] = temp_table[tx][j - 1];</p>
<p>temp_table[tx][ty + 1] = start_val;</p>
<p>tx++; ty++; bx--; by--;</p>
<p>}</p>
<p>return temp_table;</p>
<p>}</p>
<p>void getMinimum(vector&lt;vector&lt;int&gt;&gt;&amp; temp_table) {</p>
<p>int minimum = 987654321;</p>
<p>for (vector&lt;int&gt; row : temp_table) {</p>
<p>int temp_sum = 0;</p>
<p>for (int i : row) temp_sum += i;</p>
<p>minimum = min(minimum, temp_sum);</p>
<p>}</p>
<p>answer = min(answer, minimum);</p>
<p>}</p>
<p>void permutation(vector&lt;vector&lt;int&gt;&gt; temp_table,int start) {</p>
<p>if (start &gt;= K) {</p>
<p>getMinimum(temp_table);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>if (visit[i] == false) {</p>
<p>visit[i] = true;</p>
<p>permutation(rotateTable(temp_table, rotates[i]), start + 1);</p>
<p>visit[i] = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>// get input</p>
<p>cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(N, vector&lt;int&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>rotates.assign(K, vector&lt;int&gt;(3, 0));</p>
<p>visit.assign(K, false);</p>
<p>for (int i = 0; i &lt; K; i++) cin &gt;&gt; rotates[i][0] &gt;&gt; rotates[i][1] &gt;&gt; rotates[i][2];</p>
<p>//algorithm part</p>
<p>permutation(table,0);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[182. [SAMSUNG SW – Gerrymandering 1]</strong></p>
<p>- Checking two districts are connected each other or not was the main point of this problem.</p>
<p>- To split district, I used permutation – DFS, and to check connection, I used queue.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;climits&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;int&gt; people;</p>
<p>vector&lt;bool&gt; visit;</p>
<p>int answer = INT_MAX;</p>
<p>void calcul(vector&lt;int&gt;&amp; dis_a, vector&lt;int&gt;&amp; dis_b) {</p>
<p>int sum_a = 0; int sum_b = 0;</p>
<p>for (int i : dis_a) sum_a += people[i];</p>
<p>for (int i : dis_b) sum_b += people[i];</p>
<p>answer = min(answer, abs(sum_a -sum_b));</p>
<p>}</p>
<p>bool isValid(vector&lt;int&gt;&amp; dis_a, vector&lt;int&gt;&amp; dis_b) {</p>
<p>if (dis_a.empty() || dis_b.empty()) return false;</p>
<p>int size_a = dis_a.size(); int size_b = dis_b.size();</p>
<p>queue&lt;int&gt; que;</p>
<p>que.push(dis_a[0]);</p>
<p>unordered_set&lt;int&gt; res_a; unordered_set&lt;int&gt; res_b;</p>
<p>vector&lt;bool&gt; visit_a(N, false); vector&lt;bool&gt; visit_b(N, false);</p>
<p>visit_a[que.front()] = true;</p>
<p>res_a.insert(que.front());</p>
<p>while (!que.empty()) {</p>
<p>int cur_a = que.front(); que.pop();</p>
<p>for (int i = 0; i &lt; table[cur_a].size(); i++) {</p>
<p>if (find(dis_a.begin(), dis_a.end(), table[cur_a][i]) != dis_a.end() &amp;&amp; visit_a[table[cur_a][i]]==false) {</p>
<p>visit_a[table[cur_a][i]] = true;</p>
<p>que.push(table[cur_a][i]);</p>
<p>res_a.insert(table[cur_a][i]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (res_a.size() != size_a) return false;</p>
<p>que.push(dis_b[0]);</p>
<p>visit_b[que.front()] = true;</p>
<p>res_b.insert(que.front());</p>
<p>while (!que.empty()) {</p>
<p>int cur_b = que.front(); que.pop();</p>
<p>for (int i = 0; i &lt; table[cur_b].size(); i++) {</p>
<p>if (find(dis_b.begin(), dis_b.end(), table[cur_b][i]) != dis_b.end() &amp;&amp; visit_b[table[cur_b][i]] == false) {</p>
<p>visit_b[table[cur_b][i]] = true;</p>
<p>que.push(table[cur_b][i]);</p>
<p>res_b.insert(table[cur_b][i]);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (res_b.size() != size_b) return false;</p>
<p>return true;</p>
<p>}</p>
<p>void DFS(vector&lt;int&gt; dis_a,int start) {</p>
<p>if (start == N-1) return;</p>
<p>for (int i = start; i &lt; N; i++) {</p>
<p>if (visit[i] == false) {</p>
<p>vector&lt;int&gt; dis_b;</p>
<p>visit[i] = true;</p>
<p>dis_a.emplace_back(i);</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>if (find(dis_a.begin(), dis_a.end(), j) == dis_a.end()) {</p>
<p>dis_b.emplace_back(j);</p>
<p>}</p>
<p>}</p>
<p>if (isValid(dis_a, dis_b)) calcul(dis_a, dis_b);</p>
<p>DFS(dis_a, start + 1);</p>
<p>dis_a.pop_back();</p>
<p>visit[i] = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;());</p>
<p>people.assign(N, 0);</p>
<p>visit.assign(N, false);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; people[i];</p>
<p>int edge;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; edge;</p>
<p>table[i].assign(edge, 0);</p>
<p>for (int j = 0; j &lt; edge; j++) {</p>
<p>int temp_input;</p>
<p>cin &gt;&gt; temp_input;</p>
<p>table[i][j] = temp_input - 1;;</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>DFS(vector&lt;int&gt;{}, 0);</p>
<p>if (answer == INT_MAX) cout &lt;&lt; -1;</p>
<p>else cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[182. [SAMSUNG SW – Making Bridge 2]</strong></p>
<p><strong>-</strong> At first, I used brute force using permutation but it was hard to check all island was connected.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>int number_of_island = 0;</p>
<p>int needed_bridge = 0;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} }; //tx ty bx by size</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>unordered_map&lt;int, vector&lt;int&gt;&gt; map_of_land;</p>
<p>map&lt;pair&lt;int, int&gt;, int&gt; bridge;</p>
<p>int answer = 987654321;</p>
<p>bool isConnected(set&lt;set&lt;int&gt;&gt;&amp; temp_table) {</p>
<p>unordered_set&lt;int&gt; res;</p>
<p>for (set&lt;set&lt;int&gt;&gt;::iterator iter = temp_table.begin(); iter != temp_table.end(); iter++) {</p>
<p>for (set&lt;int&gt;::iterator inner = iter-&gt;begin(); inner != iter-&gt;end(); inner++) {</p>
<p>res.insert(*inner);</p>
<p>}</p>
<p>}</p>
<p>if (res.size() == number_of_island) return true;</p>
<p>return false;</p>
<p>}</p>
<p>void nameDistrict(int x, int y,int name) {</p>
<p>table[x][y] = name;</p>
<p>visit[x][y] = true;</p>
<p>if (map_of_land[name][2] &lt; x) map_of_land[name][2] = x;</p>
<p>if (map_of_land[name][3] &lt; y) map_of_land[name][3] = y;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == 1 &amp;&amp; visit[nx][ny]==false) {</p>
<p>map_of_land[name][4]++;</p>
<p>nameDistrict(nx, ny, name);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void findMinimumBridge() {</p>
<p>//horizontal bridge</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>int cur_land = 1;</p>
<p>int sy = 0;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] != 0 &amp;&amp; cur_land != table[i][j]) {</p>
<p>if (j - sy - 1 &gt;= 2 &amp;&amp; cur_land!=1) {</p>
<p>if (bridge.find(make_pair(cur_land, table[i][j])) == bridge.end()) {</p>
<p>bridge[make_pair(cur_land, table[i][j])] = j - sy - 1;</p>
<p>}</p>
<p>else bridge[make_pair(cur_land, table[i][j])] = min(bridge[make_pair(cur_land, table[i][j])], j - sy + 1);</p>
<p>}</p>
<p>cur_land = table[i][j];</p>
<p>sy = j;</p>
<p>}</p>
<p>else if (cur_land == table[i][j]) {</p>
<p>sy = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//vertical bridge</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>int cur_land = 1;</p>
<p>int sx = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>if (table[i][j] != 0 &amp;&amp; cur_land != table[i][j]) {</p>
<p>if (i - sx - 1 &gt;= 2 &amp;&amp; cur_land!=1) {</p>
<p>if (bridge.find(make_pair(cur_land, table[i][j])) == bridge.end()) {</p>
<p>bridge[make_pair(cur_land, table[i][j])] = i - sx - 1;</p>
<p>}</p>
<p>else bridge[make_pair(cur_land, table[i][j])] = min(bridge[make_pair(cur_land, table[i][j])], i - sx + 1);</p>
<p>}</p>
<p>cur_land = table[i][j];</p>
<p>sx = i;</p>
<p>}</p>
<p>else if (cur_land == table[i][j]) sx = i;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Permutation(set&lt;set&lt;int&gt;&gt; temp_table,int start,int sum,map&lt;pair&lt;int,int&gt;,int&gt;::iterator next_iter) {</p>
<p>if (start &gt;= needed_bridge) {</p>
<p>if (isConnected(temp_table)) {</p>
<p>answer = min(answer, sum);</p>
<p>for (set&lt;set&lt;int&gt;&gt;::iterator iter = temp_table.begin(); iter != temp_table.end(); iter++) {</p>
<p>for (set&lt;int&gt;::iterator inner = iter-&gt;begin(); inner != iter-&gt;end(); inner++) {</p>
<p>cout &lt;&lt; *inner &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; &quot;, &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl &lt;&lt; &quot;answer : &quot; &lt;&lt; answer &lt;&lt; endl;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator iter = next_iter; iter != bridge.end(); iter++) {</p>
<p>temp_table.insert(set&lt;int&gt;{iter-&gt;first.first,iter-&gt;first.second});</p>
<p>Permutation(temp_table, start + 1, sum + iter-&gt;second, next(iter,1));</p>
<p>temp_table.erase(temp_table.find(set&lt;int&gt;{iter-&gt;first.first, iter-&gt;first.second}));</p>
<p>}</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; M; j++) cin &gt;&gt; table[i][j];</p>
<p>visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>//algorithm part</p>
<p>// 1. counting island and make their name</p>
<p>// the name start with 2</p>
<p>int name = 2;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == 1) {</p>
<p>map_of_land[name] = vector&lt;int&gt;{ i,j,i,j,1 };</p>
<p>number_of_island++;</p>
<p>nameDistrict(i, j, name++);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>needed_bridge = number_of_island - 1;</p>
<p>cout &lt;&lt; endl;</p>
<p>printTable();</p>
<p>cout &lt;&lt; endl;</p>
<p>// 2. making bridge</p>
<p>findMinimumBridge();</p>
<p>for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator iter = bridge.begin(); iter != bridge.end(); iter++) {</p>
<p>cout &lt;&lt; iter-&gt;first.first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;first.second &lt;&lt; &quot;,&quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>Permutation(set&lt;set&lt;int&gt;&gt;{},0,0,bridge.begin());</p>
<p>if (answer == 987654321) cout &lt;&lt; -1;</p>
<p>else cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>- so I changed it to Kurskal algorithm.</p>
<p>- hu.. fucking Kruskal. there are lots of thing to think!</p>
<p>- I spent 2 hours and half… In this stance, I couldn’t get through the SAMSUNG coding test…</p>
<p>- I have to push myself up.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>int number_of_island = 0;</p>
<p>int needed_bridge = 0;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} }; //tx ty bx by size</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>unordered_map&lt;int, vector&lt;int&gt;&gt; map_of_land;</p>
<p>map&lt;pair&lt;int, int&gt;, int&gt; bridge;</p>
<p>unordered_set&lt;int&gt; has_bridge;</p>
<p>int answer = 987654321;</p>
<p>void nameDistrict(int x, int y,int name) {</p>
<p>table[x][y] = name;</p>
<p>visit[x][y] = true;</p>
<p>if (map_of_land[name][2] &lt; x) map_of_land[name][2] = x;</p>
<p>if (map_of_land[name][3] &lt; y) map_of_land[name][3] = y;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == 1 &amp;&amp; visit[nx][ny]==false) {</p>
<p>map_of_land[name][4]++;</p>
<p>nameDistrict(nx, ny, name);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void findMinimumBridge() {</p>
<p>//horizontal bridge</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>int cur_land = 1;</p>
<p>int sy = 0;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] != 0 &amp;&amp; cur_land != table[i][j]) {</p>
<p>if (j - sy - 1 &gt;= 2 &amp;&amp; cur_land!=1) {</p>
<p>if (bridge.find(make_pair(cur_land, table[i][j])) == bridge.end()) {</p>
<p>bridge[make_pair(cur_land, table[i][j])] = j - sy - 1;</p>
<p>}</p>
<p>else bridge[make_pair(cur_land, table[i][j])] = min(bridge[make_pair(cur_land, table[i][j])], j - sy - 1);</p>
<p>}</p>
<p>cur_land = table[i][j];</p>
<p>sy = j;</p>
<p>}</p>
<p>else if (cur_land == table[i][j]) {</p>
<p>sy = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//vertical bridge</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>int cur_land = 1;</p>
<p>int sx = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>if (table[i][j] != 0 &amp;&amp; cur_land != table[i][j]) {</p>
<p>if (i - sx - 1 &gt;= 2 &amp;&amp; cur_land!=1) {</p>
<p>if (bridge.find(make_pair(cur_land, table[i][j])) == bridge.end()) {</p>
<p>bridge[make_pair(cur_land, table[i][j])] = i - sx - 1;</p>
<p>}</p>
<p>else bridge[make_pair(cur_land, table[i][j])] = min(bridge[make_pair(cur_land, table[i][j])], i - sx - 1);</p>
<p>}</p>
<p>cur_land = table[i][j];</p>
<p>sx = i;</p>
<p>}</p>
<p>else if (cur_land == table[i][j]) sx = i;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int Kruskal(int sum) {</p>
<p>int cur_size = 1;</p>
<p>while (cur_size&lt;needed_bridge) {</p>
<p>int temp_x; int temp_y; int temp_dis = 987654321;</p>
<p>for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator iter = bridge.begin(); iter != bridge.end(); iter++) {</p>
<p>if ((has_bridge.find(iter-&gt;first.first) != has_bridge.end() || has_bridge.find(iter-&gt;first.second) != has_bridge.end()) &amp;&amp;</p>
<p>!(has_bridge.find(iter-&gt;first.first) != has_bridge.end() &amp;&amp; has_bridge.find(iter-&gt;first.second) != has_bridge.end())) {</p>
<p>if (iter-&gt;second &lt; temp_dis) {</p>
<p>temp_x = iter-&gt;first.first; temp_y = iter-&gt;first.second; temp_dis = iter-&gt;second;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (temp_dis == 987654321) return -1;</p>
<p>bridge.erase(bridge.find(make_pair(temp_x, temp_y)));</p>
<p>//cout &lt;&lt; &quot;x : &quot; &lt;&lt; temp_x &lt;&lt; &quot; y : &quot; &lt;&lt; temp_y &lt;&lt; &quot; dis : &quot; &lt;&lt; temp_dis &lt;&lt; endl;</p>
<p>has_bridge.insert(temp_x); has_bridge.insert(temp_y);</p>
<p>cur_size++;</p>
<p>sum += temp_dis;</p>
<p>}</p>
<p>/*for (unordered_set&lt;int&gt;::iterator iter = has_bridge.begin(); iter != has_bridge.end(); iter++)</p>
<p>cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;*/</p>
<p>if (has_bridge.size() != number_of_island) return -1;</p>
<p>return sum;</p>
<p>}</p>
<p>void printTable() {</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M));</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; M; j++) cin &gt;&gt; table[i][j];</p>
<p>visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>//algorithm part</p>
<p>// 1. counting island and make their name</p>
<p>// the name start with 2</p>
<p>int name = 2;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == 1) {</p>
<p>map_of_land[name] = vector&lt;int&gt;{ i,j,i,j,1 };</p>
<p>number_of_island++;</p>
<p>nameDistrict(i, j, name++);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>needed_bridge = number_of_island - 1;</p>
<p>//cout &lt;&lt; endl;</p>
<p>//printTable();</p>
<p>//cout &lt;&lt; endl;</p>
<p>// 2. making bridge</p>
<p>findMinimumBridge();</p>
<p>/*for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator iter = bridge.begin(); iter != bridge.end(); iter++) {</p>
<p>cout &lt;&lt; iter-&gt;first.first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;first.second &lt;&lt; &quot;,&quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;*/</p>
<p>int temp_dis = 987654321;</p>
<p>int temp_x; int temp_y;</p>
<p>if (bridge.empty()) {</p>
<p>cout &lt;&lt; -1;</p>
<p>return 0;</p>
<p>}</p>
<p>for (map&lt;pair&lt;int, int&gt;, int&gt;::iterator iter = bridge.begin(); iter != bridge.end(); iter++) {</p>
<p>if (iter-&gt;second &lt; temp_dis) {</p>
<p>temp_dis = iter-&gt;second;</p>
<p>temp_x = iter-&gt;first.first; temp_y = iter-&gt;first.second;</p>
<p>}</p>
<p>}</p>
<p>bridge.erase(bridge.find(make_pair(temp_x, temp_y)));</p>
<p>has_bridge.insert(temp_x); has_bridge.insert(temp_y);</p>
<p>cout&lt;&lt;Kruskal(temp_dis);</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[183. [SAMSUNG SW – Quit The Job 2]</strong></p>
<p>- it has been a while since I’ve met DP problem.</p>
<p>- it was not that ambiguous and complex, but one condition has held my back</p>
<p>- I started with end like backpropagation, if (i+ table[i].first)&gt; N+1, that is if he can’t finish the counsel, the most efficient way to get paid is to take money[i]=money[i+1].</p>
<p>- otherwise, max(today pay + next possible counsel pay,money[i+1]) is optimal. since money[i+1] is made as optimal from end of day( the quit day).</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define max(a,b) a&gt;b? a:b</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; table;</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N+1,pair&lt;int,int&gt;());</p>
<p>int duration; int pay;</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>cin &gt;&gt; duration &gt;&gt; pay;</p>
<p>table[i] = make_pair(duration, pay);</p>
<p>}</p>
<p>//algorithm part</p>
<p>vector&lt;long long&gt; money(N+2,0);</p>
<p>int max_money = 0;</p>
<p>for (int i = N; i &gt;= 1; i--) {</p>
<p>if (table[i].first + i &gt; N + 1) money[i] = money[i + 1];</p>
<p>else {</p>
<p>if (table[i].first + i&lt;= N) money[i] = max(table[i].second + money[table[i].first + i], money[i + 1]);</p>
<p>else if (i + 1 &lt;= N) money[i] = max(table[i].second, money[i + 1]);</p>
<p>else money[i] = table[i].second;</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; money[1] &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[184. [SAMSUNG SW – Chess Board Re-Painting]</strong></p>
<p>- it was a slicing and brute force problem. but understading the problem is pretty hard. since they took a word “Square”. I’ve been confused whether the “Square” is chess board’s small 1x1 square or 8x8 whole square.</p>
<p>- except that there was nothing to make me confused.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;array&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>array&lt;array&lt;char, 8&gt;, 8&gt; board;</p>
<p>void Slicing(int x, int y){</p>
<p>for (int i = x; i &lt; x + 8; i++) {</p>
<p>for (int j = y; j &lt; y + 8; j++) {</p>
<p>board[i-x][j-y] = table[i][j];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int getMinimum() {</p>
<p>//when start with white</p>
<p>int white_num = 0;</p>
<p>for (int i = 0; i &lt; 8; i++) {</p>
<p>for (int j = 0; j &lt; 8; j++) {</p>
<p>if ((i + j) % 2 == 0 &amp;&amp; board[i][j] == 'B') white_num++;</p>
<p>if ((i + j) % 2 == 1 &amp;&amp; board[i][j] == 'W') white_num++;</p>
<p>}</p>
<p>}</p>
<p>//when start with black</p>
<p>int black_num = 0;</p>
<p>for (int i = 0; i &lt; 8; i++) {</p>
<p>for (int j = 0; j &lt; 8; j++) {</p>
<p>if ((i + j) % 2 == 0 &amp;&amp; board[i][j] == 'W') black_num++;</p>
<p>if ((i + j) % 2 == 1 &amp;&amp; board[i][j] == 'B') black_num++;</p>
<p>}</p>
<p>}</p>
<p>return min(black_num, white_num);</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int answer = 987654321;</p>
<p>for (int i = 0; i + 7 &lt; N; i++) {</p>
<p>for (int j = 0; j + 7 &lt; M; j++) {</p>
<p>Slicing(i, j);</p>
<p>answer=min(answer,getMinimum());</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[185. [SAMSUNG SW – Treasure]</strong></p>
<p>- this problem had a trick that if we use next_permutation, time limit exceeded occur.</p>
<p>- so we have to find an algorithm but the algorithm was not that hard.</p>
<p>- we should just mulitply a’s minimum value with b’s maximum value for each round.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>int N; cin &gt;&gt; N;</p>
<p>vector&lt;int&gt; table_a(N);</p>
<p>vector&lt;int&gt; table_b(N);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; table_a[i];</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; table_b[i];</p>
<p>sort(table_a.begin(), table_a.end());</p>
<p>sort(table_b.begin(), table_b.end(), [](int a, int b) { return a &gt; b; });</p>
<p>//algorithm part</p>
<p>int i = 0;</p>
<p>int answer = 0;</p>
<p>while (i&lt;N) {</p>
<p>answer += table_a[i] * table_b[i];</p>
<p>i++;</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[186. [SAMSUNG SW – Teaching]</strong></p>
<p>- it was a selective permutation problem. all the word in antarctica start with “anta” and end with “tica”. so we teach students at least more than 5 letters. Therefore, if K&lt;=4, return is 0.</p>
<p>- Otherwise, after teaching ‘a’, ‘c’,’ ‘I’, ‘n’, ‘t’, we have to choose which letters we teach next. I used permutation for this section.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int N, K;</p>
<p>vector&lt;string&gt; table;</p>
<p>vector&lt;int&gt; rest_letter;</p>
<p>vector&lt;bool&gt; letters(26, false);</p>
<p>int answer = 0;</p>
<p>int rest_size;</p>
<p>bool isPossibleToRead(string s) {</p>
<p>for (int i = 4; i &lt; s.size() - 4; i++) if (letters[s[i] - 'a'] == false) return false;</p>
<p>return true;</p>
<p>}</p>
<p>void Permutation(int learned_letter,int start) {</p>
<p>if (learned_letter &gt;= K) {</p>
<p>int temp_res = 0;</p>
<p>for (string s : table) if (isPossibleToRead(s)) temp_res++;</p>
<p>answer = max(answer, temp_res);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = start; i &lt; rest_size; i++) {</p>
<p>letters[rest_letter[i]] = true;</p>
<p>Permutation(learned_letter + 1, i + 1);</p>
<p>letters[rest_letter[i]] = false;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>// get input</p>
<p>cin &gt;&gt; N &gt;&gt; K;</p>
<p>if (K &lt;= 4) {</p>
<p>cout &lt;&lt; 0;</p>
<p>return 0;</p>
<p>}</p>
<p>table.assign(N,&quot;&quot;);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; table[i];</p>
<p>//algorithm part</p>
<p>letters['a' - 'a'] = true; letters['n' - 'a'] = true; letters['t' - 'a'] = true; letters['c' - 'a'] = true; letters['i' - 'a'] = true;</p>
<p>for (int i = 0; i &lt; 26; i++) if (letters[i] == false) rest_letter.emplace_back(i);</p>
<p>rest_size = rest_letter.size();</p>
<p>Permutation(5,0);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[187. [SAMSUNG SW – KING]</strong></p>
<p>- it was an easy simulation problem. I had to just follow given moving order.</p>
<p>- it has an restriction to move king that after moving king, if there is stone, stone also have to be moved. but this restriction was so easy to implement.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;array&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;map&gt;</p>
<p>using namespace std;</p>
<p>array&lt;array&lt;int, 8&gt;, 8&gt; board;</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>string stone; string king; int N;</p>
<p>cin &gt;&gt; king &gt;&gt; stone &gt;&gt; N;</p>
<p>vector&lt;string&gt; orders(N,&quot;&quot;);</p>
<p>for (int i = 0; i &lt; N; i++) cin &gt;&gt; orders[i];</p>
<p>int sy =stone[0] - 'A'; int sx = 8 - (stone[1] - '0');</p>
<p>int ky = king[0] - 'A'; int kx = 8 - (king[1] - '0' );</p>
<p>//algorithm part</p>
<p>map&lt;string, pair&lt;int, int&gt;&gt; direction;</p>
<p>direction[&quot;R&quot;] = make_pair(0, 1); direction[&quot;L&quot;] = make_pair(0, -1); direction[&quot;B&quot;] = make_pair(1, 0); direction[&quot;T&quot;] = make_pair(-1, 0);</p>
<p>direction[&quot;RT&quot;] = make_pair(-1, 1); direction[&quot;LT&quot;] = make_pair(-1, -1); direction[&quot;RB&quot;] = make_pair(1, 1); direction[&quot;LB&quot;] = make_pair(1, -1);</p>
<p>for (string s : orders) {</p>
<p>int dx = direction[s].first; int dy = direction[s].second;</p>
<p>if (sx == dx + kx &amp;&amp; sy == dy + ky) {</p>
<p>if (sx + dx &lt; 0 || sy + dy &lt; 0 || sx + dx &gt;= 8 || sy + dy &gt;= 8 || kx + dx &lt; 0 || ky + dy &lt; 0 || kx + dx &gt;= 8 || ky + dy &gt;= 8) continue;</p>
<p>else kx = dx + kx; ky = dy + ky; sx = dx + sx; sy = dy + sy;</p>
<p>}</p>
<p>else if (kx + dx &gt;= 0 &amp;&amp; ky + dy &gt;= 0 &amp;&amp; kx + dx &lt; 8 &amp;&amp; ky + dy &lt; 8) {</p>
<p>kx = dx + kx; ky = dy + ky;</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; char('A' + ky) &lt;&lt; 8 - kx &lt;&lt; endl;</p>
<p>cout &lt;&lt; char('A' + sy) &lt;&lt; 8 - sx &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[188. [SAMSUNG SW – Z]</strong></p>
<p>- it was a binary search problem. Actually, it was a quaternary search.</p>
<p>- we can divide whole square to 4 district, top_left, top_right, bottom_left and bottom_right.</p>
<p>- and each value follows below rule.</p>
<p>&gt; top_left = top_left, top_right = top_left + 4^(n-1),</p>
<p>&gt; bottom_left = top_left + 2 * 4^(n-1), bottom_right = top_left + 3 * 4^(n-1)</p>
<p>- Downsizing the square for each round, we re-determine which district has (r,c).</p>
<p>- if N==1 or top_left +1 ==top_right, then end of while.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>using namespace std;</p>
<p>int N, r, c;</p>
<p>long long top_left, top_right, bottom_left, bottom_right;</p>
<p>void resizing() {</p>
<p>if (r &lt; pow(2, N - 1) &amp;&amp; c &lt; pow(2, N - 1)) { //top_left</p>
<p>}</p>
<p>else if (r &lt; pow(2, N - 1) &amp;&amp; c &gt;= pow(2, N - 1)) {//top_right</p>
<p>top_left = top_right;</p>
<p>c -= pow(2, N - 1);</p>
<p>}</p>
<p>else if (r &gt;= pow(2, N - 1) &amp;&amp; c &lt; pow(2, N - 1)) {//bottom_left</p>
<p>top_left = bottom_left;</p>
<p>r -= pow(2, N - 1);</p>
<p>}</p>
<p>else {//bottom_right</p>
<p>top_left = bottom_right;</p>
<p>c -= pow(2, N - 1);</p>
<p>r -= pow(2, N - 1);</p>
<p>}</p>
<p>N--;</p>
<p>top_right = top_left + pow(4, N - 1);</p>
<p>bottom_left= top_left + 2*pow(4, N - 1);</p>
<p>bottom_right = top_left + 3 * pow(4, N - 1);</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; r &gt;&gt; c;</p>
<p>//algorithm part</p>
<p>// tr = 4^(n-1) + top_left, bl = 2 * 4^(n-1) + top_left , br = 3 * 4^(n-1) + top_left ,</p>
<p>top_left = 0, top_right = pow(4,N-1), bottom_left = 2 * pow(4, N-1), bottom_right = 3 * pow(4, N-1); //default number</p>
<p>while (N&gt;1) {</p>
<p>resizing();</p>
<p>}</p>
<p>if (r == 0 &amp;&amp; c == 0) cout &lt;&lt; top_left;</p>
<p>else if (r == 0 &amp;&amp; c == 1) cout &lt;&lt; top_right;</p>
<p>else if (r == 1 &amp;&amp; c == 0) cout &lt;&lt; bottom_left;</p>
<p>else cout &lt;&lt; bottom_right;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[189. [SAMSUNG SW – Mafia]</strong></p>
<p>- I felt that I have to read Question more deeply. since I’ve missed a restriction that if rest number of people is even, mafia turn. Otherwise, citizen’s turn.</p>
<p>- because of that, I spent so much time.</p>
<p>- I felt one more thing that it’s more effience that just implement max score rather than using sort algorithm in the algorithm header.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>//bool end_game = false;</p>
<p>int N;</p>
<p>int mafia_pos;</p>
<p>vector&lt;pair&lt;int, bool&gt;&gt; people; //score and is_dead?</p>
<p>vector&lt;vector&lt;int&gt;&gt; R;</p>
<p>int answer = 0;</p>
<p>void DFS(int rest, int night) {</p>
<p>//if (end_game) return;</p>
<p>if (people[mafia_pos].second == true || rest &lt;= 1) {</p>
<p>answer = max(answer, night);</p>
<p>//if (rest == 1 &amp;&amp; people[mafia_pos].second == false) end_game = true;</p>
<p>return;</p>
<p>}</p>
<p>if (rest % 2 == 0) { //mafia time</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>if (people[i].second == true || i == mafia_pos) continue;</p>
<p>people[i].second = true;</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>if (people[j].second==true) continue;</p>
<p>people[j].first += R[i][j];</p>
<p>}</p>
<p>DFS(rest - 1, night + 1);</p>
<p>//if (end_game) return;</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>if (people[j].second == true) continue;</p>
<p>people[j].first -= R[i][j];</p>
<p>}</p>
<p>people[i].second = false;</p>
<p>}</p>
<p>}</p>
<p>else { //citizen time</p>
<p>int max_score = 0;</p>
<p>int min_index = 987654321;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>if (people[i].second == true) continue;</p>
<p>if (people[i].first &gt; max_score) {</p>
<p>max_score = people[i].first;</p>
<p>min_index = i;</p>
<p>}</p>
<p>else if (people[i].first == max_score) {</p>
<p>min_index = min(min_index, i);</p>
<p>}</p>
<p>}</p>
<p>people[min_index].second = true;</p>
<p>DFS(rest - 1, night);</p>
<p>//if (end_game) return;</p>
<p>people[min_index].second = false;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>people.assign(N,pair&lt;int,int&gt;());</p>
<p>R.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>int temp_input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; temp_input;</p>
<p>people[i] = make_pair(temp_input, false);</p>
<p>}</p>
<p>for (int i = 0; i &lt; N; i++)</p>
<p>for (int j = 0; j &lt; N; j++) cin &gt;&gt; R[i][j];</p>
<p>cin &gt;&gt; mafia_pos;</p>
<p>//algoirithm part</p>
<p>DFS(N,0);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[190. [SAMSUNG SW – Game]</strong></p>
<p>- It was a typical simulation problem. but tricks were there.</p>
<p>- First trick was we had to use memorization to avoid time limit abort.</p>
<p>- Second trick was how to handle an infinite loop, I avoided infinite loop by recording all the path I passed earlier current shell. and then if next shell is in the record. It will be infinite.</p>
<p>- I implemeted this using DFS.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int N, M; //row_size, col_size</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} }; // w a s d</p>
<p>int answer = 0;</p>
<p>set&lt;pair&lt;int, int&gt;&gt; visit;</p>
<p>vector&lt;vector&lt;int&gt;&gt; shell_visit;</p>
<p>bool flag = false;</p>
<p>int DFS(int x, int y,int cnt) {</p>
<p>if (shell_visit[x][y] != -1) {</p>
<p>return cnt+shell_visit[x][y];</p>
<p>}</p>
<p>int move_num = table[x][y] - '0';</p>
<p>int max_move = 1;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + (dir[i][0] * move_num); int ny = y + (dir[i][1] * move_num);</p>
<p>if (visit.find(make_pair(nx, ny)) != visit.end()) { // infinite loop</p>
<p>flag = true;</p>
<p>return 0;</p>
<p>}</p>
<p>visit.insert(make_pair(nx, ny));</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != 'H') {</p>
<p>max_move = max(max_move, DFS(nx,ny,cnt+1)-cnt);</p>
<p>}</p>
<p>visit.erase(visit.find(make_pair(nx, ny)));</p>
<p>}</p>
<p>shell_visit[x][y] = max_move;</p>
<p>return cnt+max_move;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>shell_visit.assign(N, vector&lt;int&gt;(M, -1));</p>
<p>string input_string;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input_string;</p>
<p>for (int j = 0; j &lt; M; j++) table[i][j] = input_string[j];</p>
<p>}</p>
<p>//algorithm part</p>
<p>answer=DFS(0, 0, 0);</p>
<p>visit.insert(make_pair(0, 0));</p>
<p>if (flag) cout &lt;&lt; -1;</p>
<p>else cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[191. [SAMSUNG SW – Pool]</strong></p>
<p>- it has been quite long time since I met this kind of a high level problem.</p>
<p>- it was a simulation problem. but it was hard to make it satisfy all the rule.</p>
<p>- I started sied of the pool from 1. if I met less value than current considering value, plus 1 to the shell using BFS.</p>
<p>- that’s meaning is that if we can reach from side with current value, we don’t need to care to fill water.</p>
<p>- so after that, with traveling all the shell, if we meet less value than current considering value, that is we can’t reach from side. so add 1 to answer value and make the shell plused 1.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include &lt;queue&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>int N, M; //&lt;= 50</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int max_wall = 0;</p>
<p>void BFS(int height) {</p>
<p>queue&lt;pair&lt;int, int&gt;&gt; que;</p>
<p>que.push(make_pair(0, 0));</p>
<p>table[0][0] = height;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front().first; int y = que.front().second; que.pop();</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt;= N + 1 &amp;&amp; ny &lt;= M + 1 &amp;&amp; table[nx][ny]&lt;height) {</p>
<p>table[nx][ny] = height;</p>
<p>que.push(make_pair(nx, ny));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>int answer = 0;</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N+2, vector&lt;int&gt;(M+2, 0));</p>
<p>string input;</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j+1] = input[j] - '0';</p>
<p>max_wall = max(max_wall, input[j]-'0');</p>
<p>}</p>
<p>}</p>
<p>//algorithm part;</p>
<p>for (int h = 1; h &lt;= max_wall; h++) {</p>
<p>BFS(h);</p>
<p>for (int i = 1; i &lt;= N; i++) {</p>
<p>for (int j = 1; j &lt;= M; j++) {</p>
<p>if (table[i][j] &lt; h) {</p>
<p>answer++;</p>
<p>table[i][j]++;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[192. [SAMSUNG SW – Moon is being filled up, Let’s go!]</strong></p>
<p>- it was a simulation problem with memorization. so I used BFS but there were lots of things to remember. I mean, to memorize in queue.</p>
<p>- so memory size exceeded.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>pair&lt;int, int&gt; start_pos;</p>
<p>map&lt;pair&lt;int, int&gt;,bool&gt; end_pos;</p>
<p>int N, M;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>inline bool doWeHaveTheKey(char door, unordered_map&lt;char, bool&gt; has_key) {</p>
<p>switch (door){</p>
<p>case 'A':</p>
<p>if (has_key.find('a') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'B':</p>
<p>if (has_key.find('b') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'C':</p>
<p>if (has_key.find('c') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'D':</p>
<p>if (has_key.find('d') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'E':</p>
<p>if (has_key.find('e') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'F':</p>
<p>if (has_key.find('f') != has_key.end()) return true;</p>
<p>return false;</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>int BFS(int x, int y) {</p>
<p>queue&lt;pair&lt;vector&lt;vector&lt;bool&gt;&gt;,pair&lt;vector&lt;int&gt;,unordered_map&lt;char,bool&gt;&gt;&gt;&gt; que;</p>
<p>unordered_map&lt;char, bool&gt; has_key;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(M, false)); //when we get a key, we have to re-allocate visit matrix.</p>
<p>visit[x][y] = true;</p>
<p>que.push(make_pair(visit,make_pair(vector&lt;int&gt;{x,y,0},has_key)));</p>
<p>int sum = 0;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front().second.first[0]; y = que.front().second.first[1]; sum = que.front().second.first[2];</p>
<p>has_key = que.front().second.second; visit = que.front().first; que.pop();</p>
<p>if (end_pos.find(make_pair(x, y)) != end_pos.end()) return sum;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1]; unordered_map&lt;char, bool&gt; temp_has_key = has_key; vector&lt;vector&lt;bool&gt;&gt; temp_visit = visit;</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != '#' &amp;&amp; temp_visit[nx][ny] == false) {</p>
<p>if ('a' &lt;= table[nx][ny] &amp;&amp; table[nx][ny] &lt;= 'f') { //when we meet a key</p>
<p>temp_has_key[table[nx][ny]] = true;</p>
<p>temp_visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>}</p>
<p>if ('A' &lt;= table[nx][ny] &amp;&amp; table[nx][ny] &lt;= 'F' ) { //when we meet a door</p>
<p>if(doWeHaveTheKey(table[nx][ny],has_key)) table[nx][ny] = '.';</p>
<p>else {</p>
<p>temp_visit[nx][ny] = true;</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<p>temp_visit[nx][ny] = true;</p>
<p>que.push(make_pair(temp_visit,make_pair(vector&lt;int&gt;{nx,ny,sum+1}, temp_has_key)));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>string input;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>if (input[j] == '0') start_pos = make_pair(i, j) ;</p>
<p>else if(input[j]=='1') end_pos[make_pair(i, j)] = true;</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int answer = 0;</p>
<p>answer=BFS(start_pos.first, start_pos.second);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>- I had to downsize memory size.</p>
<p>- I resolve memory problem. but time limit problem occurred.</p>
<p>- see the second code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>pair&lt;int, int&gt; start_pos;</p>
<p>map&lt;pair&lt;int, int&gt;,bool&gt; end_pos;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>queue&lt;pair&lt;unordered_map&lt;char, bool&gt;,vector&lt;int&gt;&gt;&gt; stop_pos;</p>
<p>int N, M;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int answer = 987654321;</p>
<p>inline bool doWeHaveTheKey(char door, unordered_map&lt;char, bool&gt; has_key) {</p>
<p>switch (door){</p>
<p>case 'A':</p>
<p>if (has_key.find('a') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'B':</p>
<p>if (has_key.find('b') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'C':</p>
<p>if (has_key.find('c') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'D':</p>
<p>if (has_key.find('d') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'E':</p>
<p>if (has_key.find('e') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'F':</p>
<p>if (has_key.find('f') != has_key.end()) return true;</p>
<p>return false;</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>void DFS(int x, int y, int sum, unordered_map&lt;char, bool&gt; has_key) {</p>
<p>if (end_pos.find(make_pair(x, y)) != end_pos.end()) {</p>
<p>answer = min(answer, sum);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != '#' &amp;&amp; visit[nx][ny] == false) {</p>
<p>if ('a' &lt;= table[nx][ny] &amp;&amp; table[nx][ny] &lt;= 'f') {</p>
<p>unordered_map&lt;char, bool&gt; temp_has_key = has_key;</p>
<p>temp_has_key[table[nx][ny]] = true;</p>
<p>stop_pos.push(make_pair(temp_has_key,vector&lt;int&gt;{nx, ny, sum + 1}));</p>
<p>table[nx][ny] = '.';</p>
<p>}</p>
<p>if ('A' &lt;= table[nx][ny] &amp;&amp; table[nx][ny] &lt;= 'F') {</p>
<p>if (doWeHaveTheKey(table[nx][ny], has_key)) table[nx][ny] = '.';</p>
<p>else {</p>
<p>visit[nx][ny] = true;</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<p>visit[nx][ny] = true;</p>
<p>DFS(nx, ny, sum + 1,has_key);</p>
<p>visit[nx][ny] = false;</p>
<p>}</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>string input;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>if (input[j] == '0') start_pos = make_pair(i, j) ;</p>
<p>else if(input[j]=='1') end_pos[make_pair(i, j)] = true;</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>unordered_map&lt;char, bool&gt; has_key;</p>
<p>stop_pos.push(make_pair(has_key,vector&lt;int&gt;{start_pos.first, start_pos.second, 0}));</p>
<p>while (!stop_pos.empty()) {</p>
<p>int x = stop_pos.front().second[0]; int y = stop_pos.front().second[1]; int sum = stop_pos.front().second[2];</p>
<p>has_key = stop_pos.front().first; stop_pos.pop();</p>
<p>visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>visit[x][y] = true;</p>
<p>DFS(x,y,sum, has_key);</p>
<p>}</p>
<p>if (answer == 987654321) cout &lt;&lt; -1;</p>
<p>else cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>- Now, I had to reduce time complexity.</p>
<p>- I solved it using bit mask and 3D visit array. In terms of visit array, if we have different key at current shell, its status is different. so we have to check which key we have.</p>
<p>- it was so hard…</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>pair&lt;int, int&gt; start_pos;</p>
<p>vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visit;</p>
<p>int N, M;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>inline bool doWeHaveTheKey(char door, unordered_map&lt;char, bool&gt; has_key) {</p>
<p>switch (door) {</p>
<p>case 'A':</p>
<p>if (has_key.find('a') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'B':</p>
<p>if (has_key.find('b') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'C':</p>
<p>if (has_key.find('c') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'D':</p>
<p>if (has_key.find('d') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'E':</p>
<p>if (has_key.find('e') != has_key.end()) return true;</p>
<p>return false;</p>
<p>case 'F':</p>
<p>if (has_key.find('f') != has_key.end()) return true;</p>
<p>return false;</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>int BFS(int x, int y) {</p>
<p>queue&lt;pair&lt;pair&lt;int, int&gt;, pair&lt;int,int&gt;&gt;&gt; que; //x,y, key,sum</p>
<p>que.push(make_pair(make_pair(x, y), make_pair(0,0)));</p>
<p>visit[x][y][0] = true;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front().first.first; y = que.front().first.second;</p>
<p>int key = que.front().second.first; int sum = que.front().second.second;</p>
<p>que.pop();</p>
<p>if (table[x][y] == '1') return sum;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>int new_key = key;</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) {</p>
<p>if (table[nx][ny] == '#') continue;</p>
<p>if ('a' &lt;= table[nx][ny] &amp;&amp; table[nx][ny] &lt;= 'f') new_key=(new_key | 1 &lt;&lt; table[nx][ny] - 'a');</p>
<p>if ('A' &lt;= table[nx][ny] &amp;&amp; table[nx][ny] &lt;= 'F') {</p>
<p>if (!(key &amp; (1 &lt;&lt; (table[nx][ny] - 'A')))) continue;</p>
<p>}</p>
<p>if (visit[nx][ny][new_key]) continue;</p>
<p>que.push(make_pair(make_pair(nx, ny), make_pair(new_key, sum + 1)));</p>
<p>visit[nx][ny][new_key] = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>string input;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>if (input[j] == '0') start_pos = make_pair(i, j);</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int answer = 0;</p>
<p>visit.assign(N, vector&lt;vector&lt;bool&gt;&gt;(M, vector&lt;bool&gt;(64, false)));</p>
<p>visit[start_pos.first][start_pos.second][0] = true;</p>
<p>answer = BFS(start_pos.first, start_pos.second);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[193. [SAMSUNG SW – Knight Tour]</strong></p>
<p>- this problem was so easy for me. I just had to check the condition is possible or not.</p>
<p>- I record possible end position using first postion and for each iteration, I checked a current position can be reached from previous position. that’s it.</p>
<p>- once input ended. I checked all the shell is visited for sure.</p>
<p>- Lastly, if end position is possible position to jump to start position, return true. Otherwise, return false.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;map&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; table(6, vector&lt;bool&gt;(6, false));</p>
<p>map&lt;pair&lt;int, int&gt;, bool&gt; end_pos;</p>
<p>int dir[8][2] = { {-2,-1},{-1,-2},{-2,1},{-1,2},{2,-1},{1,-2},{2,1},{1,2} };</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//make end_pos</p>
<p>string input;</p>
<p>cin &gt;&gt; input;</p>
<p>int col = input[0] - 'A'; int row = 6 - (input[1] - '0');</p>
<p>table[row][col] = true;</p>
<p>for (int i = 0; i &lt; 8; i++) {</p>
<p>int nx = row + dir[i][0]; int ny = col + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; 6 &amp;&amp; ny &lt; 6) {</p>
<p>end_pos[make_pair(nx, ny)] = true;</p>
<p>}</p>
<p>}</p>
<p>//get input and algorithm part</p>
<p>int prev_row = row; int prev_col = col;</p>
<p>for (int i = 0; i &lt; 35; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>int col = input[0] - 'A'; int row = 6 - (input[1] - '0');</p>
<p>bool flag = false;</p>
<p>//to check whether the Knight can jump to current position from pre-position.</p>
<p>for (int j = 0; j &lt; 8; j++) {</p>
<p>int nx = prev_row + dir[j][0]; int ny = prev_col + dir[j][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; 6 &amp;&amp; ny &lt; 6 &amp;&amp; nx == row &amp;&amp; ny == col) {</p>
<p>flag = true;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if (!flag || table[row][col]) { //if the Knight can not be current position or already visit current position, it's not valid.</p>
<p>cout &lt;&lt; &quot;Invalid&quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>else {</p>
<p>table[row][col] = true;</p>
<p>}</p>
<p>prev_row = row; prev_col = col;</p>
<p>}</p>
<p>// to check all the shell is visited.</p>
<p>for (int i = 0; i &lt; 6; i++) {</p>
<p>for (int j = 0; j &lt; 6; j++) {</p>
<p>if (table[i][j] == false) {</p>
<p>cout &lt;&lt; &quot;Invalid&quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//to check whether the Knight can jump to start postion from last position</p>
<p>col = input[0] - 'A'; row = 6 - (input[1] - '0');</p>
<p>if (end_pos.find(make_pair(row, col)) != end_pos.end()) {</p>
<p>cout &lt;&lt; &quot;Valid&quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>else cout &lt;&lt; &quot;Invalid&quot;;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[194. [SAMSUNG SW – Making Maze]</strong></p>
<p>- this was a simulation problem with a different start position.</p>
<p>- if player move over the limit of array, he can’t make a maze.</p>
<p>- during finishing all the given move, if player have been in the array. it’s a valid maze.</p>
<p>- so I make 50 x 50 array, and give a different start position for each iteration.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define max(a,b) a&gt;b ? a:b</p>
<p>#define min(a,b) a&gt;b ? b:a</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>int dir[4][2] = { {1,0}, {0,-1},{-1,0},{0,1} }; // s w n e</p>
<p>string input;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N&gt;&gt;input;</p>
<p>bool flag = false;</p>
<p>int ml, mr, mt, mb;</p>
<p>for (int i = 0; i &lt; 50; i++) {</p>
<p>if (flag) break;</p>
<p>for (int j = 0; j &lt; 50; j++) {</p>
<p>if (flag) break;</p>
<p>flag = true;</p>
<p>table.assign(50, vector&lt;char&gt;(50, '#'));</p>
<p>// allocate start position</p>
<p>table[i][j] = '.';</p>
<p>int cur_x = i; int cur_y = j;</p>
<p>int cur_dir = 0;</p>
<p>ml = j; mr = 0; mt = i; mb = 0;</p>
<p>//take move</p>
<p>for (int k = 0; k &lt; N; k++) {</p>
<p>char cur_move = input[k];</p>
<p>switch (cur_move){</p>
<p>case 'L':</p>
<p>cur_dir--;</p>
<p>if (cur_dir &lt; 0) cur_dir = 3;</p>
<p>break;</p>
<p>case 'R':</p>
<p>cur_dir = (cur_dir+1) % 4;</p>
<p>break;</p>
<p>case 'F':</p>
<p>cur_x = cur_x + dir[cur_dir][0]; cur_y = cur_y + dir[cur_dir][1];</p>
<p>if (cur_x &lt; 0 || cur_y &lt; 0 || cur_x &gt;= 50 || cur_y &gt;= 50) {</p>
<p>flag = false;</p>
<p>break;</p>
<p>}</p>
<p>table[cur_x][cur_y] = '.';</p>
<p>break;</p>
<p>}</p>
<p>ml = min(ml, cur_y); mr = max(mr, cur_y);</p>
<p>mt = min(mt, cur_x); mb = max(mb, cur_x);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (int i = mt; i &lt;= mb; i++) {</p>
<p>for (int j = ml; j &lt;= mr; j++) {</p>
<p>cout &lt;&lt; table[i][j];</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[195. [SAMSUNG SW – Downhill]</strong></p>
<p>- it was an easy simulation problem. just using memozation is the key to satisfy time limit.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; visit;</p>
<p>int dir[4][2] = { {-1,0 },{0,-1},{1,0},{0,1} }; // w a s d</p>
<p>int DFS(int x, int y){</p>
<p>//return part</p>
<p>if (visit[x][y] != -1) return visit[x][y];</p>
<p>if (x == N - 1 &amp;&amp; y == M - 1) return 1;</p>
<p>//DFS part</p>
<p>int res = 0;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[x][y]&gt;table[nx][ny]) {</p>
<p>res += DFS(nx, ny);</p>
<p>}</p>
<p>}</p>
<p>visit[x][y] = res;</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>visit.assign(N, vector&lt;int&gt;(M, -1));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>unsigned int answer = 0;</p>
<p>answer=DFS(0, 0);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[196. [SAMSUNG SW – A Monkey Wants To Be A Horse]</strong></p>
<p><strong>-</strong> I tried to solve this problem using DFS and DP, but I failed. since there was K value that is the number of the monkey can move like the horse.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;visit;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; shell_visit;</p>
<p>int K, N, M;</p>
<p>int k_dir[8][2] = { {-1,-2},{-2,-1}, {-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2} }; //left top start and clock-wise move.</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };//w a s d</p>
<p>int DFS(int x,int y,int cnt) {</p>
<p>if (visit[x][y][K] != -1) return visit[x][y][K];</p>
<p>if (x == N - 1 &amp;&amp; y == M - 1) return 0;</p>
<p>if (x == 0 &amp;&amp; y == 1) {</p>
<p>cout &lt;&lt; &quot;K : &quot;&lt;&lt; K &lt;&lt; endl;</p>
<p>}</p>
<p>int nx, ny;</p>
<p>int res = 987654321;</p>
<p>//Knight Move</p>
<p>if (K &gt; 0) {</p>
<p>for (int i = 0; i &lt; 8; i++) {</p>
<p>nx = x + k_dir[i][0]; ny = y + k_dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != 1 &amp;&amp; shell_visit[nx][ny]==false) {</p>
<p>shell_visit[nx][ny] = true;</p>
<p>K -= 1;</p>
<p>res= min(res,DFS(nx, ny,cnt+1)+1);</p>
<p>K += 1;</p>
<p>shell_visit[nx][ny] = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//Normal Move</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>nx = x + dir[i][0]; ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != 1 &amp;&amp; shell_visit[nx][ny] == false) {</p>
<p>shell_visit[nx][ny] = true;</p>
<p>res = min(res, DFS(nx, ny, cnt + 1)+1);</p>
<p>shell_visit[nx][ny] = false;</p>
<p>}</p>
<p>}</p>
<p>if (K &gt; 0) visit[x][y][1] = res;</p>
<p>else visit[x][y][0] = res;</p>
<p>return res;</p>
<p>}</p>
<p>int main(){</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; K &gt;&gt; M &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>shell_visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>visit.assign(N, vector&lt;vector&lt;int&gt;&gt;(M,vector&lt;int&gt;(K+1,-1)));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>shell_visit[0][0] = true;</p>
<p>int answer = 987654321;</p>
<p>answer=DFS(0,0,0);</p>
<p>if (answer == 987654321) cout &lt;&lt; -1;</p>
<p>else cout &lt;&lt; answer;</p>
<p>/*for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cout &lt;&lt; endl &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; &quot; j :&quot; &lt;&lt; j &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; visit[i][j][0] &lt;&lt; &quot; , &quot; &lt;&lt; visit[i][j][1] &lt;&lt; endl;</p>
<p>}</p>
<p>}*/</p>
<p>return 0;</p>
<p>}</p>
<p>- so I changed it to BFS.</p>
<p>- BFS also has Memozation. I mean Dp. the reason why we can’t use DP in DFS but BFS is that when we use DP in DFS, a shell can be reached along different ways. so even if the shell’s k value is same, there is a probablity that it has a different res value.</p>
<p>- Therefore, even if we visit a shell with a certain K value. we have to re-check the shell. so the visit array is useless.</p>
<p>- However, BFS always find a shortest path from current shell. so there is no possible way to reach a certain shell with different path. so we can use DP.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt;visit;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; shell_visit;</p>
<p>int K, N, M;</p>
<p>int k_dir[8][2] = { {-1,-2},{-2,-1}, {-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2} }; //left top start and clock-wise move.</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };//w a s d</p>
<p>int BFS(int x,int y, int k) {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{x, y, 0,0});</p>
<p>visit[x][y][0] = true;</p>
<p>int res = 987654321;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front()[0]; y = que.front()[1]; k = que.front()[2]; int sum = que.front()[3];</p>
<p>que.pop();</p>
<p>if (x == N - 1 &amp;&amp; y == M - 1) {</p>
<p>return sum;</p>
<p>}</p>
<p>if (K&gt;k) {</p>
<p>for (int i = 0; i &lt; 8; i++) {</p>
<p>int nx = x + k_dir[i][0]; int ny = y + k_dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != 1 &amp;&amp; visit[nx][ny][k+1] == false) {</p>
<p>visit[nx][ny][k + 1] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny, k + 1, sum + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != 1 &amp;&amp; visit[nx][ny][k] == false) {</p>
<p>visit[nx][ny][k] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny, k, sum + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (res == 987654321) return -1;</p>
<p>return res;</p>
<p>}</p>
<p>int main(){</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; K &gt;&gt; M &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>visit.assign(N, vector&lt;vector&lt;bool&gt;&gt;(M, vector&lt;bool&gt;(K + 1, false)));</p>
<p>shell_visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>shell_visit[0][0] = true;</p>
<p>int answer = 987654321;</p>
<p>answer=BFS(0,0,K);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[197. [SAMSUNG SW – Robot]</strong></p>
<p>- It was a simulation problem with some restriction.</p>
<p>- we have to maintain 3D boolean visit array to check whether we visit the shell with a certain direction.</p>
<p>- by maintaining visit array, we don’t need to turn the robot 180 degree at one time. it’s the key point.</p>
<p>- In this kind of simulation problem, memozation is always the hardest point to implement and to come up with.</p>
<p>- I used BFS using queue.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;cmath&gt;</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visit;</p>
<p>vector&lt;int&gt; start_pos(3);</p>
<p>vector&lt;int&gt; end_pos(3);</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };//wasd</p>
<p>vector&lt;int&gt; rotation = { -1,1 }; //left right back</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; afterPos(int x, int y, int d) {</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; res;</p>
<p>for (int i = 1; i &lt;= 3; i++) {</p>
<p>int nx = x + (dir[d][0] * i); int ny = y + (dir[d][1] * i);</p>
<p>if (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M || table[nx][ny] != 0 ) return res;</p>
<p>res.emplace_back(make_pair(nx, ny));</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>inline int dirChange(int d) {</p>
<p>if (d == 1) return 3;</p>
<p>else if (d == 2) return 1;</p>
<p>else if (d == 3) return 2;</p>
<p>else if (d == 4) return 0;</p>
<p>}</p>
<p>int BFS() {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{start_pos[0]-1, start_pos[1]-1, start_pos[2], 0});</p>
<p>visit[start_pos[0] - 1][start_pos[1] - 1][start_pos[2]] = true;</p>
<p>int answer = 987654321;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; int d = que.front()[2]; int sum = que.front()[3];</p>
<p>//cout &lt;&lt; &quot; x : &quot; &lt;&lt; x &lt;&lt; &quot; y : &quot; &lt;&lt; y &lt;&lt; &quot; dir : &quot; &lt;&lt; d &lt;&lt; &quot; sum : &quot; &lt;&lt; sum &lt;&lt; endl;</p>
<p>que.pop();</p>
<p>if (x == end_pos[0] - 1 &amp;&amp; y == end_pos[1] - 1 &amp;&amp; d == end_pos[2]) {</p>
<p>answer = min(answer, sum);</p>
<p>continue;</p>
<p>}</p>
<p>for (int r : rotation) {</p>
<p>int nd = d + r;</p>
<p>if (nd &lt; 0) nd = 3;</p>
<p>else if (nd == 4) nd = 0;</p>
<p>if (visit[x][y][nd] == false) {</p>
<p>visit[x][y][nd] = true;</p>
<p>que.push(vector&lt;int&gt;{x, y, nd, sum + abs(r)});</p>
<p>}</p>
<p>}</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; temp = afterPos(x, y, d);</p>
<p>for (pair&lt;int, int&gt; res : temp) {</p>
<p>if (visit[res.first][res.second][d] == false) {</p>
<p>visit[res.first][res.second][d] = true;</p>
<p>que.push(vector&lt;int&gt;{res.first, res.second, d, sum + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return answer;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>visit.assign(N, vector&lt;vector&lt;bool&gt;&gt;(M,vector&lt;bool&gt;(4,false)));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>cin &gt;&gt; start_pos[0] &gt;&gt; start_pos[1] &gt;&gt; start_pos[2];</p>
<p>cin &gt;&gt; end_pos[0] &gt;&gt; end_pos[1] &gt;&gt; end_pos[2];</p>
<p>//algorithm part</p>
<p>start_pos[2] = dirChange(start_pos[2]);</p>
<p>end_pos[2] = dirChange(end_pos[2]);</p>
<p>int answer=BFS();</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[198. [SAMSUNG SW – Jump]</strong></p>
<p>- Recently, I’ve been solving lots of simulation problem. so this problem was easy for me.</p>
<p>- I used DFS since I had to find all the path to end position and for that DFS using memozation is the easiest way, I think.</p>
<p>- a precaution is the answer can be 2^63 – 1. so I used unsigned long long data type.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int dir[2][2] = { {1,0},{0,1} };</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;unsigned long long&gt;&gt; memo;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>int N;</p>
<p>unsigned long long DFS(int x, int y) {</p>
<p>if (x == N - 1 &amp;&amp; y == N - 1) return 1;</p>
<p>if (memo[x][y] != -1) return memo[x][y];</p>
<p>if (table[x][y] == 0) return 0;</p>
<p>unsigned long long res = 0;</p>
<p>for (int i = 0; i &lt; 2; i++) {</p>
<p>int nx = x + (dir[i][0]*table[x][y]); int ny = y + (dir[i][1]*table[x][y]);</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; N&amp;&amp;visit[nx][ny]==false) {</p>
<p>visit[nx][ny] = true;</p>
<p>res+=DFS(nx, ny);</p>
<p>visit[nx][ny] = false;</p>
<p>}</p>
<p>}</p>
<p>memo[x][y] = res;</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>visit.assign(N, vector&lt;bool&gt;(N, false));</p>
<p>memo.assign(N, vector&lt;unsigned long long&gt;(N, -1));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part;</p>
<p>visit[0][0] = true;</p>
<p>unsigned long long answer = DFS(0,0);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[199. [SAMSUNG SW – Moving Log]</strong></p>
<p><strong>-</strong> this was a simulation problem to find the shortest path to move a log.</p>
<p>- the log’s size is 3, I mean horizontally. so there was a few restriction. but those was okay.</p>
<p>- I used BFS and visit array. but problem occurred when I got input.</p>
<p>- I misread input format. After changing the way to get input. it worked properly.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>int N;</p>
<p>vector&lt;int&gt; start_pos(6, 0); //log's start position</p>
<p>vector&lt;int&gt; end_pos(6, 0); //log's end position</p>
<p>vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visit;</p>
<p>bool horizon;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int BFS() {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;//log's position , move count, horizon</p>
<p>que.push(vector&lt;int&gt;{start_pos[0], start_pos[1], start_pos[2], start_pos[3], start_pos[4], start_pos[5], 0,horizon});</p>
<p>visit[start_pos[2]][start_pos[3]][horizon] = true;</p>
<p>while (!que.empty()) {</p>
<p>int sx = que.front()[0]; int sy = que.front()[1]; int mx = que.front()[2]; int my = que.front()[3]; int ex = que.front()[4]; int ey = que.front()[5];</p>
<p>int cnt = que.front()[6]; horizon = que.front()[7];</p>
<p>//cout &lt;&lt; sx &lt;&lt; &quot;,&quot; &lt;&lt; sy &lt;&lt; &quot;,&quot; &lt;&lt; mx &lt;&lt; &quot;,&quot; &lt;&lt; my &lt;&lt; &quot;,&quot; &lt;&lt; ex &lt;&lt; &quot;,&quot; &lt;&lt; ey &lt;&lt; &quot;==&quot;&lt;&lt;cnt&lt;&lt;endl;</p>
<p>if (sx == end_pos[0] &amp;&amp; sy == end_pos[1] &amp;&amp; mx == end_pos[2] &amp;&amp; my == end_pos[3] &amp;&amp; ex == end_pos[4] &amp;&amp; ey == end_pos[5]) return cnt;</p>
<p>que.pop();</p>
<p>//move</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nsx = sx + dir[i][0]; int nsy = sy + dir[i][1]; int nmx = mx + dir[i][0]; int nmy = my + dir[i][1]; int nex = ex + dir[i][0]; int ney = ey + dir[i][1];</p>
<p>if (nsx &gt;= 0 &amp;&amp; nsy &gt;= 0 &amp;&amp; nex &lt; N &amp;&amp; ney &lt; N &amp;&amp; table[nsx][nsy] != '1' &amp;&amp; table[nmx][nmy] != '1' &amp;&amp; table[nex][ney] != '1' &amp;&amp; visit[nmx][nmy][horizon] == false) {</p>
<p>visit[nmx][nmy][horizon] = true;</p>
<p>que.push(vector&lt;int&gt;{nsx, nsy, nmx, nmy, nex, ney, cnt + 1, horizon});</p>
<p>}</p>
<p>}</p>
<p>//rotate</p>
<p>if (horizon) {</p>
<p>int nsx = mx - 1; int nex = mx + 1; int nsy = my; int ney = my;</p>
<p>if (nsx &gt;= 0 &amp;&amp; nex &lt; N &amp;&amp; table[sx - 1][sy] != '1' &amp;&amp; table[mx - 1][my] != '1' &amp;&amp; table[ex - 1][ey] != '1' &amp;&amp;</p>
<p>table[sx + 1][sy] != '1' &amp;&amp; table[mx + 1][my] != '1' &amp;&amp; table[ex + 1][ey] != '1' &amp;&amp; visit[mx][my][false] == false) {</p>
<p>visit[mx][my][false] = true;</p>
<p>que.push(vector&lt;int&gt;{nsx, nsy, mx, my, nex, ney, cnt + 1, false});</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>int nsx = mx; int nex = mx; int nsy = my - 1; int ney = my + 1;</p>
<p>if (nsy &gt;= 0 &amp;&amp; ney &lt; N &amp;&amp; table[sx][sy - 1] != '1' &amp;&amp; table[mx][my - 1] != '1' &amp;&amp; table[ex][ey - 1] != '1'</p>
<p>&amp;&amp; table[sx][sy + 1] != '1' &amp;&amp; table[mx][my + 1] != '1' &amp;&amp; table[ex][ey + 1] != '1' &amp;&amp; visit[mx][my][true] == false) {</p>
<p>visit[mx][my][true] = true;</p>
<p>que.push(vector&lt;int&gt;{nsx, nsy, mx, my, nex, ney, cnt + 1, true});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input;</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;char&gt;(N, 0));</p>
<p>visit.assign(N, vector&lt;vector&lt;bool&gt;&gt;(N, vector&lt;bool&gt;(2,false))); //horizon, vertical for log's middle position</p>
<p>bool flag_start = true;</p>
<p>bool flag_end = true;</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; N; i++ ) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>//start position</p>
<p>if (flag_start &amp;&amp; input[j] == 'B') {</p>
<p>flag_start = false;</p>
<p>if (j + 1 &lt; N &amp;&amp; input[j+1] == 'B') {</p>
<p>horizon = true;</p>
<p>start_pos[0] = start_pos[2] = start_pos[4] = i;</p>
<p>start_pos[1] = j; start_pos[3] = j + 1; start_pos[5] = j + 2;</p>
<p>}</p>
<p>else {</p>
<p>start_pos[0] = i; start_pos[2] = i + 1; start_pos[4] = i+2;</p>
<p>start_pos[1] = start_pos[3] = start_pos[5] = j;</p>
<p>horizon = false;</p>
<p>}</p>
<p>}</p>
<p>//end position</p>
<p>if (flag_end &amp;&amp; input[j] == 'E') {</p>
<p>flag_end = false;</p>
<p>if (j + 1 &lt; N &amp;&amp; input[j+1] == 'E') {</p>
<p>end_pos[0] = end_pos[2] = end_pos[4] = i;</p>
<p>end_pos[1] = j; end_pos[3] = j + 1; end_pos[5] = j + 2;</p>
<p>}</p>
<p>else {</p>
<p>end_pos[0] = i; end_pos[2] = i + 1; end_pos[4] = i + 2;</p>
<p>end_pos[1] = end_pos[3] = end_pos[5] = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int answer=BFS();</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[200. [SAMSUNG SW – Famous 7 Princesses]</strong></p>
<p>- Wow, I have to say it was quite hard and difficult.</p>
<p>- I thought it was a simulation problem, so if I had used DFS or BFS, I could’ve solved this problem.</p>
<p>- but it was a combination problem. since although I used DFS or BFS, I wasn’t able to search like crossroad.</p>
<p>- Therefore, I had to choose 7 people first using combination. After that, I had to check the member included at least 4 “S” member and if Yes, I also had to check the people were connected each other.</p>
<p>- To determine they were connected, I used DFS.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;set&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table(5, vector&lt;char&gt;(5, 0));</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>vector&lt;vector&lt;int&gt;&gt; temp_table;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; s_pos;</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; cur_com;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int res = 0;</p>
<p>int conneceted_size;</p>
<p>void DFS(int x, int y) {</p>
<p>conneceted_size++;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; 5 &amp;&amp; ny &lt; 5 &amp;&amp; temp_table[nx][ny] == 1 &amp;&amp; visit[nx][ny] == false) {</p>
<p>visit[nx][ny] = true;</p>
<p>DFS(nx, ny);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>bool isConnected() {</p>
<p>conneceted_size = 0;</p>
<p>temp_table.assign(5, vector&lt;int&gt;(5, 0));</p>
<p>visit.assign(5, vector&lt;bool&gt;(5, false));</p>
<p>for (int i = 0; i &lt; 7; i++) temp_table[cur_com[i].first][cur_com[i].second] = 1;</p>
<p>visit[cur_com[0].first][cur_com[0].second] = true;</p>
<p>DFS(cur_com[0].first, cur_com[0].second);</p>
<p>if (conneceted_size == 7) return true;</p>
<p>return false;</p>
<p>}</p>
<p>void Combination(int start_x, int start_y, int cnt, int member) {</p>
<p>if (cnt == 7 ) {</p>
<p>if (member &gt;= 4) {</p>
<p>if (isConnected()) res += 1;</p>
<p>return;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>for (int i = start_x; i &lt; 5; i++) {</p>
<p>for (int j = start_y; j &lt; 5; j++) {</p>
<p>cur_com.emplace_back(make_pair(i, j));</p>
<p>bool S_member=false;</p>
<p>if (table[i][j] == 'S') S_member = true;</p>
<p>if (j == 4) {</p>
<p>Combination(i + 1, 0, cnt + 1, member + S_member);</p>
<p>start_y = 0;</p>
<p>}</p>
<p>else Combination(i, j + 1, cnt + 1, member + S_member);</p>
<p>cur_com.pop_back();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; 5; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; 5; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>if (input[j] == 'S') {</p>
<p>s_pos.emplace_back(make_pair(i, j));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>Combination(0, 0, 0, 0);</p>
<p>cout &lt;&lt; res;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[201. [SAMSUNG SW – Chess]</strong></p>
<p>- this was an easy simulation problem.</p>
<p>- I just had to implement the way to move of queen and knight.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int N, M,q,k,p;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; queens;</p>
<p>vector&lt;pair&lt;int,int&gt;&gt; knights;</p>
<p>int k_dir[8][2] = { {-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2} };</p>
<p>int q_dir[8][2] = { {-1,0}, {-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1} };</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>int x, y;</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>cin &gt;&gt; q;</p>
<p>for (int i = 0; i &lt; q; i++) {</p>
<p>cin &gt;&gt; x &gt;&gt; y;</p>
<p>table[x-1][y-1] = 1;</p>
<p>queens.emplace_back(make_pair(x-1, y-1));</p>
<p>}</p>
<p>cin &gt;&gt; k;</p>
<p>for (int i = 0; i &lt; k; i++) {</p>
<p>cin &gt;&gt; x &gt;&gt; y;</p>
<p>table[x-1][y-1] = 1;</p>
<p>knights.emplace_back(make_pair(x-1, y-1));</p>
<p>}</p>
<p>cin &gt;&gt; p;</p>
<p>for (int i = 0; i &lt; p; i++) {</p>
<p>cin &gt;&gt; x &gt;&gt; y;</p>
<p>table[x-1][y-1] = 1;</p>
<p>}</p>
<p>//algorithm part</p>
<p>//for queen</p>
<p>for (int i = 0; i &lt; q; i++) {</p>
<p>for (int j = 0; j &lt; 8; j++) {</p>
<p>int move = 1;</p>
<p>while (true) {</p>
<p>x = queens[i].first + q_dir[j][0] * move; y = queens[i].second + q_dir[j][1] * move;</p>
<p>if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= M || table[x][y] == 1) break;</p>
<p>table[x][y] = 2;</p>
<p>move +=1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//for knight</p>
<p>for (int i = 0; i &lt; k; i++) {</p>
<p>for (int j = 0; j &lt; 8; j++) {</p>
<p>x = knights[i].first + k_dir[j][0]; y = knights[i].second + k_dir[j][1];</p>
<p>if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= M || table[x][y] == 1) continue;</p>
<p>table[x][y] = 2;</p>
<p>}</p>
<p>}</p>
<p>int answer = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == 0) answer++;</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[202. [SAMSUNG SW – Making Bridge]</strong></p>
<p>- It was a minimum spanning tree problem.</p>
<p>- when I solved this problem. I thought time limit exceeded might have occurred. but it’s not.</p>
<p>- First, I named all the district respectively.</p>
<p>- Second, for each shell that is one of a district, find minimum path to another district using BFS.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int N;</p>
<p>int d_num = 2;</p>
<p>int answer = 987654321;</p>
<p>void makeDistriction() {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>if (table[i][j] == 1) {</p>
<p>que.push(vector&lt;int&gt;{i,j});</p>
<p>table[i][j] = d_num;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1];</p>
<p>que.pop();</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; N &amp;&amp; table[nx][ny] == 1) {</p>
<p>table[nx][ny] = d_num;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>d_num += 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void makeBridge() {</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>if (table[i][j] != 0) {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{i, j,0});</p>
<p>int cur_d = table[i][j];</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(N, false));</p>
<p>visit[i][j] = true;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; int dis = que.front()[2]; que.pop();</p>
<p>if (table[x][y] != 0 &amp;&amp; table[x][y]!=cur_d) {</p>
<p>answer = min(answer, dis-1);</p>
<p>break;</p>
<p>}</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; N &amp;&amp; visit[nx][ny] == false &amp;&amp; table[nx][ny]!=cur_d) {</p>
<p>visit[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny, dis + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>makeDistriction();</p>
<p>makeBridge();</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[203. [SAMSUNG SW – Break A Wall and Move]</strong></p>
<p><strong>-</strong> It was a simulation problem to find the shortest path from start to end position.</p>
<p>- I used DFS first, but I failed since there is no insurance that a path I found is minimum path when we use DFS.</p>
<p>- so I changed it to BFS and solved it.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define min(a,b) a&gt;b?b:a</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visit;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>bool flag = false;</p>
<p>int BFS() {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{0, 0, 1,1});</p>
<p>visit[0][0][1] = true;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; int punch = que.front()[2]; int sum = que.front()[3];</p>
<p>if (x == N - 1 &amp;&amp; y == M - 1) return sum;</p>
<p>que.pop();</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) {</p>
<p>if (table[nx][ny] == 1) {</p>
<p>if (punch &amp;&amp; visit[nx][ny][0]==false) {</p>
<p>visit[nx][ny][0] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny, 0,sum+1});</p>
<p>}</p>
<p>else continue;</p>
<p>}</p>
<p>else if(visit[nx][ny][punch] == false) {</p>
<p>visit[nx][ny][punch] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny, punch,sum+1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return -1;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>visit.assign(N, vector&lt;vector&lt;bool&gt;&gt;(M, vector&lt;bool&gt;(2, false)));</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j] - '0';</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int answer=BFS();</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[204. [SAMSUNG SW – Number Board Jump]</strong></p>
<p>- it was just a DFS problem. there was no restriction so easy.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#include&lt;string&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(5,vector&lt;int&gt;(5,0));</p>
<p>set&lt;string&gt; number_set;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>void DFS(int x, int y, string cur_set,int cnt) {</p>
<p>if (cnt == 6) {</p>
<p>number_set.insert(cur_set);</p>
<p>return;</p>
<p>}</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; 5 &amp;&amp; ny &lt; 5) {</p>
<p>cur_set += table[nx][ny] + '0';</p>
<p>DFS(nx, ny, cur_set,cnt+1);</p>
<p>cur_set.pop_back();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>for (int i = 0; i &lt; 5; i++) {</p>
<p>for (int j = 0; j &lt; 5; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>for (int i = 0; i &lt; 5; i++) {</p>
<p>for (int j = 0; j &lt; 5; j++) {</p>
<p>string cur_set = to_string(table[i][j]) + '0';</p>
<p>DFS(i, j, cur_set, 1);</p>
<p>cur_set.pop_back();</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; number_set.size();</p>
<p>return 0;</p>
<p>}</p>
<p><strong>[205. [SAMSUNG SW – Castle Wall]</strong></p>
<p>- this was so hard. they gave walls of the castle using numeric value, actually binary value!</p>
<p>- so reaching the given condition was so hard.</p>
<p>- I used BFS, and bit operation.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int N, M;</p>
<p>int dir[4][2] = { {0,-1} ,{-1,0},{0,1},{1,0} };</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>int BFS(int x, int y) {</p>
<p>visit[x][y] = true;</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{x, y});</p>
<p>int room_size = 1;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front()[0]; y = que.front()[1];</p>
<p>que.pop();</p>
<p>int wall = 1;</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>int nx = x + dir[i][0]; int ny = y + dir[i][1];</p>
<p>if ((table[x][y] &amp; wall)!=wall) {</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; visit[nx][ny] == false) {</p>
<p>visit[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>room_size += 1;</p>
<p>}</p>
<p>}</p>
<p>wall*=2;</p>
<p>}</p>
<p>}</p>
<p>return room_size;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; M &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int num_of_rooms = 0;</p>
<p>int max_size = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (visit[i][j] == false) {</p>
<p>int temp = BFS(i,j);</p>
<p>max_size = max(max_size, temp);</p>
<p>num_of_rooms += 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int max_size2 = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>for (int k = 1; k &lt;= 8; k *= 2) {</p>
<p>if ((table[i][j]&amp;k)==k) {</p>
<p>visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>table[i][j] -= k;</p>
<p>int temp = BFS(i, j);</p>
<p>max_size2 = max(max_size2, temp);</p>
<p>table[i][j] += k;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; num_of_rooms &lt;&lt; endl;</p>
<p>cout &lt;&lt; max_size &lt;&lt; endl;</p>
<p>cout &lt;&lt; max_size2 &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>[206. SAMSUNG SW : Water Bottle]</p>
<p>- it was a simulation problem with BFS.</p>
<p>- But at first, I had no idea how to solve this problem.</p>
<p>- the key was just to implement pouring water from one to another.</p>
<p>- I used BFS to record current bottles’ water volume and visit 3d array to check whether current bottles’ volume is already checked or not.</p>
<p>- I spent 26 minutes and 14 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; bottle(3, 0);</p>
<p>vector&lt;int&gt; water(3, 0);</p>
<p>bool visit[200][200][200];</p>
<p>set&lt;int&gt; answer;</p>
<p>inline bool isValid(int a,int b,int c) {</p>
<p>if (visit[a][b][c]) return false;</p>
<p>return true;</p>
<p>}</p>
<p>inline bool isFull(int i,int c,int n) {</p>
<p>if ((bottle[i] - c) - n &lt; 0) return true;</p>
<p>return false;</p>
<p>}</p>
<p>void BFS() {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{0, 0, water[2]});</p>
<p>visit[0][0][water[2]] = true;</p>
<p>answer.insert(water[2]);</p>
<p>while (!que.empty()) {</p>
<p>int a = que.front()[0]; int b = que.front()[1]; int c = que.front()[2];</p>
<p>que.pop();</p>
<p>int na, nb, nc;</p>
<p>if (a == 0) answer.insert(c);</p>
<p>if (a != 0) {</p>
<p>if (isFull(1,b,a)) {</p>
<p>na = a - (bottle[1] - b);</p>
<p>nb = bottle[1];</p>
<p>}</p>
<p>else {</p>
<p>na = 0;</p>
<p>nb = a + b;</p>
<p>}</p>
<p>if (visit[na][nb][c] == false) {</p>
<p>visit[na][nb][c] = true;</p>
<p>que.push(vector&lt;int&gt;{na, nb, c});</p>
<p>}</p>
<p>if (isFull(2, c, a)) {</p>
<p>na = a - (bottle[2] - c);</p>
<p>nc = bottle[2];</p>
<p>}</p>
<p>else{</p>
<p>na = 0;</p>
<p>nc = a + c;</p>
<p>}</p>
<p>if (visit[na][b][nc] == false) {</p>
<p>visit[na][b][nc] = true;</p>
<p>que.push(vector&lt;int&gt;{na, b, nc});</p>
<p>}</p>
<p>}</p>
<p>if (b != 0) {</p>
<p>if (isFull(0, a, b)) {</p>
<p>nb = b - (bottle[0] - a);</p>
<p>na = bottle[0];</p>
<p>}</p>
<p>else {</p>
<p>nb = 0;</p>
<p>na = a + b;</p>
<p>}</p>
<p>if (visit[na][nb][c] == false) {</p>
<p>visit[na][nb][c] = true;</p>
<p>que.push(vector&lt;int&gt;{na, nb, c});</p>
<p>}</p>
<p>if (isFull(2, c, b)) {</p>
<p>nb = b - (bottle[2] - c);</p>
<p>nc = bottle[2];</p>
<p>}</p>
<p>else {</p>
<p>nb = 0;</p>
<p>nc = b + c;</p>
<p>}</p>
<p>if (visit[a][nb][nc] == false) {</p>
<p>visit[a][nb][nc] = true;</p>
<p>que.push(vector&lt;int&gt;{a, nb, nc});</p>
<p>}</p>
<p>}</p>
<p>if (c != 0) {</p>
<p>if (isFull(0, a, c)) {</p>
<p>nc = c - (bottle[0] - a);</p>
<p>na = bottle[0];</p>
<p>}</p>
<p>else {</p>
<p>nc = 0;</p>
<p>na = a + c;</p>
<p>}</p>
<p>if (visit[na][b][nc] == false) {</p>
<p>visit[na][b][nc] = true;</p>
<p>que.push(vector&lt;int&gt;{na, b, nc});</p>
<p>}</p>
<p>if (isFull(1, b, c)) {</p>
<p>nc = c - (bottle[1] - b);</p>
<p>nb = bottle[1];</p>
<p>}</p>
<p>else {</p>
<p>nc = 0;</p>
<p>nb = b + c;</p>
<p>}</p>
<p>if (visit[a][nb][nc] == false) {</p>
<p>visit[a][nb][nc] = true;</p>
<p>que.push(vector&lt;int&gt;{a, nb, nc});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input;</p>
<p>cin &gt;&gt; bottle[0] &gt;&gt; bottle[1] &gt;&gt; bottle[2];</p>
<p>water[2] = bottle[2];</p>
<p>//algorithm part</p>
<p>BFS();</p>
<p>for (set&lt;int&gt;::iterator iter = answer.begin(); iter != answer.end(); iter++)</p>
<p>cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>[207. SAMSUNG SW : Seven Dwarfs]</p>
<p>- it was a combination problem. I used DFS to implenmt combination.</p>
<p>- this problem was so easy, I just had to check whether sum of chosen dwarfs height is 100 or not after choosing 7 dwarfs.</p>
<p>- I spent 5 minutes.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;int&gt; table(9, 0);</p>
<p>vector&lt;bool&gt; visit(9, false);</p>
<p>vector&lt;int&gt; chosen;</p>
<p>bool flag = false;</p>
<p>void Combination(int cnt, int start) {</p>
<p>if (cnt == 7) {</p>
<p>int sum = 0;</p>
<p>for (int i : chosen) sum += i;</p>
<p>if (sum == 100) flag = true;</p>
<p>return;</p>
<p>}</p>
<p>for (int i = start; i &lt; 9; i++) {</p>
<p>if (visit[i]) continue;</p>
<p>visit[i] = true;</p>
<p>chosen.emplace_back(table[i]);</p>
<p>Combination(cnt + 1, i + 1);</p>
<p>if (flag) return;</p>
<p>chosen.pop_back();</p>
<p>visit[i] = false;</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>for (int i = 0; i &lt; 9; i++) cin &gt;&gt; table[i];</p>
<p>//algorithm part</p>
<p>Combination(0, 0);</p>
<p>sort(chosen.begin(), chosen.end());</p>
<p>for (int i : chosen) cout &lt;&lt; i &lt;&lt;endl;</p>
<p>return 0;</p>
<p>}</p>
<p>[208. SAMSUNG SW : Safety Area]</p>
<p>- It was a simulation problem.</p>
<p>- I used BFS to determine how many safety areas are for each precipitation.</p>
<p>- I spent 11 minutes and 29 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int max_height=0;</p>
<p>int N;</p>
<p>int answer = 1;</p>
<p>void BFS(int height) {</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(N, false));</p>
<p>int res = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>if (table[i][j] &gt; height &amp;&amp; visit[i][j]==false) {</p>
<p>res += 1;</p>
<p>visit[i][j] = true;</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{i, j});</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; que.pop();</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny&lt;N &amp;&amp; visit[nx][ny] == false &amp;&amp; table[nx][ny]&gt;height) {</p>
<p>visit[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>answer = max(answer, res);</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>max_height = max(max_height, table[i][j]);</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>for (int i = 1; i &lt; max_height; i++) BFS(i);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[209. SAMSUNG SW : Bus Transfer]</p>
<p>- It was a simulation problem. it was so hard for me.</p>
<p>- I used DFS to find path to destination. but memory limit exceeded.</p>
<p>- see the first code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;map&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>vector&lt;bool&gt; visit;</p>
<p>vector&lt;vector&lt;int&gt;&gt; shell_visit;</p>
<p>int sx, sy, dx, dy;</p>
<p>int N, M, K;</p>
<p>map&lt;pair&lt;int, int&gt;, set&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;short&gt;&gt; bus; //number, x1, y1, x2, y2 ,dir , if dir==1 , then vertical</p>
<p>int answer;</p>
<p>inline int Y(int y) {</p>
<p>return N - y;</p>
<p>}</p>
<p>int DFS(int x, int y) {</p>
<p>if (x == dx &amp;&amp; y == dy) {</p>
<p>return 0;</p>
<p>}</p>
<p>if (shell_visit[y][x] != -1) return shell_visit[y][x];</p>
<p>int res = 987654321;</p>
<p>for (int b : table[make_pair(y,x)]) {</p>
<p>if (visit[b]) continue;</p>
<p>visit[b] = true;</p>
<p>//cout &lt;&lt; x &lt;&lt; &quot; , &quot; &lt;&lt; y &lt;&lt;&quot; : &quot;&lt;&lt;b&lt;&lt; endl;</p>
<p>int x1 = bus[b][1]; int y1 = bus[b][2]; int x2 = bus[b][3]; int y2 = bus[b][4]; int d = bus[b][5];</p>
<p>if (d) { //vertical</p>
<p>if (y1 &gt; y2) {</p>
<p>for (int j = y2; j &lt;= y1; j++) {</p>
<p>if(!table[make_pair(j,x1)].empty()) res = min(res, DFS(x1, j) + 1);</p>
<p>}</p>
<p>}</p>
<p>else {</p>
<p>for (int j = y1; j &lt;= y2; j++) {</p>
<p>if (!table[make_pair(j, x1)].empty()) res = min(res, DFS(x1, j) + 1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>else { //horizon</p>
<p>if (x1 &gt; x2) {</p>
<p>for (int j = x2; j &lt;= x1; j++) {</p>
<p>if (!table[make_pair(y1, j)].empty()) res=min(res,DFS(j, y1)+1);</p>
<p>}</p>
<p>}</p>
<p>else{</p>
<p>for (int j = x1; j &lt;= x2; j++) {</p>
<p>if (!table[make_pair(y1, j)].empty()) res = min(res, DFS(j, y1) + 1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>visit[b] = false;</p>
<p>}</p>
<p>shell_visit[y][x] = res;</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cout.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;</p>
<p>shell_visit.assign(N, vector&lt;int&gt;(M, -1));</p>
<p>bus.assign(K, vector&lt;short&gt;(6,0));</p>
<p>visit.assign(K, false);</p>
<p>int b;</p>
<p>int x1, x2, y1, y2;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>cin &gt;&gt; b;</p>
<p>for (int j = 1; j &lt; 5; j++) {</p>
<p>cin &gt;&gt; bus[b-1][j];</p>
<p>//bus[b-1][j] -= 1;</p>
<p>}</p>
<p>bus[b - 1][1] -= 1; bus[b - 1][3] -= 1;</p>
<p>bus[b - 1][2] = Y(bus[b - 1][2]);</p>
<p>bus[b - 1][4] = Y(bus[b - 1][4]);</p>
<p>int temp;</p>
<p>x1 = bus[b - 1][1]; y1 = bus[b - 1][2]; x2 = bus[b - 1][3]; y2 = bus[b - 1][4];</p>
<p>if (x1==x2) { // vertical</p>
<p>bus[b - 1][5] = 1;</p>
<p>if (y1 &gt; y2) {</p>
<p>for (int j = y2; j &lt;= y1; j++) table[make_pair(j,x1)].insert(b-1);</p>
<p>}</p>
<p>else {</p>
<p>for (int j = y1; j &lt;= y2; j++) table[make_pair(j, x1)].insert(b - 1);</p>
<p>}</p>
<p>}</p>
<p>else { //horizon</p>
<p>bus[b - 1][5] = 0;</p>
<p>if (x1 &gt; x2) {</p>
<p>for (int j = x2; j &lt;= x1; j++) table[make_pair(y1, j)].insert(b - 1);</p>
<p>}</p>
<p>else {</p>
<p>for (int j = x1; j &lt;= x2; j++) table[make_pair(y1, j)].insert(b - 1);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; dx &gt;&gt; dy;</p>
<p>sx--; dx--;</p>
<p>sy = Y(sy); dy = Y(dy);</p>
<p>/*cout &lt;&lt; endl;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>for (int j = 0; j &lt; bus[i].size();j++) cout &lt;&lt; bus[i][j] &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;*/</p>
<p>//algorithm part</p>
<p>answer=DFS(sx,sy);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>- so I searched and find a way.</p>
<p>- the indice ranges are so wide. so I wasn’t able to use 2D array.</p>
<p>- Using BFS, finding a bus I can transfer. the below code is from google.</p>
<p>- I Spent 1 hour and 41 minutes and 38 seconds.</p>
<p>- see the code.</p>
<p>#include &lt;iostream&gt;</p>
<p>#include &lt;queue&gt;</p>
<p>using namespace std;</p>
<p>struct info {</p>
<p>int x1;</p>
<p>int y1;</p>
<p>int x2;</p>
<p>int y2;</p>
<p>bool is_in(const int&amp; x, const int&amp; y)const {</p>
<p>return (x &gt;= x1 &amp;&amp; x &lt;= x2 &amp;&amp; y &gt;= y1 &amp;&amp; y &lt;= y2);</p>
<p>}</p>
<p>bool is_in(const info&amp; a)const {</p>
<p>return (a.x1 &lt;= x2 &amp;&amp; a.x2 &gt;= x1 &amp;&amp; a.y1 &lt;= y2 &amp;&amp; a.y2 &gt;= y1);</p>
<p>}</p>
<p>};</p>
<p>void swap(int&amp; a, int&amp; b) {</p>
<p>int tmp = a;</p>
<p>a = b;</p>
<p>b = tmp;</p>
<p>}</p>
<p>int visited[5001];</p>
<p>info bus[5001];</p>
<p>int M, N, K;</p>
<p>int sx, sy, dx, dy;</p>
<p>queue&lt;int&gt; q;</p>
<p>int bfs() {</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>if (bus[i].is_in(sx, sy)) {</p>
<p>q.push(i);</p>
<p>visited[i] = 1;</p>
<p>}</p>
<p>}</p>
<p>while (!q.empty()) {</p>
<p>int idx = q.front();</p>
<p>if (bus[idx].is_in(dx, dy)) {</p>
<p>return visited[idx];</p>
<p>}</p>
<p>q.pop();</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>if (visited[i]) continue;</p>
<p>if (bus[idx].is_in(bus[i])) {</p>
<p>visited[i] = visited[idx] + 1;</p>
<p>q.push(i);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios::sync_with_stdio(false);</p>
<p>cin.tie(0);</p>
<p>cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>int num, x1, y1, x2, y2;</p>
<p>cin &gt;&gt; num &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</p>
<p>if (y1 &gt; y2) swap(y1, y2);</p>
<p>if (x1 &gt; x2) swap(x1, x2);</p>
<p>bus[i] = { x1,y1,x2,y2 };</p>
<p>}</p>
<p>cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; dx &gt;&gt; dy;</p>
<p>cout &lt;&lt; bfs() &lt;&lt; &quot;\n&quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>[210. SAMSUNG SW : IceBerg]</p>
<p>- it was a simulation problem.</p>
<p>- To melt iceberg. I had to determine how many sea shells are adjacent to current shell.</p>
<p>- To determine how many districts are, I used BFS with visit 2D array.</p>
<p>- I spent 20 minutes or so.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;int&gt;&gt; table;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>void Melting() {</p>
<p>vector&lt;vector&lt;int&gt;&gt; stk;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] != 0) {</p>
<p>int res = 0;</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = i + dir[d][0]; int ny = j + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == 0) res++;</p>
<p>}</p>
<p>stk.emplace_back(vector&lt;int&gt;{i, j, res});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (vector&lt;int&gt; row : stk) {</p>
<p>int x = row[0]; int y = row[1]; int m = row[2];</p>
<p>table[x][y] -= m;</p>
<p>if (table[x][y] &lt; 0) table[x][y] = 0;</p>
<p>}</p>
<p>}</p>
<p>void BFS(int x, int y) {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{x, y});</p>
<p>visit[x][y] = true;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front()[0]; y = que.front()[1]; que.pop();</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != 0 &amp;&amp; visit[nx][ny]==false) {</p>
<p>visit[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>bool isEmpty() {</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] != 0) return false;</p>
<p>}</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>void PrintTable() {</p>
<p>cout &lt;&lt; endl;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;int&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int answer=0;</p>
<p>bool flag = false;</p>
<p>while (true) {</p>
<p>answer++;</p>
<p>int dis = 0;</p>
<p>visit.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>Melting();</p>
<p>if (isEmpty()) {</p>
<p>flag = true;</p>
<p>break;</p>
<p>}</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] != 0 &amp;&amp; visit[i][j] == false) {</p>
<p>dis++;</p>
<p>BFS(i, j);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (dis &gt;= 2) break;</p>
<p>}</p>
<p>if (flag) cout &lt;&lt; 0;</p>
<p>else cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[211. SAMSUNG SW : Get District]</p>
<p>- It was a BFS problem.</p>
<p>- except for converting given corrodisantes, thers was nothing special.</p>
<p>- I spent 20 minutes and 57 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>int N, M, K;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; table;</p>
<p>vector&lt;int&gt; dis;</p>
<p>int answer = 0;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>void DrawBox(int lx,int ly,int rx,int ry) {</p>
<p>for (int i = rx; i &lt;= lx; i++) {</p>
<p>for (int j = ly; j &lt;= ry; j++) {</p>
<p>table[i][j] = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void BFS(int x, int y) {</p>
<p>int res = 1;</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{x, y});</p>
<p>table[x][y] = true;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front()[0]; y = que.front()[1]; que.pop();</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == false) {</p>
<p>table[nx][ny] = true;</p>
<p>res +=1;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>dis.emplace_back(res);</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</p>
<p>table.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>int lx, ly, rx, ry;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>cin &gt;&gt; ly &gt;&gt; lx &gt;&gt; ry &gt;&gt; rx;</p>
<p>lx = N - lx-1; rx = N - rx;</p>
<p>ry -= 1;</p>
<p>DrawBox(lx, ly, rx, ry);</p>
<p>}</p>
<p>//algorithm part</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == false) {</p>
<p>answer += 1;</p>
<p>BFS(i,j);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>sort(dis.begin(), dis.end());</p>
<p>cout &lt;&lt; answer &lt;&lt; endl;</p>
<p>for (int i : dis) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>[212. SAMSUNG SW : Tresure Island]</p>
<p>- It was a BFS problem.</p>
<p>- For all the land, I had to search maximum distance from a current shell using BFS.</p>
<p>- I spent 7 minutes and 21 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>int N, M;</p>
<p>int answer = 0;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int BFS(int x, int y) {</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{x, y, 0});</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit(N, vector&lt;bool&gt;(M, false));</p>
<p>visit[x][y] = true;</p>
<p>int res = 0;</p>
<p>while (!que.empty()) {</p>
<p>x = que.front()[0]; y = que.front()[1]; int cnt = que.front()[2];</p>
<p>que.pop();</p>
<p>res = max(res, cnt);</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; visit[nx][ny] == false &amp;&amp; table[nx][ny] == 'L') {</p>
<p>visit[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny, cnt + 1});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>return res;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == 'L') {</p>
<p>answer=max(answer,BFS(i, j));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[213. SAMSUNG SW : Virus]</p>
<p>- It was a simulation problem.</p>
<p>- To record graph, I used unordered_map and unorderd_set.</p>
<p>- To travel connected nodes from current node, I used queue.</p>
<p>- I spent 8 minutes and 13 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;unordered_map&gt;</p>
<p>#include&lt;unordered_set&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>unordered_map&lt;int, unordered_set&lt;int&gt;&gt; table;</p>
<p>unordered_map&lt;int, bool&gt; visit;</p>
<p>int N, K;</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; K;</p>
<p>int a, b;</p>
<p>for (int i = 0; i &lt; K; i++) {</p>
<p>cin &gt;&gt; a &gt;&gt; b;</p>
<p>table[a].insert(b);</p>
<p>table[b].insert(a);</p>
<p>}</p>
<p>//algorihtm part</p>
<p>visit[1] = true;</p>
<p>queue&lt;int&gt; que;</p>
<p>que.push(1);</p>
<p>int answer = 0;</p>
<p>while (!que.empty()) {</p>
<p>int cur_com = que.front(); que.pop();</p>
<p>for (unordered_set&lt;int&gt;::iterator iter = table[cur_com].begin(); iter != table[cur_com].end(); iter++) {</p>
<p>if (visit[*iter] == false) {</p>
<p>visit[*iter] = true;</p>
<p>answer += 1;</p>
<p>que.push(*iter);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[214. SAMSUNG SW : Horizontal Vertical Puzzle]</p>
<p>- it was a permuation problem.</p>
<p>- At first, I didn’t understand what the problem requires. so I spent 5 minutes or so to understand it.</p>
<p>- I used DFS for permutation.</p>
<p>- To check whether the puzzle table is valid, for each word in the table, I compared it to the given words.</p>
<p>- if it exists, erase it, if not, return false and keep permutate.</p>
<p>- I spent 20 minutes and 49 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>using namespace std;</p>
<p>vector&lt;string&gt; words(6,&quot;&quot;);</p>
<p>vector&lt;string&gt; table(3, &quot;&quot;);</p>
<p>vector&lt;int&gt; chosen;</p>
<p>vector&lt;bool&gt; visit(6, false);</p>
<p>bool flag = false;</p>
<p>bool isPuzzle() {</p>
<p>vector&lt;string&gt; chosen_words;</p>
<p>for (int i = 0; i &lt; 3; i++) {</p>
<p>table[i] = words[chosen[i]];</p>
<p>chosen_words.emplace_back(table[i]);</p>
<p>}</p>
<p>for (int j = 0; j &lt; 3; j++) {</p>
<p>string temp = &quot;&quot;;</p>
<p>for (int i = 0; i &lt; 3; i++) {</p>
<p>temp += table[i][j];</p>
<p>}</p>
<p>chosen_words.emplace_back(temp);</p>
<p>}</p>
<p>vector&lt;string&gt; temp_words = words;</p>
<p>for (string cur : chosen_words) {</p>
<p>if (find(temp_words.begin(), temp_words.end(), cur) != temp_words.end()) {</p>
<p>temp_words.erase(find(temp_words.begin(), temp_words.end(), cur));</p>
<p>}</p>
<p>else return false;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>void Combination(int cnt) {</p>
<p>if (cnt == 3) {</p>
<p>if (isPuzzle()) {</p>
<p>flag = true;</p>
<p>return;</p>
<p>}</p>
<p>return;</p>
<p>}</p>
<p>for (int i = 0; i &lt; 6; i++) {</p>
<p>if (visit[i] == false) {</p>
<p>visit[i] = true;</p>
<p>chosen.emplace_back(i);</p>
<p>Combination(cnt + 1);</p>
<p>if (flag) return;</p>
<p>chosen.pop_back();</p>
<p>visit[i] = false;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>for (int i = 0; i &lt; 6; i++) cin &gt;&gt; words[i];</p>
<p>//algorithm part</p>
<p>Combination(0);</p>
<p>if (!flag) cout &lt;&lt; 0;</p>
<p>else {</p>
<p>for (string cur : table) {</p>
<p>cout &lt;&lt; cur &lt;&lt; endl;</p>
<p>}</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
<p>[215. SAMSUNG SW : Postman Han Sang Duck]</p>
<p>- At first, I thought it was just a BFS problem.</p>
<p>- But it was a DP Problem. I encounterd a quite difficult one for a long time.</p>
<p>- First, sort the given heights.</p>
<p>- Second, Find a minimum maximum height that Han Sang Duck can delivery all the post.</p>
<p>- Third, Find a maximum minimum height that Han Sang Duck can delivery all the post.</p>
<p>- If we find a valid height, calculate their difference.</p>
<p>- Go back to Second until the right pointer of sorted list reaches the list’s end.</p>
<p>- I spent 1 hours and 22 minutes and 48 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;set&gt;</p>
<p>#define max(a,b) a&gt;b? a:b</p>
<p>#define min(a,b) a&gt;b? b:a</p>
<p>using namespace std;</p>
<p>int N, house;</p>
<p>int px, py;</p>
<p>vector&lt;vector&lt;int&gt;&gt; house_pos;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>vector&lt;vector&lt;int&gt;&gt; height;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; visit;</p>
<p>int dir[8][2] = { {-1,0},{-1,-1},{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1} }; // start from north, gose by antiClock-wise</p>
<p>set&lt;int&gt; fatigue;</p>
<p>set&lt;int&gt;::iterator s_left;</p>
<p>set&lt;int&gt;::iterator s_right;</p>
<p>void DFS(int x, int y,int min_h, int max_h) {</p>
<p>if (x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= N || visit[x][y] || height[x][y]&lt;min_h || height[x][y]&gt;max_h) return;</p>
<p>visit[x][y] = true;</p>
<p>for (int d = 0; d &lt; 8; d++) DFS(x+dir[d][0], y+dir[d][1], min_h, max_h);</p>
<p>}</p>
<p>bool isValid() {</p>
<p>for (vector&lt;int&gt; row : house_pos) if (visit[row[0]][row[1]] == false) return false;</p>
<p>return true;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>table.assign(N, vector&lt;char&gt;(N, 0));</p>
<p>height.assign(N, vector&lt;int&gt;(N, 0));</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>table[i][j]=input[j];</p>
<p>if (table[i][j] == 'K') {</p>
<p>house += 1;</p>
<p>house_pos.emplace_back(vector&lt;int&gt;{i, j});</p>
<p>}</p>
<p>if (table[i][j] == 'P') {</p>
<p>px = i; py = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; N; j++) {</p>
<p>cin &gt;&gt; height[i][j];</p>
<p>fatigue.insert(height[i][j]);</p>
<p>}</p>
<p>}</p>
<p>s_left = fatigue.begin();</p>
<p>s_right = fatigue.begin();</p>
<p>//algorithm part</p>
<p>int answer = 987654321;</p>
<p>while (s_right!=fatigue.end()) {</p>
<p>while (s_left!=fatigue.end()) {</p>
<p>visit.assign(N, vector&lt;bool&gt;(N, false));</p>
<p>DFS(px, py, *s_left, *s_right);</p>
<p>if (!isValid()) break;</p>
<p>answer = min(answer, *s_right - *s_left);</p>
<p>s_left++;</p>
<p>}</p>
<p>s_right++;</p>
<p>}</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[216. SAMSUNG SW : Cheeze 1]</p>
<p>- It was a simulation problem.</p>
<p>- Before make cheeze melt, I should determine shells that are adjacent to air.</p>
<p>- To do that, I used BFS.</p>
<p>- After that, for each shell, I checked whether it is cheeze and the shell is adjacent to air.</p>
<p>- if so, I pushed its x,y corrdinates to a stk. Finally, remove the shells.</p>
<p>- During Above operation, I also counted how many cheeze shells left.</p>
<p>- I spent 14 minutes and 19 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;short&gt;&gt; table;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; air;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>int num_of_cheeze = 0;</p>
<p>void AirVisit() {</p>
<p>air.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{0, 0});</p>
<p>air[0][0] = true;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; que.pop();</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == 0 &amp;&amp; air[nx][ny]==false) {</p>
<p>air[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Melting() {</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; stk;</p>
<p>num_of_cheeze = 0;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == 1) {</p>
<p>num_of_cheeze += 1;</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = i + dir[d][0]; int ny = j + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; air[nx][ny] == true) {</p>
<p>stk.emplace_back(make_pair(i, j));</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (pair&lt;int, int&gt; row : stk) {</p>
<p>table[row.first][row.second] = 0;</p>
<p>}</p>
<p>}</p>
<p>void PrintTable() {</p>
<p>cout &lt;&lt; endl;</p>
<p>for (vector&lt;short&gt; row : table) {</p>
<p>for (short i : row) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>bool isEmpty() {</p>
<p>for (vector&lt;short&gt; row : table) {</p>
<p>for (short i : row) if (i != 0) return false;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;short&gt;(M, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int sec = 0;</p>
<p>while (true) {</p>
<p>AirVisit();</p>
<p>Melting();</p>
<p>sec += 1;</p>
<p>if (isEmpty()) break;</p>
<p>}</p>
<p>cout &lt;&lt; sec &lt;&lt; endl;</p>
<p>cout &lt;&lt; num_of_cheeze &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>[217. SAMSUNG SW : Cheeze 2]</p>
<p>- It was a simulation problem like a just previous problem.</p>
<p>- it required more conditions. Without those things, they were almost same.</p>
<p>- I spent 12 minutes and 33 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;queue&gt;</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;short&gt;&gt; table;</p>
<p>vector&lt;vector&lt;bool&gt;&gt; air;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>void AirVisit() {</p>
<p>air.assign(N, vector&lt;bool&gt;(M, false));</p>
<p>queue&lt;vector&lt;int&gt;&gt; que;</p>
<p>que.push(vector&lt;int&gt;{0, 0});</p>
<p>air[0][0] = true;</p>
<p>while (!que.empty()) {</p>
<p>int x = que.front()[0]; int y = que.front()[1]; que.pop();</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == 0 &amp;&amp; air[nx][ny] == false) {</p>
<p>air[nx][ny] = true;</p>
<p>que.push(vector&lt;int&gt;{nx, ny});</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Melting() {</p>
<p>vector&lt;pair&lt;int, int&gt;&gt; stk;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>if (table[i][j] == 1) {</p>
<p>int num_of_air = 0;</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>int nx = i + dir[d][0]; int ny = j + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] == 0 &amp;&amp; air[nx][ny] == true) num_of_air += 1;</p>
<p>}</p>
<p>if (num_of_air &gt;= 2) stk.emplace_back(make_pair(i, j));</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>for (pair&lt;int, int&gt; row : stk) {</p>
<p>table[row.first][row.second] = 0;</p>
<p>}</p>
<p>}</p>
<p>bool isEmpty() {</p>
<p>for (vector&lt;short&gt; row : table) {</p>
<p>for (short c : row) if (c != 0) return false;</p>
<p>}</p>
<p>return true;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;short&gt;(M, false));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>cin &gt;&gt; table[i][j];</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int sec = 0;</p>
<p>while (!isEmpty()) {</p>
<p>AirVisit();</p>
<p>Melting();</p>
<p>sec += 1;</p>
<p>}</p>
<p>cout &lt;&lt; sec;</p>
<p>return 0;</p>
<p>}</p>
<p>[218. SAMSUNG SW : Monomino Domino]</p>
<p>- WOW. I’ve suddenly encountered a super strong enemy for a long time.</p>
<p>- It was a simulation problem.</p>
<p>- To tell you a trap in this problem, 2 x 1 or 1 x 2 “BLOCK”</p>
<p>- they move together, but one of a 1 x 1 block in 2 x 1 or 1 x 2 block can be removed respectively.</p>
<p>- In those case, I had to revise their friend block to themselves.</p>
<p>- I used two 10 x 4 table, so I had to re-allocate blue table’s corrodinates.</p>
<p>- When I remove a row, I had to revise their friend block as I mentioned above.</p>
<p>- I spent 3 hours ans 8 minutes and 13 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#define EM 999 // empty</p>
<p>using namespace std;</p>
<p>int N;</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; blue(10,vector&lt;vector&lt;int&gt;&gt;(4, vector&lt;int&gt;(2,EM)));</p>
<p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; green(10, vector&lt;vector&lt;int&gt;&gt;(4, vector&lt;int&gt;(2,EM)));</p>
<p>vector&lt;vector&lt;int&gt;&gt; order;</p>
<p>int answer = 0;</p>
<p>int num_shell = 0;</p>
<p>void PutAndMove(int t, int x, int y) {</p>
<p>int i;</p>
<p>if (t == 1) {</p>
<p>//green</p>
<p>for (i = 2; i &lt; 11; i++) if (i &gt;= 10 || green[i][y][0]!=EM) break;</p>
<p>green[i - 1][y][0] = i - 1; green[i - 1][y][1] = y;</p>
<p>//blue</p>
<p>for (i = 2; i &lt; 11; i++) if (i &gt;= 10 || blue[i][x][0]!=EM) break;</p>
<p>blue[i-1][x][0] = i-1; blue[i - 1][x][1] = x;</p>
<p>}</p>
<p>else if (t == 2) {</p>
<p>//green</p>
<p>for (i = 2; i &lt; 11; i++) if (i &gt;= 10 || green[i][y][0] != EM || green[i][y + 1][0] != EM) break;</p>
<p>green[i-1][y][0] = i-1; green[i - 1][y][1] = y+1;</p>
<p>green[i - 1][y + 1][0] = i-1; green[i - 1][y + 1][1] = y;</p>
<p>//blue</p>
<p>for (i = 2; i &lt; 11; i++) if (i+1 &gt;= 10 ||(i+1&lt;10 &amp;&amp; blue[i+1][x][0] != EM)) break;</p>
<p>blue[i-1][x][0] = i; blue[i - 1][x][1] = x; blue[i][x][0] = i-1; blue[i][x][1]=x;</p>
<p>}</p>
<p>else if(t==3){</p>
<p>//green</p>
<p>for (i = 2; i &lt; 11; i++) if (i+1 &gt;= 10 ||(i+1&lt;10 &amp;&amp; green[i+1][y][0] != EM)) break;</p>
<p>green[i-1][y][0] = i; green[i - 1][y][1] = y;</p>
<p>green[i][y][0] = i-1; green[i][y][1] = y;</p>
<p>//blue</p>
<p>for (i = 2; i &lt; 11; i++) if (i &gt;= 10 || blue[i][x][0] != EM || blue[i][x+1][0] != EM) break;</p>
<p>blue[i-1][x][0] = i-1; blue[i - 1][x][1] =x+1;</p>
<p>blue[i-1][x+1][0] = i-1; blue[i - 1][x + 1][1] = x;</p>
<p>}</p>
<p>}</p>
<p>void RemoveRow() {</p>
<p>for (int i = 6; i &lt; 10; i++) {</p>
<p>int g_num = 0; int b_num = 0;</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (green[i][j][0] != EM) g_num += 1;</p>
<p>if (blue[i][j][0] != EM) b_num += 1;</p>
<p>}</p>
<p>if (g_num == 4) {</p>
<p>answer += 1;</p>
<p>for (int j = 0; j &lt; 4; j++) { //remove friend</p>
<p>if (green[i][j][0] &lt; 10 &amp;&amp; green[i][j][1] &lt; 4) {</p>
<p>green[green[i][j][0]][green[i][j][1]][0] = green[i][j][0];</p>
<p>green[green[i][j][0]][green[i][j][1]][1] = green[i][j][1];</p>
<p>}</p>
<p>green[i][j][0] = EM; green[i][j][1] == EM;</p>
<p>}</p>
<p>}</p>
<p>if (b_num == 4) {</p>
<p>answer += 1;</p>
<p>for (int j = 0; j &lt; 4; j++) { //remove friend</p>
<p>if (blue[i][j][0] &lt; 10 &amp;&amp; blue[i][j][1] &lt; 4) {</p>
<p>blue[blue[i][j][0]][blue[i][j][1]][0] = blue[i][j][0];</p>
<p>blue[blue[i][j][0]][blue[i][j][1]][1] = blue[i][j][1];</p>
<p>}</p>
<p>blue[i][j][0] = EM; blue[i][j][1] = EM;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void MoveDown() {</p>
<p>for (int i = 8; i &gt;= 4; i--) {</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (green[i][j][0]!=EM) {</p>
<p>int g_empty = 0;</p>
<p>if (green[i][j][0] == i &amp;&amp; green[i][j][1] == j) { //has no friend</p>
<p>for (int k = i + 1; k &lt; 10; k++) {</p>
<p>if (green[k][j][0]==EM) g_empty += 1;</p>
<p>else break;</p>
<p>}</p>
<p>green[i][j][0] = EM; green[i][j][1] = EM;</p>
<p>green[i + g_empty][j][0] = i + g_empty;</p>
<p>green[i + g_empty][j][1] = j;</p>
<p>}</p>
<p>else { //has friend</p>
<p>int fx = green[i][j][0]; int fy = green[i][j][1];</p>
<p>if (i != fx) { //vertical friend</p>
<p>int nx = i &gt; fx ? i : fx;</p>
<p>for (int k = nx + 1; k &lt; 10; k++) {</p>
<p>if (green[k][j][0] == EM) g_empty += 1;</p>
<p>else break;</p>
<p>}</p>
<p>if (g_empty &gt;= 1) {</p>
<p>green[i][j][0] = EM; green[i][j][1] = EM;</p>
<p>green[fx][fy][0] = EM; green[fx][fy][1] = EM;</p>
<p>green[nx + g_empty][j][0] = nx + g_empty - 1;</p>
<p>green[nx + g_empty][j][1] = j;</p>
<p>green[nx + g_empty - 1][j][0] = nx + g_empty;</p>
<p>green[nx + g_empty - 1][j][1] = j;</p>
<p>}</p>
<p>}</p>
<p>else { //horizon friend</p>
<p>for (int k = i + 1; k &lt; 10; k++) {</p>
<p>if (green[k][j][0]!=EM || green[k][fy][0]!=EM) break;</p>
<p>g_empty += 1;</p>
<p>}</p>
<p>if (g_empty &gt;= 1) {</p>
<p>green[i][j][0] = EM; green[i][j][1] = EM;</p>
<p>green[i][fy][0] = EM; green[i][fy][1] = EM;</p>
<p>green[i + g_empty][j][0] = i + g_empty;</p>
<p>green[i + g_empty][j][1] = fy;</p>
<p>green[i + g_empty][fy][0] = i + g_empty;</p>
<p>green[i + g_empty][fy][1] = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (blue[i][j][0]!=EM) {</p>
<p>int b_empty = 0;</p>
<p>if (blue[i][j][0] == i &amp;&amp; blue[i][j][1] == j) { //has no friend</p>
<p>for (int k = i + 1; k &lt; 10; k++) {</p>
<p>if (blue[k][j][0]==EM) b_empty += 1;</p>
<p>else break;</p>
<p>}</p>
<p>blue[i][j][0] = EM; blue[i][j][1] = EM;</p>
<p>blue[i + b_empty][j][0] = i + b_empty;</p>
<p>blue[i + b_empty][j][1] = j;</p>
<p>}</p>
<p>else { //has friend</p>
<p>int fx = blue[i][j][0]; int fy = blue[i][j][1];</p>
<p>if (i != fx) { //vertical friend</p>
<p>int nx = i &gt; fx ? i : fx;</p>
<p>for (int k = nx + 1; k &lt; 10; k++) {</p>
<p>if (blue[k][j][0]==EM) b_empty += 1;</p>
<p>else break;</p>
<p>}</p>
<p>if (b_empty &gt;= 1) {</p>
<p>blue[i][j][0] = EM; blue[i][j][1] = EM;</p>
<p>blue[fx][fy][0] = EM; blue[fx][fy][1] = EM;</p>
<p>blue[nx + b_empty][j][0] = nx + b_empty - 1;</p>
<p>blue[nx + b_empty][j][1] = j;</p>
<p>blue[nx + b_empty - 1][j][0] = nx + b_empty;</p>
<p>blue[nx + b_empty - 1][j][1] = j;</p>
<p>}</p>
<p>}</p>
<p>else { //horizon friend</p>
<p>for (int k = i + 1; k &lt; 10; k++) {</p>
<p>if (blue[k][j][0]!=EM || blue[k][fy][0]!=EM) break;</p>
<p>b_empty += 1;</p>
<p>}</p>
<p>if (b_empty &gt;= 1) {</p>
<p>blue[i][j][0] = EM; blue[i][j][1] = EM;</p>
<p>blue[i][fy][0] = EM; blue[i][fy][0] = EM;</p>
<p>blue[i + b_empty][j][0] = i + b_empty;</p>
<p>blue[i + b_empty][j][1] = fy;</p>
<p>blue[i + b_empty][fy][0] = i + b_empty;</p>
<p>blue[i + b_empty][fy][1] = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void Border() {</p>
<p>int b_num = 0; int g_num = 0;</p>
<p>for (int i = 4; i &lt;= 5; i++) {</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (green[i][j][0]!=EM) {</p>
<p>g_num += 1;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (blue[i][j][0]!=EM) {</p>
<p>b_num += 1;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (g_num &gt;= 1) {</p>
<p>for (int i = 9; i &gt;= 10 - g_num; i--) {</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (green[i][j][0] != EM) {</p>
<p>if (green[i][j][0] &lt; 10 &amp;&amp; green[i][j][1] &lt; 4) {</p>
<p>green[green[i][j][0]][green[i][j][1]][0] = green[i][j][0];</p>
<p>green[green[i][j][0]][green[i][j][1]][1] = green[i][j][1];</p>
<p>}</p>
<p>}</p>
<p>green[i][j][0] = EM; green[i][j][1] = EM;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>if (b_num &gt;= 1) {</p>
<p>for (int i = 9; i &gt;= 10 - b_num; i--) {</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (blue[i][j][0] != EM) {</p>
<p>if (blue[i][j][0] &lt; 10 &amp;&amp; blue[i][j][1] &lt; 4) {</p>
<p>blue[blue[i][j][0]][blue[i][j][1]][0] = blue[i][j][0];</p>
<p>blue[blue[i][j][0]][blue[i][j][1]][1] = blue[i][j][1];</p>
<p>}</p>
<p>}</p>
<p>blue[i][j][0] = EM; blue[i][j][1] = EM;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void getScore() {</p>
<p>for (int i = 4; i &lt; 10; i++) {</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>if (green[i][j][0]!=EM) num_shell += 1;</p>
<p>if (blue[i][j][0]!=EM) num_shell += 1;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void PrintTable() {</p>
<p>cout &lt;&lt; &quot;### GREEN ###&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;vector&lt;int&gt;&gt; row : green) {</p>
<p>for (vector&lt;int&gt; i : row) {</p>
<p>if (i[0] == EM) cout &lt;&lt; &quot;0&quot; &lt;&lt; &quot; &quot;;</p>
<p>else cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;### BLUE ###&quot; &lt;&lt; endl;</p>
<p>for (vector&lt;vector&lt;int&gt;&gt; row : blue) {</p>
<p>for (vector&lt;int&gt; i : row) {</p>
<p>if (i[0] == EM) cout &lt;&lt; &quot;0&quot; &lt;&lt; &quot; &quot;;</p>
<p>else cout &lt;&lt; &quot;1&quot; &lt;&lt; &quot; &quot;;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N;</p>
<p>order.assign(N, vector&lt;int&gt;(3, 0));</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; order[i][0] &gt;&gt; order[i][1] &gt;&gt; order[i][2];</p>
<p>}</p>
<p>//algorithm part</p>
<p>int sec = 0;</p>
<p>for (vector&lt;int&gt; row : order) {</p>
<p>int t = row[0]; int x = row[1]; int y = row[2];</p>
<p>PutAndMove(t, x, y);</p>
<p>RemoveRow();</p>
<p>MoveDown();</p>
<p>Border();</p>
<p>MoveDown();</p>
<p>RemoveRow();</p>
<p>MoveDown();</p>
<p>}</p>
<p>getScore();</p>
<p>cout &lt;&lt; answer &lt;&lt; endl;</p>
<p>cout &lt;&lt; num_shell &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>[219. SAMSUNG SW : Juvenile Shark]</p>
<p>- It was a simulation problem.</p>
<p>- I thought it was easy, actually until now. but I’ve been trapped by something so I took so much time.</p>
<p>- the trap was to syncronize fishes' position with table.</p>
<p>- I had used fishes' position vector as global variable. So the program didn’t work well.</p>
<p>- To find this trap, I spent so much time :(</p>
<p>- I didn’t used BFS. Because of that, I think it devoured much time</p>
<p>- I spent 2 hours and half or so.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;array&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define max(a,b) a&gt;b?a:b</p>
<p>using namespace std;</p>
<p>array&lt;array &lt;int, 2&gt;, 8&gt; dir = { { {-1,0},{-1,-1},{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1} } };</p>
<p>vector&lt;bool&gt; visit(16,false);</p>
<p>int answer = 0;</p>
<p>void PrintTable(vector&lt;vector&lt;int&gt;&gt;&amp; table) {</p>
<p>cout &lt;&lt; endl;</p>
<p>for (vector&lt;int&gt; row : table) {</p>
<p>for (int i : row) cout &lt;&lt; i+1 &lt;&lt; &quot; &quot;;</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>cout &lt;&lt; endl;</p>
<p>}</p>
<p>void FishSwap(vector&lt;vector&lt;int&gt;&gt;&amp; table, vector&lt;vector&lt;int&gt;&gt;&amp; fish, int a, int b) {</p>
<p>int ax = fish[a][2]; int ay = fish[a][3]; int bx = fish[b][2]; int by = fish[b][3];</p>
<p>fish[a][2] = bx; fish[a][3] = by; fish[b][2] = ax; fish[b][3] = ay;</p>
<p>table[ax][ay] = b; table[bx][by] = a;</p>
<p>}</p>
<p>void MoveFish(vector&lt;vector&lt;int&gt;&gt;&amp; table,vector&lt;vector&lt;int&gt;&gt;&amp; fish, int sx, int sy) {</p>
<p>for (int f = 0; f &lt; 16; f++) {</p>
<p>if (visit[f] == true) continue;</p>
<p>int x = fish[f][2]; int y = fish[f][3]; int d = fish[f][1];</p>
<p>int rotate_num = 0;</p>
<p>while (rotate_num&lt;8) {</p>
<p>int nx = x + dir[d][0]; int ny = y + dir[d][1];</p>
<p>if (nx &lt; 0 || ny &lt; 0 || nx &gt;= 4 || ny &gt;= 4 || (sx == nx &amp;&amp; sy == ny)) {</p>
<p>d = (d + 1) % 8;</p>
<p>rotate_num += 1;</p>
<p>continue;</p>
<p>}</p>
<p>else {</p>
<p>FishSwap(table,fish, f, table[nx][ny]);</p>
<p>fish[f][1] = d;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void MoveShark(vector&lt;vector&lt;int&gt;&gt; table,vector&lt;vector&lt;int&gt;&gt; fish,int sx, int sy, int sd, int sum,int cnt ) {</p>
<p>MoveFish(table,fish,sx,sy);</p>
<p>int nx = sx + dir[sd][0]; int ny = sy + dir[sd][1];</p>
<p>while (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; 4 &amp;&amp; ny &lt; 4 ) {</p>
<p>if (visit[table[nx][ny]] == false) {</p>
<p>visit[table[nx][ny]] = true;</p>
<p>MoveShark(table, fish, nx, ny, fish[table[nx][ny]][1], sum + table[nx][ny] + 1, cnt + 1);</p>
<p>visit[table[nx][ny]] = false;</p>
<p>}</p>
<p>nx = nx + dir[sd][0]; ny = ny + dir[sd][1];</p>
<p>}</p>
<p>answer = max(answer, sum);</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>vector&lt;vector&lt;int&gt;&gt; table(4, vector&lt;int&gt;(4, 0));</p>
<p>vector&lt;vector&lt;int&gt;&gt; fish(16, vector&lt;int&gt;(4, 0));</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>for (int j = 0; j &lt; 4; j++) {</p>
<p>cin &gt;&gt; fish[4 * i + j][0] &gt;&gt; fish[4 * i + j][1];</p>
<p>fish[4 * i + j][0] -= 1;</p>
<p>fish[4 * i + j][1] -= 1; //dir index starts at 0.</p>
<p>fish[4 * i + j][2] = i; fish[4 * i + j][3] = j; //x y position</p>
<p>table[i][j] = fish[4 * i + j][0];</p>
<p>}</p>
<p>}</p>
<p>visit[fish[0][0]] = true;</p>
<p>//algorithm part</p>
<p>int sx = 0; int sy = 0;</p>
<p>int sd; int sum = 0;</p>
<p>sd = fish[0][1]; sum = fish[0][0] + 1;</p>
<p>sort(fish.begin(), fish.end()); //sort by number</p>
<p>MoveShark(table,fish,sx,sy,sd,sum,0);</p>
<p>cout &lt;&lt; answer;</p>
<p>return 0;</p>
<p>}</p>
<p>[220. Leetcode 31 : Next Permutation]</p>
<p>- it was a quite difficult problem. Since I had to satisfy memory restriction.</p>
<p>- I was able to use only a given vector with extra constant memory.</p>
<p>- Logic is below.</p>
<p>- First, Finding first element from last index in the given vector that is lower than its right elements.</p>
<p>- Second, Finding the smallest element just right after the first element that is greater than the first element.</p>
<p>- Third, Swap the smallest element with the first element.</p>
<p>- Fourth, sort the range, I means, from just right after first element to end of the vector.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>#include&lt;algorithm&gt;</p>
<p>#define max(a,b) a&gt;b? a:b</p>
<p>using namespace std;</p>
<p>bool flag = false;</p>
<p>int main() {</p>
<p>vector&lt;int&gt; table = { 6,7,5,3,5,6,2,9,1,2,7,0,9 }; // 1234 1243 1324 1342 1423 1432</p>
<p>// we can guess that a next number is always greater than a current number.</p>
<p>int changed_index = 0;</p>
<p>int right_index = 0;</p>
<p>//To check it is last or not.</p>
<p>int i;</p>
<p>int after_num = 987654321;</p>
<p>for ( i = 0; i &lt; table.size()-1; i++) if (table[i] &lt; table[i + 1]) break;</p>
<p>if (i == table.size()-1) reverse(table.begin(), table.end());</p>
<p>else {</p>
<p>// it must be changed from last index.</p>
<p>for (int i = table.size()-1; i &gt;= 0; i--) {</p>
<p>for (int j = i + 1; j &lt; table.size(); j++) {</p>
<p>if (table[i] &lt; table[j]) {</p>
<p>changed_index = i;</p>
<p>flag = true;</p>
<p>if (table[j] &lt; after_num) {</p>
<p>after_num = table[j];</p>
<p>right_index = j;</p>
<p>}</p>
<p>//4 1 3 2 // 3 4 1 2 // 2 4 3 1 &lt;&lt;= this one have to occur.</p>
<p>}</p>
<p>}</p>
<p>if (flag) break; // if something is changed by above if syntax, we don't need to go further.</p>
<p>}</p>
<p>swap(table[changed_index], table[right_index]);</p>
<p>sort(table.begin() + 1 + changed_index , table.end());</p>
<p>}</p>
<p>for (int i : table) cout &lt;&lt; i &lt;&lt; &quot; &quot;;</p>
<p>return 0;</p>
<p>}</p>
<p>[221. SAMSUNG SW – Gas Pipe]</p>
<p>- It has been such a long time I’ve met a time limit exceed.</p>
<p>- It was a simulation problem. I’ve struggle to reach the time limit.</p>
<p>- Checking whether all the pipe is used consumed lots of computational time.</p>
<p>- So I chagend the logic just to find a possible condition to put a pipe of a certain shape.</p>
<p>- First, Finding the stolen shell.</p>
<p>- Second, Checking a possible pipe to put the shell.</p>
<p>- I spent 2 hours and 40 minutes and 20 seconds.</p>
<p>- see the code.</p>
<p>#include&lt;iostream&gt;</p>
<p>#include&lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int N, M;</p>
<p>vector&lt;vector&lt;char&gt;&gt; table;</p>
<p>int dir[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };</p>
<p>char answer;</p>
<p>int nx, ny,d;</p>
<p>void FindStartPosition(int&amp; sx, int&amp; sy) {</p>
<p>//find start direction</p>
<p>for (d = 0; d &lt; 4; d++) {</p>
<p>nx = sx + dir[d][0]; ny = sy + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != '.') {</p>
<p>if (nx == sx) { //horizontal</p>
<p>if (table[nx][ny] == '-' || table[nx][ny] == '+') break;</p>
<p>else if (ny &lt; sy &amp;&amp; (table[nx][ny] == '1' || table[nx][ny] == '2')) break;</p>
<p>else if (ny &gt; sy &amp;&amp; (table[nx][ny] == '2' || table[nx][ny] == '3')) break;</p>
<p>}</p>
<p>else { //vertical</p>
<p>if (table[nx][ny] == '|' || table[nx][ny] == '+') break;</p>
<p>else if (nx &lt; sx &amp;&amp; (table[nx][ny] == '1' || table[nx][ny] == '4')) break;</p>
<p>else if (nx &gt; sx &amp;&amp; (table[nx][ny] == '2' || table[nx][ny] == '3')) break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>sx = nx; sy = ny;</p>
<p>}</p>
<p>void Move() {</p>
<p>while (table[nx][ny] != 'Z' &amp;&amp; table[nx][ny] != '.') {</p>
<p>switch (table[nx][ny]) {</p>
<p>case '-':</p>
<p>if (d == 1) ny -= 1;</p>
<p>else if (d == 3) ny += 1;</p>
<p>else return;</p>
<p>break;</p>
<p>case '|':</p>
<p>if (d == 0) nx -= 1;</p>
<p>else if (d == 2) nx += 1;</p>
<p>else return;</p>
<p>break;</p>
<p>case '+':</p>
<p>if (d == 0) nx -= 1;</p>
<p>else if (d == 2) nx += 1;</p>
<p>else if (d == 1) ny -= 1;</p>
<p>else if (d == 3) ny += 1;</p>
<p>else return;</p>
<p>break;</p>
<p>case '1':</p>
<p>if (d == 1) {</p>
<p>nx += 1;</p>
<p>d = 2;</p>
<p>}</p>
<p>else if (d == 0) {</p>
<p>ny += 1;</p>
<p>d = 3;</p>
<p>}</p>
<p>else return;</p>
<p>break;</p>
<p>case '2':</p>
<p>if (d == 2) {</p>
<p>ny += 1;</p>
<p>d = 3;</p>
<p>}</p>
<p>else if (d == 1) {</p>
<p>nx -= 1;</p>
<p>d = 0;</p>
<p>}</p>
<p>else return;</p>
<p>break;</p>
<p>case '3':</p>
<p>if (d == 3) {</p>
<p>nx -= 1;</p>
<p>d = 0;</p>
<p>}</p>
<p>else if (d == 2) {</p>
<p>ny -= 1;</p>
<p>d = 1;</p>
<p>}</p>
<p>else return;</p>
<p>break;</p>
<p>case '4':</p>
<p>if (d == 3) {</p>
<p>nx += 1;</p>
<p>d = 2;</p>
<p>}</p>
<p>else if (d == 0) {</p>
<p>ny -= 1;</p>
<p>d = 1;</p>
<p>}</p>
<p>else return;</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>void FindPipe() {</p>
<p>vector&lt;bool&gt; around(4, false);</p>
<p>int x = nx; int y = ny;</p>
<p>for (int d = 0; d &lt; 4; d++) {</p>
<p>nx = x + dir[d][0]; ny = y + dir[d][1];</p>
<p>if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M &amp;&amp; table[nx][ny] != '.') {</p>
<p>if (d == 0 &amp;&amp; (table[nx][ny] == '|' || table[nx][ny] == '+' || table[nx][ny] == '1' || table[nx][ny] == '4')) around[d] = true;</p>
<p>else if(d==2 &amp;&amp; (table[nx][ny] == '|' || table[nx][ny] == '+' || table[nx][ny] == '2' || table[nx][ny] == '3')) around[d] = true;</p>
<p>else if (d == 1 &amp;&amp; (table[nx][ny] == '-' || table[nx][ny] == '+' || table[nx][ny] == '1' || table[nx][ny] == '2')) around[d] = true;</p>
<p>else if (d == 3 &amp;&amp; (table[nx][ny] == '-' || table[nx][ny] == '+' || table[nx][ny] == '3' || table[nx][ny] == '4')) around[d] = true;</p>
<p>}</p>
<p>}</p>
<p>if (around[0] &amp;&amp; around[1] &amp;&amp; around[2] &amp;&amp; around[3]) answer = '+';</p>
<p>else if (around[0] &amp;&amp; around[1]) answer = '3';</p>
<p>else if (around[0] &amp;&amp; around[3]) answer = '2';</p>
<p>else if (around[2] &amp;&amp; around[1]) answer = '4';</p>
<p>else if (around[2] &amp;&amp; around[3]) answer = '1';</p>
<p>else if (around[0] &amp;&amp; around[2]) answer = '|';</p>
<p>else if (around[1] &amp;&amp; around[3]) answer = '-';</p>
<p>}</p>
<p>int main() {</p>
<p>ios_base::sync_with_stdio(false);</p>
<p>cin.tie(NULL); cout.tie(NULL);</p>
<p>//get input</p>
<p>cin &gt;&gt; N &gt;&gt; M;</p>
<p>table.assign(N, vector&lt;char&gt;(M, 0));</p>
<p>int sx, sy, dx, dy;</p>
<p>string input;</p>
<p>for (int i = 0; i &lt; N; i++) {</p>
<p>cin &gt;&gt; input;</p>
<p>for (int j = 0; j &lt; M; j++) {</p>
<p>table[i][j] = input[j];</p>
<p>if (table[i][j] == 'M') {</p>
<p>sx = i; sy = j;</p>
<p>}</p>
<p>if (table[i][j] == 'Z') {</p>
<p>dx = i; dy = j;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>//algorithm part</p>
<p>int csx, csy;</p>
<p>FindStartPosition(sx, sy);</p>
<p>Move();</p>
<p>csx = nx; csy = ny;</p>
<p>FindPipe();</p>
<p>cout &lt;&lt; csx + 1 &lt;&lt; &quot; &quot; &lt;&lt; csy + 1 &lt;&lt; &quot; &quot; &lt;&lt; answer &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>{ %endraw%}</p>
</body>
</html>
