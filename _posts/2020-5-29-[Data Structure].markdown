---
layout: post
title: [Data Structure]
date: 2020-5-29
description: txt to markdown
thumbnail: food2.jpg
categories: CS_Study

# Information for the author block
author : Loui
---

```cpp

{% raw %}

**map**  
- map은 red black 트리구조 기반으로 되어있음. 그래서 특정 key를 찾을 때, O(lon n)이 보장됨.  
<span style="color:red">+ red balck 트리는 루트 와 리프노드는 블랙이고, 레드 노드의 자식은 무조건 블랙이다. 즉 레드노드가 연속적으로 올 수 없다. 또한 같은 레벨의 어떤 노드에서 시작하든, 리프까지의 경로에서 만나는 블랙 노드의 개수는 같다. </span>  
++ 이렇게 하면 가장 짧은 경우 블랙-블랙-블랙… 이고 가장 긴 경우는 블랙-레드-블랙-레드-블랙… 이렇게 되므로 최대길이가 최소 길이의 2배를 넘지 않게 된다.  
+ 삽입시, 레드로 마지막 자리에 삽입되며, uncle노드로 칭하는 부모의 형제노드의 색깔에 따라서 행동이 달라진다.  
+ uncle의 블랙일때에는, 조부모와 부모와 삽입된 노드를 정렬한 뒤, 중간크기의 노드를 루트로 하여 나머지 두 노드를 왼쪽, 오른쪽 자식으로 붙힌다.  
+ 그후 루트를 검은색, 자식을 레드로 바꾸어 주고, 언클 노드는 검은색을 유지하여, 레드노드의 자식노드로 위치를 찾아 넣어준다.  
+ uncle이 레드일때에는, 부모와 uncle을 모두 블랙으로 만든 후, 조부모를 레드로 만든다. 만약 조부모가 루트였다면, 블랙으로 바뀌지만, 조부모가 루트가 아니라면 다시 double red가 발생하여 위의 두 상황 중 하나를 채택하여야 한다.  
- 위와 같은 특성 때문에, 키 값의 분포가 고르지 못하면 insert에 대한 rotation이 지속적으로 발생하게 된다.  
**unordered_map**  
- 충분한 크기의 메모리만 주어진다면 O(1)시간에 key 값 참조가 가능함.  
- 단, 문자열을 key로 사용할 경우에는 문자열 전체를 비교해야하는 unordered_map 보다 map이 더 빠를 수 있다. 내 생각에는 map은 트리 구조 이므로, trie 트리 구조로 설계하면 O(log n)시간에 key 참조가 가능할 것 같다.  

**list**  
- 연결리스트는 각 value를 노드에 저장하고, 다음 node에 대한 pointer를 가지고 있는 것을 말한다.  
-그러므로 삽입 삭제는 O(1)에 가능하지만, 탐색은 최악의 경우 O(n)이 걸리게 된다. 첫번째부터 찾아야 하기 때문이다.  
- 물론 단방향 연결리스트였을 경우에는 끝에 삽입 또는 삭제하려면 O(n)만큼 가야한다.  
- 양방향 연결리스트로 double linked list가 있는데 deque라고 주로 읽는 것 같다.  

**queue**
- 큐는 FIFO 구조이다.  
- 우선순위 큐는 max heap, min heap 등을 이용해 주로 구현하며, 리스트나 벡터로 하면 계속 정렬을 해야해서 효율이 별로다.  

**stack**  
- 스택은 LIFO구조이다.  

**set**  
- red black tree 기반이다. 그래서 오름차순으로 소트된다.  
- 탐색은 O(log n)이고, 삽입과 삭제또한 O(log n)에 red black tree를 다시 구성하는 시간이 포함된다.  

**unordered_set**
- 소트하지 않는다. 해쉬 테이블 형식으로 구현된다.  
- 탐색은 평균 O(1)이지만, 최악의 경우 O(n)이고, 삭제는 최악의 경우 O(n)이고, 삽입은 O(1) 이라는 것이 나의 직관이다.  

<span style="color:red">**AVL tree**</span>  
- AVL 트리는 BF(Balancing Factor)를 가지고 있다. 이것은 왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀것이다. 이것의 절대값이 2 이상이 되지 않도록 함으로써, AVL트리는 균형을 지킨다.  
- 삽입시 불균형이 생기면, 불균형이 생긴 그 노드에서 손자까지 그룹으로 묶어서 정렬뒤 중간 값을 루트로 하여 BST를 만든다. 그리고 다시 BF를 계산하면 된다.  
- 만약 이때 손자들이 자식을 가지고 있었거나, 조부모가 다른 자식을 가지고 있었으면, 균형화를 위한 rotation이 끝난뒤 BST처럼 다시 삽입하면 된다.  

**graph**  
그래프는 vertex와 edge로 이루어진 자료구조로서, 주로 인접리스트로 구현된다.  
즉 각 노드는 자신과 연결된 노드를 포인터로 가리킨다. 인접리스트는 메모리는 인접행렬보다 적은 엣지수만큼만 소비하지만(+header 개수) 삽입과 삭제는 해당 노드의 edge 수 만큼 걸린다.
인접행렬은 n x n 행렬을 이용해서 서로 연결되어 있으면 1, 아니면 0으로 나타낸다.  
인접행렬은 탐색 및 수정이 O(1)시간에 할 수 있다는 장점이 있다. 하지만 메모리를 n x n 만큼 소비한다.  


{% endraw %}
```

